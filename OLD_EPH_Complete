================================================================================
OLD_EPH_Complete - Consolidated EPH-Related Files
================================================================================
Generated on: Thu Jan 15 15:02:51 UTC 2026
Repository: rork-git-ai-4-sub-ui

This file contains all EPH (Employee Plant Hours) related files consolidated
into a single document for easy download and reference.

Table of Contents:
------------------
1. Core EPH Files (7 files)
2. Billing Integration (3 files)
3. Supporting Components (6 files)
4. Utility Files (5 files)
5. Types (3 files)
6. Documentation (6 files)
7. Config (1 file)
8. Navigation Entry Points (3 files)

Total: 33 files

Note: types/ephReport.ts is listed in Core EPH Files section (counted once)

================================================================================

CATEGORY: Core EPH Files
FILE: app/eph-inbox.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { Stack } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FileText, Calendar, DollarSign, Package, CheckCircle, AlertCircle, Clock, MessageSquare, X, Inbox, Send, CreditCard } from 'lucide-react-native';
import { Colors } from '@/constants/colors';
import { useAuth } from '@/contexts/AuthContext';
import { getEPHReportsForSender } from '@/utils/ephReportManager';
import { EPHReport } from '@/types/ephReport';
import { collection, getDocs, query, where, orderBy as firestoreOrderBy } from 'firebase/firestore';
import { db } from '@/config/firebase';

type FilterStatus = 'all' | 'sent' | 'reviewed' | 'agreed' | 'disputed';
type TabType = 'inbox' | 'report' | 'payments';

export default function MachineHoursScreen() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(true);
  const [reports, setReports] = useState<EPHReport[]>([]);
  const [filteredReports, setFilteredReports] = useState<EPHReport[]>([]);
  const [filterStatus, setFilterStatus] = useState<FilterStatus>('all');
  const [activeTab, setActiveTab] = useState<TabType>('inbox');
  const [selectedReport, setSelectedReport] = useState<EPHReport | null>(null);
  const [detailsVisible, setDetailsVisible] = useState(false);
  const [detailedTimesheets, setDetailedTimesheets] = useState<any[]>([]);
  const [loadingDetails, setLoadingDetails] = useState(false);

  const loadEPHReports = useCallback(async () => {
    if (!user?.masterAccountId) return;

    try {
      setLoading(true);
      console.log('[EPH Inbox] Loading sent reports for:', user.masterAccountId);
      const fetchedReports = await getEPHReportsForSender(user.masterAccountId);
      setReports(fetchedReports);
      console.log('[EPH Inbox] Loaded', fetchedReports.length, 'sent reports');
    } catch (error) {
      console.error('[EPH Inbox] Error loading reports:', error);
      Alert.alert('Error', 'Failed to load EPH reports');
    } finally {
      setLoading(false);
    }
  }, [user?.masterAccountId]);

  useEffect(() => {
    if (user?.masterAccountId) {
      loadEPHReports();
    }
  }, [user?.masterAccountId, loadEPHReports]);

  useEffect(() => {
    if (filterStatus === 'all') {
      setFilteredReports(reports);
    } else {
      setFilteredReports(reports.filter(r => r.status === filterStatus));
    }
  }, [filterStatus, reports]);

  const handleViewDetails = async (report: EPHReport) => {
    setSelectedReport(report);
    setLoadingDetails(true);
    setDetailsVisible(true);

    try {
      console.log('[EPH Inbox] Loading timesheet details for report:', report.id);
      const timesheets: any[] = [];

      for (const assetId of report.assetIds) {
        console.log('[EPH Inbox] Fetching timesheets for asset:', assetId);
        const q = query(
          collection(db, 'plantAssetTimesheets'),
          where('assetId', '==', assetId),
          where('date', '>=', report.dateRangeFrom),
          where('date', '<=', report.dateRangeTo),
          firestoreOrderBy('date', 'desc')
        );

        const snapshot = await getDocs(q);
        snapshot.docs.forEach(doc => {
          const data = doc.data();
          timesheets.push({
            id: doc.id,
            assetId: data.assetId,
            assetType: data.assetType,
            plantNumber: data.plantNumber,
            registrationNumber: data.registrationNumber,
            date: data.date,
            totalHours: data.totalHours || 0,
            openHours: data.openHours || '00:00',
            closeHours: data.closeHours || data.closingHours || '00:00',
            operatorName: data.operatorName || 'Unknown',
            isBreakdown: data.isBreakdown || false,
            isRainDay: data.isRainDay || false,
            isStrikeDay: data.isStrikeDay || false,
            isPublicHoliday: data.isPublicHoliday || false,
            notes: data.notes || data.adminNotes || data.billingNotes || '',
          });
        });
      }

      console.log('[EPH Inbox] Loaded', timesheets.length, 'timesheet entries');
      setDetailedTimesheets(timesheets);
    } catch (error) {
      console.error('[EPH Inbox] Error loading timesheet details:', error);
      Alert.alert('Error', 'Failed to load timesheet details');
    } finally {
      setLoadingDetails(false);
    }
  };

  const getStatusColor = (status: EPHReport['status']): string => {
    switch (status) {
      case 'sent': return '#F59E0B';
      case 'reviewed': return '#3B82F6';
      case 'agreed': return '#10B981';
      case 'disputed': return '#EF4444';
      default: return '#64748B';
    }
  };

  const getStatusIcon = (status: EPHReport['status']) => {
    const color = getStatusColor(status);
    switch (status) {
      case 'sent': return <Clock size={20} color={color} />;
      case 'reviewed': return <FileText size={20} color={color} />;
      case 'agreed': return <CheckCircle size={20} color={color} />;
      case 'disputed': return <AlertCircle size={20} color={color} />;
      default: return <FileText size={20} color={color} />;
    }
  };

  const getStatusLabel = (status: EPHReport['status']): string => {
    switch (status) {
      case 'sent': return 'Awaiting Review';
      case 'reviewed': return 'Reviewed';
      case 'agreed': return 'Agreed';
      case 'disputed': return 'Disputed';
      default: return status;
    }
  };

  const formatDate = (dateStr: string): string => {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
  };

  const renderFilterButton = (label: string, status: FilterStatus, count: number) => {
    const isActive = filterStatus === status;
    return (
      <TouchableOpacity
        style={[styles.filterButton, isActive && styles.filterButtonActive]}
        onPress={() => setFilterStatus(status)}
      >
        <Text style={[styles.filterButtonText, isActive && styles.filterButtonTextActive]}>
          {label} ({count})
        </Text>
      </TouchableOpacity>
    );
  };

  const renderReportCard = (report: EPHReport) => {
    return (
      <View key={report.id} style={styles.reportCard}>
        <View style={styles.reportHeader}>
          <View style={styles.reportHeaderLeft}>
            <FileText size={24} color="#3B82F6" />
            <View style={styles.reportHeaderText}>
              <Text style={styles.reportCompany}>To: {report.recipientName}</Text>
              <Text style={styles.reportSite}>{report.siteName || 'Unknown Site'}</Text>
            </View>
          </View>
          <View style={[styles.statusBadge, { backgroundColor: `${getStatusColor(report.status)}20` }]}>
            {getStatusIcon(report.status)}
            <Text style={[styles.statusText, { color: getStatusColor(report.status) }]}>
              {getStatusLabel(report.status)}
            </Text>
          </View>
        </View>

        <View style={styles.reportInfo}>
          <View style={styles.reportInfoRow}>
            <Calendar size={16} color={Colors.textSecondary} />
            <Text style={styles.reportInfoLabel}>Period:</Text>
            <Text style={styles.reportInfoValue}>
              {formatDate(report.dateRangeFrom)} - {formatDate(report.dateRangeTo)}
            </Text>
          </View>

          <View style={styles.reportInfoRow}>
            <Package size={16} color={Colors.textSecondary} />
            <Text style={styles.reportInfoLabel}>Assets:</Text>
            <Text style={styles.reportInfoValue}>{report.totalAssets}</Text>
          </View>

          <View style={styles.reportInfoRow}>
            <Clock size={16} color={Colors.textSecondary} />
            <Text style={styles.reportInfoLabel}>Total Hours:</Text>
            <Text style={styles.reportInfoValue}>{report.totalHours.toFixed(1)}h</Text>
          </View>

          <View style={styles.reportInfoRow}>
            <DollarSign size={16} color={Colors.textSecondary} />
            <Text style={styles.reportInfoLabel}>Total Cost:</Text>
            <Text style={styles.reportCost}>R{report.totalCost.toFixed(2)}</Text>
          </View>
        </View>

        {report.message && (
          <View style={styles.messageBox}>
            <MessageSquare size={14} color={Colors.textSecondary} />
            <Text style={styles.messageText}>{report.message}</Text>
          </View>
        )}

        {report.disputeNotes && (
          <View style={styles.disputeBox}>
            <AlertCircle size={14} color="#EF4444" />
            <Text style={styles.disputeText}>{report.disputeNotes}</Text>
          </View>
        )}

        <TouchableOpacity
          style={styles.viewDetailsButton}
          onPress={() => handleViewDetails(report)}
        >
          <FileText size={16} color="#3B82F6" />
          <Text style={styles.viewDetailsButtonText}>View Line Items</Text>
        </TouchableOpacity>

        <View style={styles.reportFooter}>
          <Text style={styles.reportFooterText}>
            Sent: {report.sentAt ? new Date(report.sentAt.seconds * 1000).toLocaleDateString('en-GB') : 'Unknown'}
          </Text>
          {report.agreedAt && (
            <Text style={styles.reportFooterText}>
              Agreed: {new Date(report.agreedAt.seconds * 1000).toLocaleDateString('en-GB')}
            </Text>
          )}
        </View>
      </View>
    );
  };

  const statusCounts = {
    all: reports.length,
    sent: reports.filter(r => r.status === 'sent').length,
    reviewed: reports.filter(r => r.status === 'reviewed').length,
    agreed: reports.filter(r => r.status === 'agreed').length,
    disputed: reports.filter(r => r.status === 'disputed').length,
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <Stack.Screen
        options={{
          title: 'Machine Hours',
          headerStyle: { backgroundColor: Colors.headerBg },
          headerTintColor: Colors.text,
        }}
      />

      <View style={styles.tabsContainer}>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'inbox' && styles.tabActive]}
          onPress={() => setActiveTab('inbox')}
        >
          <Inbox size={20} color={activeTab === 'inbox' ? '#3B82F6' : Colors.textSecondary} />
          <Text style={[styles.tabText, activeTab === 'inbox' && styles.tabTextActive]}>EPH Reports</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'report' && styles.tabActive]}
          onPress={() => setActiveTab('report')}
        >
          <Send size={20} color={activeTab === 'report' ? '#3B82F6' : Colors.textSecondary} />
          <Text style={[styles.tabText, activeTab === 'report' && styles.tabTextActive]}>EPH Approvals</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'payments' && styles.tabActive]}
          onPress={() => setActiveTab('payments')}
        >
          <CreditCard size={20} color={activeTab === 'payments' ? '#3B82F6' : Colors.textSecondary} />
          <Text style={[styles.tabText, activeTab === 'payments' && styles.tabTextActive]}>EPH Payments</Text>
        </TouchableOpacity>
      </View>

      {activeTab === 'inbox' && (
        loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={Colors.accent} />
            <Text style={styles.loadingText}>Loading EPH reports...</Text>
          </View>
        ) : (
          <>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.filterContainer}
              contentContainerStyle={styles.filterContent}
            >
              {renderFilterButton('All', 'all', statusCounts.all)}
              {renderFilterButton('Awaiting', 'sent', statusCounts.sent)}
              {renderFilterButton('Reviewed', 'reviewed', statusCounts.reviewed)}
              {renderFilterButton('Agreed', 'agreed', statusCounts.agreed)}
              {renderFilterButton('Disputed', 'disputed', statusCounts.disputed)}
            </ScrollView>

            <ScrollView style={styles.content}>
              {filteredReports.length === 0 ? (
                <View style={styles.emptyContainer}>
                  <FileText size={64} color={Colors.textSecondary} />
                  <Text style={styles.emptyText}>No EPH reports sent</Text>
                  <Text style={styles.emptySubtext}>
                    EPH reports you send to subcontractors will appear here
                  </Text>
                </View>
              ) : (
                <View style={styles.reportsContainer}>
                  {filteredReports.map(report => renderReportCard(report))}
                </View>
              )}
            </ScrollView>
          </>
        )
      )}

      {activeTab === 'report' && (
        <ScrollView style={styles.content}>
          <View style={styles.emptyContainer}>
            <Send size={64} color={Colors.textSecondary} />
            <Text style={styles.emptyText}>EPH Approvals</Text>
            <Text style={styles.emptySubtext}>
              Review and approve EPH reports from sites
            </Text>
          </View>
        </ScrollView>
      )}

      {activeTab === 'payments' && (
        <ScrollView style={styles.content}>
          <View style={styles.emptyContainer}>
            <CreditCard size={64} color={Colors.textSecondary} />
            <Text style={styles.emptyText}>EPH Payments</Text>
            <Text style={styles.emptySubtext}>
              Process payments for agreed EPH reports
            </Text>
          </View>
        </ScrollView>
      )}

      {detailsVisible && selectedReport && (
        <View style={styles.modalOverlay}>
          <View style={styles.detailsModalContent}>
            <View style={styles.detailsHeader}>
              <View>
                <Text style={styles.detailsTitle}>EPH Report Details</Text>
                <Text style={styles.detailsSubtitle}>Sent to: {selectedReport.recipientName}</Text>
              </View>
              <TouchableOpacity
                onPress={() => {
                  setDetailsVisible(false);
                  setSelectedReport(null);
                  setDetailedTimesheets([]);
                }}
                style={styles.closeButton}
              >
                <X size={24} color={Colors.text} />
              </TouchableOpacity>
            </View>

            {loadingDetails ? (
              <View style={styles.detailsLoading}>
                <ActivityIndicator size="large" color={Colors.accent} />
                <Text style={styles.loadingText}>Loading timesheet details...</Text>
              </View>
            ) : (
              <ScrollView style={styles.detailsContent}>
                <View style={styles.detailsSummary}>
                  <Text style={styles.summaryLabel}>Total Hours: {selectedReport.totalHours.toFixed(1)}h</Text>
                  <Text style={styles.summaryLabel}>Total Cost: R{selectedReport.totalCost.toFixed(2)}</Text>
                  <Text style={styles.summaryLabel}>Assets: {selectedReport.totalAssets}</Text>
                </View>

                {detailedTimesheets.length === 0 ? (
                  <Text style={styles.noTimesheetsText}>No timesheet entries found</Text>
                ) : (
                  <View style={styles.timesheetsContainer}>
                    {detailedTimesheets.map((timesheet, index) => (
                      <View key={`${timesheet.id}-${index}`} style={styles.timesheetCard}>
                        <View style={styles.timesheetHeader}>
                          <View style={styles.timesheetHeaderLeft}>
                            <Text style={styles.timesheetAsset}>
                              {timesheet.assetType} - {timesheet.plantNumber || timesheet.registrationNumber}
                            </Text>
                            <Text style={styles.timesheetDate}>{timesheet.date}</Text>
                          </View>
                        </View>

                        <View style={styles.timesheetDetails}>
                          <View style={styles.timesheetRow}>
                            <Text style={styles.timesheetLabel}>Operator:</Text>
                            <Text style={styles.timesheetValue}>{timesheet.operatorName}</Text>
                          </View>
                          <View style={styles.timesheetRow}>
                            <Text style={styles.timesheetLabel}>Hours:</Text>
                            <Text style={styles.timesheetValue}>{timesheet.totalHours}h</Text>
                          </View>
                          <View style={styles.timesheetRow}>
                            <Text style={styles.timesheetLabel}>Open/Close:</Text>
                            <Text style={styles.timesheetValue}>
                              {timesheet.openHours} - {timesheet.closeHours}
                            </Text>
                          </View>

                          {(timesheet.isBreakdown || timesheet.isRainDay || timesheet.isStrikeDay || timesheet.isPublicHoliday) && (
                            <View style={styles.conditionsRow}>
                              {timesheet.isBreakdown && (
                                <View style={styles.conditionBadge}>
                                  <Text style={styles.conditionText}>Breakdown</Text>
                                </View>
                              )}
                              {timesheet.isRainDay && (
                                <View style={styles.conditionBadge}>
                                  <Text style={styles.conditionText}>Rain</Text>
                                </View>
                              )}
                              {timesheet.isStrikeDay && (
                                <View style={styles.conditionBadge}>
                                  <Text style={styles.conditionText}>Strike</Text>
                                </View>
                              )}
                              {timesheet.isPublicHoliday && (
                                <View style={styles.conditionBadge}>
                                  <Text style={styles.conditionText}>Holiday</Text>
                                </View>
                              )}
                            </View>
                          )}

                          {timesheet.notes && (
                            <View style={styles.timesheetNotes}>
                              <Text style={styles.notesText}>{timesheet.notes}</Text>
                            </View>
                          )}
                        </View>
                      </View>
                    ))}
                  </View>
                )}
              </ScrollView>
            )}
          </View>
        </View>
      )}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
    color: Colors.textSecondary,
  },
  filterContainer: {
    backgroundColor: Colors.surface,
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  filterContent: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    gap: 8,
  },
  filterButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: Colors.cardBg,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  filterButtonActive: {
    backgroundColor: '#3B82F6',
    borderColor: '#3B82F6',
  },
  filterButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: Colors.text,
  },
  filterButtonTextActive: {
    color: '#fff',
  },
  content: {
    flex: 1,
  },
  emptyContainer: {
    paddingVertical: 64,
    alignItems: 'center',
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    fontWeight: '600' as const,
    color: Colors.text,
  },
  emptySubtext: {
    marginTop: 4,
    fontSize: 14,
    color: Colors.textSecondary,
    textAlign: 'center',
    paddingHorizontal: 32,
  },
  reportsContainer: {
    padding: 16,
    gap: 16,
  },
  reportCard: {
    backgroundColor: Colors.cardBg,
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  reportHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  reportHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    gap: 12,
  },
  reportHeaderText: {
    flex: 1,
  },
  reportCompany: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: Colors.text,
    marginBottom: 2,
  },
  reportSite: {
    fontSize: 13,
    color: Colors.textSecondary,
  },
  statusBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600' as const,
  },
  reportInfo: {
    gap: 12,
    marginBottom: 16,
  },
  reportInfoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  reportInfoLabel: {
    fontSize: 14,
    color: Colors.textSecondary,
  },
  reportInfoValue: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: Colors.text,
  },
  reportCost: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#10B981',
  },
  messageBox: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
    padding: 12,
    backgroundColor: '#DBEAFE',
    borderRadius: 8,
    marginBottom: 16,
  },
  messageText: {
    flex: 1,
    fontSize: 13,
    color: '#1E40AF',
    lineHeight: 18,
  },
  disputeBox: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
    padding: 12,
    backgroundColor: '#FEE2E2',
    borderRadius: 8,
    marginBottom: 16,
  },
  disputeText: {
    flex: 1,
    fontSize: 13,
    color: '#991B1B',
    lineHeight: 18,
  },
  reportFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: Colors.border,
  },
  reportFooterText: {
    fontSize: 12,
    color: Colors.textSecondary,
  },
  viewDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 10,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#3B82F6',
    borderRadius: 8,
  },
  viewDetailsButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#3B82F6',
  },
  detailsModalContent: {
    backgroundColor: Colors.cardBg,
    borderRadius: 16,
    width: '95%',
    maxWidth: 800,
    maxHeight: '90%',
  },
  detailsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  detailsTitle: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: Colors.text,
  },
  detailsSubtitle: {
    fontSize: 14,
    color: Colors.textSecondary,
    marginTop: 2,
  },
  closeButton: {
    padding: 4,
  },
  detailsLoading: {
    padding: 40,
    alignItems: 'center',
  },
  detailsContent: {
    flex: 1,
  },
  detailsSummary: {
    padding: 16,
    backgroundColor: '#F1F5F9',
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  summaryLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: Colors.text,
    marginBottom: 4,
  },
  noTimesheetsText: {
    padding: 40,
    textAlign: 'center',
    fontSize: 14,
    color: Colors.textSecondary,
  },
  timesheetsContainer: {
    padding: 16,
    gap: 12,
  },
  timesheetCard: {
    backgroundColor: Colors.surface,
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  timesheetHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 8,
  },
  timesheetHeaderLeft: {
    flex: 1,
  },
  timesheetAsset: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: Colors.text,
  },
  timesheetDate: {
    fontSize: 12,
    color: Colors.textSecondary,
    marginTop: 2,
  },
  timesheetDetails: {
    gap: 6,
  },
  timesheetRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  timesheetLabel: {
    fontSize: 13,
    color: Colors.textSecondary,
  },
  timesheetValue: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: Colors.text,
  },
  conditionsRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 6,
    marginTop: 4,
  },
  conditionBadge: {
    paddingHorizontal: 8,
    paddingVertical: 3,
    backgroundColor: '#DBEAFE',
    borderRadius: 4,
  },
  conditionText: {
    fontSize: 11,
    fontWeight: '600' as const,
    color: '#1E40AF',
  },
  timesheetNotes: {
    marginTop: 6,
    padding: 8,
    backgroundColor: '#F8FAFC',
    borderRadius: 4,
  },
  notesText: {
    fontSize: 12,
    color: Colors.text,
    fontStyle: 'italic' as const,
  },
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  tabsContainer: {
    flexDirection: 'row',
    backgroundColor: Colors.surface,
    borderBottomWidth: 1,
    borderBottomColor: Colors.border,
  },
  tab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 16,
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  tabActive: {
    borderBottomColor: '#3B82F6',
  },
  tabText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: Colors.textSecondary,
  },
  tabTextActive: {
    color: '#3B82F6',
  },
});


--- END OF FILE: app/eph-inbox.tsx ---


================================================================================
CATEGORY: Core EPH Files
FILE: app/eph-menu.tsx
================================================================================

import { Stack } from 'expo-router';
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function EphMenuScreen() {
  return (
    <View style={styles.container} testID="eph-menu-screen">
      <Stack.Screen
        options={{
          headerTitle: 'Machine Hours (EPH)',
          headerStyle: {
            backgroundColor: '#0b4a6b',
          },
          headerTintColor: '#ffffff',
          headerTitleStyle: {
            fontWeight: '600' as const,
          },
        }}
      />

      <View style={styles.content}>
        <Text style={styles.title}>EPH</Text>
        <Text style={styles.subtitle}>Menu coming soon.</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  content: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: '800' as const,
    color: '#0f172a',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#475569',
    lineHeight: 22,
  },
});


--- END OF FILE: app/eph-menu.tsx ---


================================================================================
CATEGORY: Core EPH Files
FILE: utils/ephReportManager.ts
================================================================================

import { collection, doc, setDoc, getDocs, getDoc, query, where, orderBy, updateDoc, Timestamp } from 'firebase/firestore';
import { db } from '@/config/firebase';
import { EPHReport, EPHRecipientType, LineItemDispute } from '@/types/ephReport';
import { PlantAsset } from '@/types';

export type AssetOwnerInfo = {
  recipientType: EPHRecipientType;
  recipientId: string;
  recipientName: string;
  recipientEmail?: string;
  recipientMasterAccountId?: string;
};

export function determineAssetOwner(asset: PlantAsset): AssetOwnerInfo {
  console.log('[ephReportManager] Determining owner for asset:', asset.assetId, {
    ownerType: asset.ownerType,
    ownerId: asset.ownerId,
    ownerMasterAccountId: asset.ownerMasterAccountId,
    ownerName: asset.ownerName,
  });

  if (asset.ownerType === 'subcontractor' && asset.ownerId) {
    return {
      recipientType: 'subcontractor',
      recipientId: asset.ownerId,
      recipientName: asset.ownerName || 'Unknown Subcontractor',
      recipientEmail: asset.ownerEmail,
    };
  }
  
  if (asset.ownerType === 'company' && asset.ownerMasterAccountId) {
    return {
      recipientType: 'free_user',
      recipientId: asset.ownerMasterAccountId,
      recipientName: asset.ownerName || asset.ownerContactName || 'Free User',
      recipientEmail: asset.ownerEmail,
      recipientMasterAccountId: asset.ownerMasterAccountId,
    };
  }
  
  throw new Error(`Cannot determine asset owner for ${asset.assetId}. Missing ownerId or ownerMasterAccountId.`);
}

export async function createEPHReport(params: {
  ownerInfo: AssetOwnerInfo;
  senderMasterAccountId: string;
  senderCompanyName: string;
  siteId: string;
  siteName?: string;
  dateRangeFrom: Date;
  dateRangeTo: Date;
  assetIds: string[];
  totalHours: number;
  totalCost: number;
  message?: string;
  pdfUrl?: string;
  sentBy: string;
}): Promise<string> {
  console.log('[ephReportManager] Creating EPH report:', {
    recipientType: params.ownerInfo.recipientType,
    recipientId: params.ownerInfo.recipientId,
    assetCount: params.assetIds.length,
  });

  const reportRef = doc(collection(db, 'ephReports'));
  const reportId = `EPH-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
  
  const reportData: EPHReport = {
    id: reportRef.id,
    reportId,
    status: 'sent',
    recipientType: params.ownerInfo.recipientType,
    recipientId: params.ownerInfo.recipientId,
    recipientName: params.ownerInfo.recipientName,
    recipientEmail: params.ownerInfo.recipientEmail,
    recipientMasterAccountId: params.ownerInfo.recipientMasterAccountId,
    senderMasterAccountId: params.senderMasterAccountId,
    senderCompanyName: params.senderCompanyName,
    siteId: params.siteId,
    siteName: params.siteName,
    dateRangeFrom: params.dateRangeFrom.toISOString().split('T')[0],
    dateRangeTo: params.dateRangeTo.toISOString().split('T')[0],
    assetIds: params.assetIds,
    totalAssets: params.assetIds.length,
    totalHours: params.totalHours,
    totalCost: params.totalCost,
    message: params.message,
    pdfUrl: params.pdfUrl,
    sentAt: Timestamp.now(),
    sentBy: params.sentBy,
    createdAt: Timestamp.now(),
  };
  
  await setDoc(reportRef, reportData);
  
  console.log('[ephReportManager] EPH report created:', reportRef.id);
  return reportRef.id;
}

export async function getEPHReportsForRecipient(
  recipientMasterAccountId: string,
  status?: EPHReport['status']
): Promise<EPHReport[]> {
  console.log('[ephReportManager] Fetching EPH reports for recipient:', recipientMasterAccountId);

  let q = query(
    collection(db, 'ephReports'),
    where('recipientMasterAccountId', '==', recipientMasterAccountId),
    orderBy('createdAt', 'desc')
  );

  if (status) {
    q = query(
      collection(db, 'ephReports'),
      where('recipientMasterAccountId', '==', recipientMasterAccountId),
      where('status', '==', status),
      orderBy('createdAt', 'desc')
    );
  }

  const snapshot = await getDocs(q);
  const reports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as EPHReport));
  
  console.log('[ephReportManager] Found', reports.length, 'EPH reports');
  return reports;
}

export async function getEPHReportsForSender(
  senderMasterAccountId: string,
  status?: EPHReport['status']
): Promise<EPHReport[]> {
  console.log('[ephReportManager] Fetching EPH reports for sender:', senderMasterAccountId);

  let q = query(
    collection(db, 'ephReports'),
    where('senderMasterAccountId', '==', senderMasterAccountId),
    orderBy('sentAt', 'desc')
  );

  if (status) {
    q = query(
      collection(db, 'ephReports'),
      where('senderMasterAccountId', '==', senderMasterAccountId),
      where('status', '==', status),
      orderBy('sentAt', 'desc')
    );
  }

  const snapshot = await getDocs(q);
  const reports = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as EPHReport));
  
  console.log('[ephReportManager] Found', reports.length, 'EPH reports');
  return reports;
}

export async function approveEPHReport(
  reportId: string,
  userId: string
): Promise<void> {
  console.log('[ephReportManager] Approving EPH report:', reportId);

  await updateDoc(doc(db, 'ephReports', reportId), {
    status: 'agreed',
    reviewedAt: Timestamp.now(),
    reviewedBy: userId,
    agreedAt: Timestamp.now(),
    agreedBy: userId,
    updatedAt: Timestamp.now(),
  });

  console.log('[ephReportManager] EPH report approved');
}

export async function disputeEPHReport(
  reportId: string,
  userId: string,
  notes: string,
  lineItemDisputes?: LineItemDispute[]
): Promise<void> {
  console.log('[ephReportManager] Disputing EPH report:', reportId);

  await updateDoc(doc(db, 'ephReports', reportId), {
    status: 'disputed',
    reviewedAt: Timestamp.now(),
    reviewedBy: userId,
    disputeNotes: notes,
    lineItemDisputes: lineItemDisputes || [],
    updatedAt: Timestamp.now(),
  });

  console.log('[ephReportManager] EPH report disputed');
}

export async function getEPHReportDetails(
  reportId: string
): Promise<EPHReport | null> {
  console.log('[ephReportManager] Fetching EPH report details:', reportId);

  const docRef = doc(db, 'ephReports', reportId);
  const snapshot = await getDoc(docRef);

  if (!snapshot.exists()) {
    console.log('[ephReportManager] Report not found');
    return null;
  }

  return { id: snapshot.id, ...snapshot.data() } as EPHReport;
}

export async function markEPHAsReviewed(
  reportId: string,
  userId: string
): Promise<void> {
  console.log('[ephReportManager] Marking EPH as reviewed:', reportId);

  await updateDoc(doc(db, 'ephReports', reportId), {
    status: 'reviewed',
    reviewedAt: Timestamp.now(),
    reviewedBy: userId,
    updatedAt: Timestamp.now(),
  });

  console.log('[ephReportManager] EPH report marked as reviewed');
}


--- END OF FILE: utils/ephReportManager.ts ---


================================================================================
CATEGORY: Core EPH Files
FILE: utils/ephEmailService.ts
================================================================================

import * as MailComposer from 'expo-mail-composer';
import { Platform, Alert } from 'react-native';

export async function sendEPHToSubcontractor(params: {
  recipientEmail: string;
  message: string;
  pdfUri: string;
  pdfFileName: string;
  subcontractorName: string;
  dateRange: { from: Date; to: Date };
  assetCount: number;
  totalHours: number;
  companyName: string;
}): Promise<void> {
  console.log('[ephEmailService] Sending EPH to subcontractor:', params.recipientEmail);
  
  const { recipientEmail, message, pdfUri, pdfFileName, subcontractorName, dateRange, assetCount, totalHours, companyName } = params;
  
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };
  
  const subject = `EPH Report for Review - ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)} - ${subcontractorName}`;
  
  const body = `Dear ${subcontractorName},

Please find attached the Equipment/Plant Hours (EPH) report for the period ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)}.

Assets Included: ${assetCount}
Total Hours: ${totalHours.toFixed(1)}h

${message ? `\n${message}\n\n` : ''}Please review the hours and respond with any corrections or approval.

Thank you,
${companyName}`;
  
  if (Platform.OS === 'web') {
    console.log('[ephEmailService] Web platform - opening email composer simulation');
    Alert.alert(
      'Email Composer',
      `Would open email to:\n${recipientEmail}\n\nSubject: ${subject}\n\nWith PDF attachment: ${pdfFileName}\n\nThis is a simulation on web. On mobile, this would open your email client.`,
      [{ text: 'OK' }]
    );
    return;
  }
  
  const isAvailable = await MailComposer.isAvailableAsync();
  if (!isAvailable) {
    throw new Error('Email composer not available on this device');
  }
  
  await MailComposer.composeAsync({
    recipients: [recipientEmail],
    subject,
    body,
    attachments: [pdfUri],
  });
  
  console.log('[ephEmailService] Email composer opened successfully');
}

export async function sendAgreementConfirmationToSubcontractor(params: {
  recipientEmail: string;
  subcontractorName: string;
  dateRange: { from: Date; to: Date };
  assetCount: number;
  totalHours: number;
  agreedBy: string;
  companyName: string;
}): Promise<void> {
  console.log('[ephEmailService] Sending agreement confirmation:', params.recipientEmail);
  
  const { recipientEmail, subcontractorName, dateRange, assetCount, totalHours, agreedBy, companyName } = params;
  
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };
  
  const subject = `EPH Agreement Confirmed - ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)}`;
  
  const body = `Dear ${subcontractorName},

This confirms that the Equipment/Plant Hours (EPH) report for the period ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)} has been finalized and agreed.

Assets: ${assetCount}
Total Hours: ${totalHours.toFixed(1)}h
Agreed By: ${agreedBy}
Date: ${formatDate(new Date())}

The agreed timesheets are now ready for payment processing.

Thank you,
${companyName}`;
  
  if (Platform.OS === 'web') {
    console.log('[ephEmailService] Web platform - showing confirmation');
    Alert.alert(
      'Agreement Confirmation',
      `Would send confirmation email to:\n${recipientEmail}\n\nSubject: ${subject}`,
      [{ text: 'OK' }]
    );
    return;
  }
  
  const isAvailable = await MailComposer.isAvailableAsync();
  if (!isAvailable) {
    console.log('[ephEmailService] Email not available, skipping confirmation email');
    return;
  }
  
  await MailComposer.composeAsync({
    recipients: [recipientEmail],
    subject,
    body,
  });
  
  console.log('[ephEmailService] Confirmation email opened successfully');
}


--- END OF FILE: utils/ephEmailService.ts ---


================================================================================
CATEGORY: Core EPH Files
FILE: utils/ephPendingEditsManager.ts
================================================================================

import { collection, doc, setDoc, getDocs, query, where, updateDoc, Timestamp, orderBy } from 'firebase/firestore';
import { db } from '@/config/firebase';

export type EPHPendingEdit = {
  id: string;
  originalTimesheetId: string;
  assetId: string;
  assetType: string;
  plantNumber?: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedByName: string;
  
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  
  status: 'pending_review' | 'reviewed' | 'superseded';
  reviewedBy?: string;
  reviewedAt?: Timestamp;
  
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
  
  createdAt: Timestamp;
  updatedAt: Timestamp;
};

export async function createPendingEdit(params: {
  originalTimesheetId: string;
  assetId: string;
  assetType: string;
  plantNumber?: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedByName: string;
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
}): Promise<string> {
  console.log('[ephPendingEditsManager] Creating pending edit for asset:', params.assetId);
  
  const existingEdits = await getPendingEditsByAsset(params.assetId, params.date, params.masterAccountId);
  for (const edit of existingEdits) {
    await supersedePendingEdit(edit.id);
  }
  
  const editRef = doc(collection(db, 'ephPendingEdits'));
  const editId = editRef.id;
  
  const editData: EPHPendingEdit = {
    ...params,
    id: editId,
    status: 'pending_review',
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };
  
  await setDoc(editRef, editData);
  
  console.log('[ephPendingEditsManager] Pending edit created:', editId);
  return editId;
}

export async function getPendingEditsByAsset(
  assetId: string,
  date: string,
  masterAccountId: string
): Promise<EPHPendingEdit[]> {
  console.log('[ephPendingEditsManager] Fetching pending edits for asset:', assetId, 'date:', date);
  
  const q = query(
    collection(db, 'ephPendingEdits'),
    where('assetId', '==', assetId),
    where('date', '==', date),
    where('masterAccountId', '==', masterAccountId),
    where('status', '==', 'pending_review'),
    orderBy('createdAt', 'desc')
  );
  
  const snapshot = await getDocs(q);
  const edits = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as EPHPendingEdit);
  
  console.log('[ephPendingEditsManager] Found pending edits:', edits.length);
  return edits;
}

export async function getAllPendingEditsByAssetId(
  assetId: string,
  masterAccountId: string
): Promise<EPHPendingEdit[]> {
  console.log('[ephPendingEditsManager] Fetching all pending edits for asset:', assetId);
  
  const q = query(
    collection(db, 'ephPendingEdits'),
    where('assetId', '==', assetId),
    where('masterAccountId', '==', masterAccountId),
    where('status', '==', 'pending_review'),
    orderBy('date', 'desc')
  );
  
  const snapshot = await getDocs(q);
  const edits = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as EPHPendingEdit);
  
  console.log('[ephPendingEditsManager] Found pending edits:', edits.length);
  return edits;
}

export async function supersedePendingEdit(editId: string): Promise<void> {
  console.log('[ephPendingEditsManager] Superseding pending edit:', editId);
  
  await updateDoc(doc(db, 'ephPendingEdits', editId), {
    status: 'superseded',
    updatedAt: Timestamp.now(),
  });
  
  console.log('[ephPendingEditsManager] Pending edit superseded');
}

export async function reviewPendingEdit(editId: string, reviewedBy: string): Promise<void> {
  console.log('[ephPendingEditsManager] Reviewing pending edit:', editId);
  
  await updateDoc(doc(db, 'ephPendingEdits', editId), {
    status: 'reviewed',
    reviewedBy,
    reviewedAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  });
  
  console.log('[ephPendingEditsManager] Pending edit reviewed');
}


--- END OF FILE: utils/ephPendingEditsManager.ts ---


================================================================================
CATEGORY: Core EPH Files
FILE: types/ephReport.ts
================================================================================

export type EPHReportStatus = 'draft' | 'sent' | 'reviewed' | 'agreed' | 'disputed';

export type EPHRecipientType = 'subcontractor' | 'free_user';

export type LineItemDispute = {
  assetId: string;
  timesheetId: string;
  date: string;
  disputeNotes: string;
  originalHours: number;
  disputedHours?: number;
  createdAt: any;
  createdBy: string;
};

export type EPHReport = {
  id?: string;
  reportId: string;
  status: EPHReportStatus;
  
  recipientType: EPHRecipientType;
  recipientId: string;
  recipientName: string;
  recipientEmail?: string;
  recipientMasterAccountId?: string;
  
  senderMasterAccountId: string;
  senderCompanyName: string;
  siteId: string;
  siteName?: string;
  
  dateRangeFrom: string;
  dateRangeTo: string;
  assetIds: string[];
  totalAssets: number;
  totalHours: number;
  totalCost: number;
  message?: string;
  pdfUrl?: string;
  
  sentAt?: any;
  sentBy?: string;
  reviewedAt?: any;
  reviewedBy?: string;
  agreedAt?: any;
  agreedBy?: string;
  disputeNotes?: string;
  lineItemDisputes?: LineItemDispute[];
  
  createdAt: any;
  updatedAt?: any;
};


--- END OF FILE: types/ephReport.ts ---


================================================================================
CATEGORY: Core EPH Files
FILE: components/accounts/EditEPHHoursModal.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  Modal,
  TouchableOpacity,
  TextInput,
  ScrollView,
  StyleSheet,
  Platform,
  Alert,
} from 'react-native';
import { X, Save } from 'lucide-react-native';

type TimesheetEntry = {
  id: string;
  date: string;
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes?: string;
  operatorName?: string;
  assetType?: string;
  plantNumber?: string;
};

export type EditedValues = {
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  adminNotes: string;
};

type Props = {
  visible: boolean;
  onClose: () => void;
  onSave: (editedValues: EditedValues) => Promise<void>;
  timesheet: TimesheetEntry | null;
};

export default function EditEPHHoursModal({ visible, onClose, onSave, timesheet }: Props) {
  const [totalHours, setTotalHours] = useState<string>('0');
  const [openHours, setOpenHours] = useState<string>('00:00');
  const [closeHours, setCloseHours] = useState<string>('00:00');
  const [isBreakdown, setIsBreakdown] = useState<boolean>(false);
  const [isRainDay, setIsRainDay] = useState<boolean>(false);
  const [isStrikeDay, setIsStrikeDay] = useState<boolean>(false);
  const [isPublicHoliday, setIsPublicHoliday] = useState<boolean>(false);
  const [adminNotes, setAdminNotes] = useState<string>('');
  const [saving, setSaving] = useState<boolean>(false);

  useEffect(() => {
    if (timesheet) {
      setTotalHours(timesheet.totalHours.toString());
      setOpenHours(timesheet.openHours || '00:00');
      setCloseHours(timesheet.closeHours || '00:00');
      setIsBreakdown(timesheet.isBreakdown || false);
      setIsRainDay(timesheet.isRainDay || false);
      setIsStrikeDay(timesheet.isStrikeDay || false);
      setIsPublicHoliday(timesheet.isPublicHoliday || false);
      setAdminNotes('');
    }
  }, [timesheet]);

  const handleSave = async () => {
    const totalHoursNum = parseFloat(totalHours);

    if (isNaN(totalHoursNum) || totalHoursNum < 0) {
      Alert.alert('Invalid Hours', 'Please enter valid total hours');
      return;
    }

    setSaving(true);
    try {
      await onSave({
        totalHours: totalHoursNum,
        openHours,
        closeHours,
        isBreakdown,
        isRainDay,
        isStrikeDay,
        isPublicHoliday,
        adminNotes,
      });
      onClose();
    } catch (error) {
      console.error('[EditEPHHoursModal] Error saving:', error);
      Alert.alert('Error', 'Failed to save edits. Please try again.');
    } finally {
      setSaving(false);
    }
  };

  if (!timesheet) return null;

  return (
    <Modal visible={visible} animationType="slide" transparent={true}>
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <View style={styles.modalTitleContainer}>
              <Text style={styles.modalTitle}>Edit Hours</Text>
              <Text style={styles.modalSubtitle}>
                {timesheet.assetType || 'Asset'} - {timesheet.plantNumber || timesheet.id}
              </Text>
              <Text style={styles.modalDate}>{timesheet.date}</Text>
            </View>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.modalBody} showsVerticalScrollIndicator={false}>
            <View style={styles.originalValuesBox}>
              <Text style={styles.sectionLabel}>Plant Manager&apos;s Original Values:</Text>
              <View style={styles.originalRow}>
                <Text style={styles.originalLabel}>Total Hours:</Text>
                <Text style={styles.originalValue}>{timesheet.totalHours}h</Text>
              </View>
              <View style={styles.originalRow}>
                <Text style={styles.originalLabel}>Open Hours:</Text>
                <Text style={styles.originalValue}>{timesheet.openHours}</Text>
              </View>
              <View style={styles.originalRow}>
                <Text style={styles.originalLabel}>Close Hours:</Text>
                <Text style={styles.originalValue}>{timesheet.closeHours}</Text>
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionLabel}>Edit Total Hours</Text>
              <TextInput
                style={styles.input}
                value={totalHours}
                onChangeText={setTotalHours}
                keyboardType="decimal-pad"
                placeholder="Enter total hours"
                placeholderTextColor="#94a3b8"
              />
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionLabel}>Edit Meter Readings</Text>
              <View style={styles.row}>
                <View style={styles.halfInput}>
                  <Text style={styles.inputLabel}>Open Hours</Text>
                  <TextInput
                    style={styles.input}
                    value={openHours}
                    onChangeText={setOpenHours}
                    placeholder="00:00"
                    placeholderTextColor="#94a3b8"
                  />
                </View>
                <View style={styles.halfInput}>
                  <Text style={styles.inputLabel}>Close Hours</Text>
                  <TextInput
                    style={styles.input}
                    value={closeHours}
                    onChangeText={setCloseHours}
                    placeholder="00:00"
                    placeholderTextColor="#94a3b8"
                  />
                </View>
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionLabel}>Day Conditions</Text>
              
              <TouchableOpacity
                style={styles.checkboxRow}
                onPress={() => setIsBreakdown(!isBreakdown)}
              >
                <View style={[styles.checkbox, isBreakdown && styles.checkboxChecked]}>
                  {isBreakdown && <View style={styles.checkboxInner} />}
                </View>
                <Text style={styles.checkboxLabel}>Breakdown Day</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.checkboxRow}
                onPress={() => setIsRainDay(!isRainDay)}
              >
                <View style={[styles.checkbox, isRainDay && styles.checkboxChecked]}>
                  {isRainDay && <View style={styles.checkboxInner} />}
                </View>
                <Text style={styles.checkboxLabel}>Rain Day</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.checkboxRow}
                onPress={() => setIsStrikeDay(!isStrikeDay)}
              >
                <View style={[styles.checkbox, isStrikeDay && styles.checkboxChecked]}>
                  {isStrikeDay && <View style={styles.checkboxInner} />}
                </View>
                <Text style={styles.checkboxLabel}>Strike Day</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.checkboxRow}
                onPress={() => setIsPublicHoliday(!isPublicHoliday)}
              >
                <View style={[styles.checkbox, isPublicHoliday && styles.checkboxChecked]}>
                  {isPublicHoliday && <View style={styles.checkboxInner} />}
                </View>
                <Text style={styles.checkboxLabel}>Public Holiday</Text>
              </TouchableOpacity>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionLabel}>Admin Notes (Reason for Edit)</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={adminNotes}
                onChangeText={setAdminNotes}
                placeholder="Explain reason for editing hours..."
                placeholderTextColor="#94a3b8"
                multiline
                numberOfLines={4}
                textAlignVertical="top"
              />
            </View>
          </ScrollView>

          <View style={styles.modalFooter}>
            <TouchableOpacity
              style={[styles.button, styles.cancelButton]}
              onPress={onClose}
              disabled={saving}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.button, styles.saveButton, saving && styles.saveButtonDisabled]}
              onPress={handleSave}
              disabled={saving}
            >
              <Save size={18} color="#ffffff" />
              <Text style={styles.saveButtonText}>
                {saving ? 'Saving...' : 'Save Edits'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    width: '100%',
    maxWidth: 600,
    maxHeight: '90%',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
      },
      android: {
        elevation: 8,
      },
      web: {
        boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
      },
    }),
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  modalTitleContainer: {
    flex: 1,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  modalSubtitle: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 2,
  },
  modalDate: {
    fontSize: 13,
    color: '#94a3b8',
  },
  closeButton: {
    padding: 4,
  },
  modalBody: {
    padding: 20,
  },
  originalValuesBox: {
    backgroundColor: '#f1f5f9',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderLeftWidth: 4,
    borderLeftColor: '#3b82f6',
  },
  originalRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  originalLabel: {
    fontSize: 14,
    color: '#64748b',
  },
  originalValue: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  section: {
    marginBottom: 20,
  },
  sectionLabel: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 12,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    padding: 12,
    fontSize: 15,
    color: '#1e293b',
  },
  textArea: {
    minHeight: 100,
    paddingTop: 12,
  },
  row: {
    flexDirection: 'row',
    gap: 12,
  },
  halfInput: {
    flex: 1,
  },
  inputLabel: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 6,
  },
  checkboxRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderWidth: 2,
    borderColor: '#cbd5e1',
    borderRadius: 6,
    marginRight: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxChecked: {
    borderColor: '#3b82f6',
    backgroundColor: '#eff6ff',
  },
  checkboxInner: {
    width: 12,
    height: 12,
    backgroundColor: '#3b82f6',
    borderRadius: 3,
  },
  checkboxLabel: {
    fontSize: 15,
    color: '#1e293b',
  },
  modalFooter: {
    flexDirection: 'row',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
  },
  button: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 14,
    borderRadius: 8,
  },
  cancelButton: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  cancelButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  saveButton: {
    backgroundColor: '#3b82f6',
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
});


--- END OF FILE: components/accounts/EditEPHHoursModal.tsx ---


================================================================================
CATEGORY: Billing Integration
FILE: app/billing-config.tsx
================================================================================

import { Stack, useFocusEffect, useLocalSearchParams } from 'expo-router';
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  StyleSheet,
  Text,
  View,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Switch,
  FlatList,
  Platform,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { DollarSign, Save, Clock, Calendar, FileText, CloudRain, Wrench, AlertTriangle, ChevronDown, ChevronUp, CalendarDays, ClipboardList, Edit3, CheckSquare, Square, Send, GitCompare } from 'lucide-react-native';
import { Alert } from 'react-native';
import { collection, getDocs, query, where, orderBy, doc, setDoc, getDoc } from 'firebase/firestore';
import { db } from '@/config/firebase';
import { PlantAsset, Subcontractor } from '@/types';
import { useAuth } from '@/contexts/AuthContext';
import { HeaderTitleWithSync } from '@/components/HeaderSyncStatus';
import AgreedHoursModal from '@/components/accounts/AgreedHoursModal';
import ReportGenerationModal from '@/components/accounts/ReportGenerationModal';
import EditEPHHoursModal from '@/components/accounts/EditEPHHoursModal';
import TimesheetComparisonModal from '@/components/accounts/TimesheetComparisonModal';
import SendConfirmationModal from '@/components/accounts/SendConfirmationModal';
import { agreePlantAssetTimesheet, getAgreedTimesheetByOriginalId, directApproveEPHTimesheets } from '@/utils/agreedTimesheetManager';
import { generateTimesheetPDF, downloadTimesheetPDF, emailTimesheetPDF } from '@/utils/timesheetPdfGenerator';
import { createPendingEdit, getAllPendingEditsByAssetId, supersedePendingEdit, EPHPendingEdit } from '@/utils/ephPendingEditsManager';
import { sendEPHToSubcontractor } from '@/utils/ephEmailService';
import { calculateBillableHours, BillingConfigForCalculation, BillableHoursResult } from '@/utils/billableHoursCalculator';

type BillingMethod = 'PER_HOUR' | 'MINIMUM_BILLING';

type DayTypeConfig = {
  enabled: boolean;
  billingMethod: BillingMethod;
  minHours?: number;
  rateMultiplier: number;
  customRate?: number;
};

type BillingConfig = {
  weekdays: DayTypeConfig;
  saturday: DayTypeConfig;
  sunday: DayTypeConfig;
  publicHolidays: DayTypeConfig;
  rainDays: {
    enabled: boolean;
    minHours: number;
    thresholdHours: number;
  };
  breakdown: {
    enabled: boolean;
  };
};

type TabType = 'eph' | 'timesheets';
type TimesheetsSubTab = 'machine' | 'man';
type ConfigSubTab = 'machine' | 'man';

type EPHRecord = {
  assetId: string;
  assetType: string;
  plantNumber?: string;
  registrationNumber?: string;
  rate: number;
  rateType: 'wet' | 'dry';
  // Actual/Normal hours (raw clock hours)
  actualNormalHours: number;
  actualSaturdayHours: number;
  actualSundayHours: number;
  actualPublicHolidayHours: number;
  actualBreakdownHours: number;
  actualRainDayHours: number;
  actualStrikeDayHours: number;
  totalActualHours: number;
  // Billable hours (calculated based on billing config rules)
  billableNormalHours: number;
  billableSaturdayHours: number;
  billableSundayHours: number;
  billablePublicHolidayHours: number;
  billableBreakdownHours: number;
  billableRainDayHours: number;
  billableStrikeDayHours: number;
  totalBillableHours: number;
  estimatedCost: number;
  rawTimesheets: TimesheetEntry[];
  billingResults: BillableHoursResult[];
  billingResultsByDate?: Map<string, BillableHoursResult>;
  billingResultsById?: Map<string, BillableHoursResult>;
};

type TimesheetEntry = {
  id: string;
  date: string;
  dayOfWeek: string;
  openHours: string;
  closeHours: string;
  closingHours?: string;
  totalHours: number;
  operatorName: string;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isBreakdown: boolean;
  isPublicHoliday: boolean;
  notes?: string;
  operatorNotes?: string;
  additionalNotes?: string;
  adminNotes?: string;
  billingNotes?: string;
  comment?: string;
  comments?: string;
  extraNotes?: string;
  rawNotes?: string;
  verifiedAt?: string;
  hasOriginalEntry?: boolean;
  originalEntryData?: Partial<TimesheetEntry>;
  originalEntryId?: string;
  adjustedBy?: string;
  adjustedAt?: string;
  isAdjustment?: boolean;
};

type TimesheetDisplayRow = {
  id: string;
  isoDate: string;
  dateLabel: string;
  weekdayLabel: string;
  operatorName: string;
  openHours: string;
  closeHours: string;
  totalHours: number;
  isOriginal: boolean;
  badgeLabel: 'ORIG' | 'PM';
  adjustedBy?: string;
  adjustedAt?: string;
  notes?: string;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isBreakdown: boolean;
  isPublicHoliday: boolean;
  sourceEntryId: string;
  timestamp: number;
};

type TimesheetDisplayGroup = {
  date: string;
  rows: TimesheetDisplayRow[];
  hasAdjustments: boolean;
};

const toTimeString = (value?: string | number | null): string => {
  if (value === null || value === undefined) {
    return '00:00';
  }
  return String(value);
};

const sanitizeNotes = (value?: string | null): string | undefined => {
  if (!value) {
    return undefined;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return undefined;
  }
  const normalized = trimmed
    .replace(/,/g, '.')
    .replace(/:/g, '.')
    .replace(/\s+/g, '')
    .toLowerCase();
  if (/^(\d+(\.\d+)?)(h|hr|hrs|hour|hours)?$/.test(normalized)) {
    return undefined;
  }
  const lowerTrimmed = trimmed.toLowerCase();
  const hourPatterns = [
    /^\d+[.,:]?\d*\s*(h|hr|hrs|hour|hours)$/,
    /^(h|hr|hrs|hour|hours)\s*[.,:]?\s*\d+[.,:]?\d*$/,
    /^\d+[.,:]?\d*$/,
  ];
  for (const pattern of hourPatterns) {
    if (pattern.test(lowerTrimmed)) {
      return undefined;
    }
  }
  return trimmed;
};

const noteFieldCandidates: (keyof TimesheetEntry)[] = [
  'notes',
  'operatorNotes',
  'additionalNotes',
  'adminNotes',
  'billingNotes',
  'comment',
  'comments',
  'extraNotes',
  'rawNotes',
];

const resolveDisplayNotes = (entry?: Partial<TimesheetEntry>): string | undefined => {
  if (!entry) {
    return undefined;
  }

  for (const field of noteFieldCandidates) {
    const value = entry[field];
    if (typeof value === 'string') {
      const sanitized = sanitizeNotes(value);
      if (sanitized) {
        return sanitized;
      }
    }
  }

  if (entry.originalEntryData) {
    return resolveDisplayNotes(entry.originalEntryData);
  }

  return undefined;
};

const buildDisplayRow = (
  entry: Partial<TimesheetEntry> & { id?: string },
  type: 'original' | 'adjusted',
  sourceEntryId: string,
  timestamp: number,
): TimesheetDisplayRow => {
  const isoDate = entry.date ?? new Date().toISOString();
  const dateObj = new Date(isoDate);

  return {
    id: entry.id ?? `${isoDate}-${type}-${Math.random().toString(36).slice(2, 8)}`,
    isoDate,
    dateLabel: dateObj.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' }),
    weekdayLabel: dateObj.toLocaleDateString('en-GB', { weekday: 'short' }),
    operatorName: entry.operatorName ?? 'Unknown',
    openHours: toTimeString(entry.openHours),
    closeHours: toTimeString(entry.closeHours ?? entry.closingHours),
    totalHours: Number(entry.totalHours ?? 0),
    isOriginal: type === 'original',
    badgeLabel: type === 'original' ? 'ORIG' : 'PM',
    adjustedBy: entry.adjustedBy,
    adjustedAt: entry.adjustedAt,
    notes: resolveDisplayNotes(entry),
    isRainDay: Boolean(entry.isRainDay),
    isStrikeDay: Boolean(entry.isStrikeDay),
    isBreakdown: Boolean(entry.isBreakdown),
    isPublicHoliday: Boolean(entry.isPublicHoliday),
    sourceEntryId,
    timestamp,
  };
};

const buildTimesheetGroups = (entries: TimesheetEntry[]): TimesheetDisplayGroup[] => {
  const groupMap = new Map<string, TimesheetDisplayGroup>();

  console.log('[buildTimesheetGroups] Processing', entries.length, 'entries');

  entries.forEach((entry, idx) => {
    const key = entry.date;
    if (!groupMap.has(key)) {
      groupMap.set(key, {
        date: key,
        rows: [],
        hasAdjustments: false,
      });
    }

    const group = groupMap.get(key)!;
    const sourceEntryId = getSourceEntryId(entry);
    const entryTimestamp = getEntryTimestamp(entry);
    const isPMEntry = Boolean(entry.hasOriginalEntry || entry.isAdjustment || entry.adjustedBy);

    console.log(`[buildTimesheetGroups] Entry ${idx}:`, {
      id: entry.id?.substring(0, 8),
      isPMEntry,
      hasOriginalEntry: entry.hasOriginalEntry,
      isAdjustment: entry.isAdjustment,
      adjustedBy: entry.adjustedBy,
      hasOriginalData: !!entry.originalEntryData,
      originalHours: entry.originalEntryData?.totalHours,
      currentHours: entry.totalHours,
    });

    if (isPMEntry && entry.originalEntryData) {
      console.log(`[buildTimesheetGroups] Creating ORIG row from originalEntryData for entry ${idx}`);
      const originalRow = buildDisplayRow(
        {
          ...entry.originalEntryData,
          id: entry.originalEntryId ?? `${entry.id}-orig`,
          date: entry.date,
        },
        'original',
        sourceEntryId,
        entryTimestamp - 1,
      );
      group.rows.push(originalRow);
      console.log(`[buildTimesheetGroups] Added ORIG row:`, {
        badge: originalRow.badgeLabel,
        hours: originalRow.totalHours,
        operator: originalRow.operatorName,
      });
    }

    const rowType: 'original' | 'adjusted' = isPMEntry ? 'adjusted' : 'original';
    const mainRow = buildDisplayRow(entry, rowType, sourceEntryId, entryTimestamp);
    group.rows.push(mainRow);
    console.log(`[buildTimesheetGroups] Added ${rowType.toUpperCase()} row:`, {
      badge: mainRow.badgeLabel,
      hours: mainRow.totalHours,
      operator: mainRow.operatorName,
    });
  });

  const groups = Array.from(groupMap.values()).sort(
    (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
  );

  groups.forEach((group) => {
    const dateOperatorPairs = new Map<string, { original?: TimesheetDisplayRow; pm?: TimesheetDisplayRow }>();
    
    group.rows.forEach((row) => {
      const pairKey = `${row.isoDate}-${row.sourceEntryId}`;
      if (!dateOperatorPairs.has(pairKey)) {
        dateOperatorPairs.set(pairKey, {});
      }
      const pair = dateOperatorPairs.get(pairKey)!;
      
      if (row.badgeLabel === 'ORIG') {
        if (!pair.original || row.timestamp > pair.original.timestamp) {
          pair.original = row;
        }
      } else {
        if (!pair.pm || row.timestamp > pair.pm.timestamp) {
          pair.pm = row;
        }
      }
    });

    const dedupedRows: TimesheetDisplayRow[] = [];
    dateOperatorPairs.forEach((pair) => {
      if (pair.original) {
        dedupedRows.push(pair.original);
      }
      if (pair.pm) {
        dedupedRows.push(pair.pm);
      }
    });

    dedupedRows.sort((a, b) => {
      if (a.isOriginal === b.isOriginal) {
        return b.timestamp - a.timestamp;
      }
      return a.isOriginal ? -1 : 1;
    });

    group.rows = dedupedRows;
    group.hasAdjustments = dedupedRows.some(row => !row.isOriginal);
  });

  return groups;
};

const getEntryTimestamp = (entry: TimesheetEntry): number => {
  const timestamps = [entry.adjustedAt, entry.verifiedAt, entry.date];
  for (const value of timestamps) {
    if (!value) continue;
    const parsed = Date.parse(value);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return 0;
};

const getSourceEntryId = (entry: Partial<TimesheetEntry>): string => {
  if (entry.originalEntryId) {
    return entry.originalEntryId;
  }
  if (entry.id) {
    return entry.id;
  }
  const dateKey = entry.date ?? new Date().toISOString();
  const operator = entry.operatorName ?? 'unknown';
  const open = toTimeString(entry.openHours);
  const close = toTimeString(entry.closeHours ?? entry.closingHours);
  return `${dateKey}-${operator}-${open}-${close}`;
};

const deduplicateTimesheetEntries = (entries: TimesheetEntry[]): TimesheetEntry[] => {
  const pairingMap = new Map<string, { plantManager?: TimesheetEntry; operator?: TimesheetEntry }>();
  const processedIds = new Set<string>();

  entries.forEach((entry) => {
    if (processedIds.has(entry.id)) {
      return;
    }

    const isPMEntry = entry.hasOriginalEntry || entry.isAdjustment || Boolean(entry.adjustedBy);
    const dateOperatorKey = `${entry.date}-${entry.operatorName}`;

    if (!pairingMap.has(dateOperatorKey)) {
      pairingMap.set(dateOperatorKey, {});
    }

    const pair = pairingMap.get(dateOperatorKey)!;

    if (isPMEntry) {
      if (!pair.plantManager || getEntryTimestamp(entry) > getEntryTimestamp(pair.plantManager)) {
        if (pair.plantManager) {
          processedIds.delete(pair.plantManager.id);
        }
        pair.plantManager = entry;
        processedIds.add(entry.id);
      }
    } else {
      if (!pair.operator || getEntryTimestamp(entry) > getEntryTimestamp(pair.operator)) {
        if (pair.operator) {
          processedIds.delete(pair.operator.id);
        }
        pair.operator = entry;
        processedIds.add(entry.id);
      }
    }
  });

  const result: TimesheetEntry[] = [];
  pairingMap.forEach((pair) => {
    if (pair.operator) {
      result.push(pair.operator);
    }
    if (pair.plantManager) {
      result.push(pair.plantManager);
    }
  });

  return result;
};

// Returns only the effective entry per date (PM entry takes priority over operator entry)
// This is used for billing calculations where we should only count one value per date
const getEffectiveEntriesForBilling = (entries: TimesheetEntry[]): TimesheetEntry[] => {
  const pairingMap = new Map<string, { plantManager?: TimesheetEntry; operator?: TimesheetEntry }>();
  const processedIds = new Set<string>();

  entries.forEach((entry) => {
    if (processedIds.has(entry.id)) {
      return;
    }

    const isPMEntry = entry.hasOriginalEntry || entry.isAdjustment || Boolean(entry.adjustedBy);
    const dateOperatorKey = `${entry.date}-${entry.operatorName}`;

    if (!pairingMap.has(dateOperatorKey)) {
      pairingMap.set(dateOperatorKey, {});
    }

    const pair = pairingMap.get(dateOperatorKey)!;

    if (isPMEntry) {
      if (!pair.plantManager || getEntryTimestamp(entry) > getEntryTimestamp(pair.plantManager)) {
        if (pair.plantManager) {
          processedIds.delete(pair.plantManager.id);
        }
        pair.plantManager = entry;
        processedIds.add(entry.id);
      }
    } else {
      if (!pair.operator || getEntryTimestamp(entry) > getEntryTimestamp(pair.operator)) {
        if (pair.operator) {
          processedIds.delete(pair.operator.id);
        }
        pair.operator = entry;
        processedIds.add(entry.id);
      }
    }
  });

  // Return only the effective entry per date: PM entry if exists, otherwise operator entry
  const result: TimesheetEntry[] = [];
  pairingMap.forEach((pair) => {
    if (pair.plantManager) {
      // PM entry takes priority - only include this one
      result.push(pair.plantManager);
    } else if (pair.operator) {
      // Only include operator entry if no PM entry exists
      result.push(pair.operator);
    }
  });

  return result;
};

export default function BillingConfigScreen() {
  const insets = useSafeAreaInsets();
  const { user } = useAuth();
  const params = useLocalSearchParams();
  const initialTab = (params.tab as TabType) || 'eph';
  const [activeTab, setActiveTab] = useState<TabType>(initialTab);
  const [subcontractors, setSubcontractors] = useState<Subcontractor[]>([]);
  const [selectedSubcontractor, setSelectedSubcontractor] = useState<string | null>(null);
  const [plantAssets, setPlantAssets] = useState<PlantAsset[]>([]);
  const [ephData, setEphData] = useState<EPHRecord[]>([]);
  const [selectedAssetForTimesheets, setSelectedAssetForTimesheets] = useState<PlantAsset | null>(null);
  const [timesheets, setTimesheets] = useState<TimesheetEntry[]>([]);
  const [loading, setLoading] = useState(false);
  const [expandedCards, setExpandedCards] = useState<Set<string>>(new Set());
  const [startDate, setStartDate] = useState<Date>(() => {
    const date = new Date();
    date.setDate(1);
    return date;
  });
  const [endDate, setEndDate] = useState<Date>(new Date());
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);
  const [selectedEphAssetForTimesheets, setSelectedEphAssetForTimesheets] = useState<string | null>(null);
  const [selectedAssetIds, setSelectedAssetIds] = useState<Set<string>>(new Set());
  
  const [config, setConfig] = useState<BillingConfig>({
    weekdays: {
      enabled: true,
      billingMethod: 'PER_HOUR',
      minHours: 0,
      rateMultiplier: 1.0,
    },
    saturday: {
      enabled: true,
      billingMethod: 'MINIMUM_BILLING',
      minHours: 8,
      rateMultiplier: 1.5,
    },
    sunday: {
      enabled: true,
      billingMethod: 'MINIMUM_BILLING',
      minHours: 8,
      rateMultiplier: 1.5,
    },
    publicHolidays: {
      enabled: true,
      billingMethod: 'MINIMUM_BILLING',
      minHours: 8,
      rateMultiplier: 2.0,
    },
    rainDays: {
      enabled: true,
      minHours: 4.5,
      thresholdHours: 1,
    },
    breakdown: {
      enabled: true,
    },
  });
  const [timesheetGroups, setTimesheetGroups] = useState<TimesheetDisplayGroup[]>([]);
  const [showOriginalRows, setShowOriginalRows] = useState(true);
  const [agreedHoursModalVisible, setAgreedHoursModalVisible] = useState(false);
  const [selectedTimesheetForAgreement, setSelectedTimesheetForAgreement] = useState<any>(null);
  const [ephTimesheets, setEphTimesheets] = useState<Map<string, TimesheetEntry[]>>(new Map());
  const [agreedTimesheetIds, setAgreedTimesheetIds] = useState<Set<string>>(new Set());
  const [reportGenerationModalVisible, setReportGenerationModalVisible] = useState(false);
  const [pdfGenerating, setPdfGenerating] = useState(false);
  
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [comparisonModalVisible, setComparisonModalVisible] = useState(false);
  const [sendModalVisible, setSendModalVisible] = useState(false);
  const [selectedTimesheetForEdit, setSelectedTimesheetForEdit] = useState<any>(null);
  const [selectedComparison, setSelectedComparison] = useState<any>(null);
  const [pendingEdits, setPendingEdits] = useState<Map<string, EPHPendingEdit[]>>(new Map());
  const [timesheetsSubTab, setTimesheetsSubTab] = useState<TimesheetsSubTab>('machine');
  const [configSubTab, setConfigSubTab] = useState<ConfigSubTab>('machine');
  const [globalBillingMethod, setGlobalBillingMethod] = useState<BillingMethod>('PER_HOUR');
  const [expandedDayCards, setExpandedDayCards] = useState<Set<string>>(new Set());

  const totalTimesheetHours = useMemo(() => {
    // Calculate total hours using hierarchy based on timesheetGroups:
    // 1. If admin edit exists -> use admin's hours (highest priority for billing)
    // 2. If plant manager edited -> use plant manager's hours (adjustmentEntry)
    // 3. If only operator entry -> use operator's hours (originalEntry)
    // Each group represents a unique date, and we only count once per date
    
    console.log('[TotalHours] Starting calculation with', timesheetGroups.length, 'date groups');
    
    const assetPendingEdits = selectedAssetForTimesheets 
      ? pendingEdits.get(selectedAssetForTimesheets.assetId) || []
      : [];
    
    let total = 0;
    
    timesheetGroups.forEach(group => {
      // Check for admin edit (highest priority)
      const adminEdit = assetPendingEdits.find(
        edit => edit.date === group.date && edit.editedBy === 'admin' && edit.status === 'pending_review'
      );
      
      if (adminEdit) {
        // Use admin's hours (highest priority)
        total += adminEdit.totalHours;
        console.log(`[TotalHours] Date ${group.date}: Using ADMIN edit hours: ${adminEdit.totalHours}`);
      } else {
        // Use PM entry if it exists (from adjustmentEntry), otherwise use operator entry
        // Find the PM row or ORIG row in the visible rows
        const pmRow = group.rows.find(row => row.badgeLabel === 'PM');
        const origRow = group.rows.find(row => row.badgeLabel === 'ORIG');
        
        if (pmRow) {
          total += pmRow.totalHours;
          console.log(`[TotalHours] Date ${group.date}: Using PM hours: ${pmRow.totalHours}`);
        } else if (origRow) {
          total += origRow.totalHours;
          console.log(`[TotalHours] Date ${group.date}: Using OPERATOR hours: ${origRow.totalHours}`);
        } else if (group.rows.length > 0) {
          // Fallback to first row if no PM or ORIG badge found
          total += group.rows[0].totalHours;
          console.log(`[TotalHours] Date ${group.date}: Using fallback hours: ${group.rows[0].totalHours}`);
        }
      }
    });
    
    console.log(`[TotalHours] Final calculated total: ${total}h from ${timesheetGroups.length} date groups`);
    return total;
  }, [timesheetGroups, pendingEdits, selectedAssetForTimesheets]);

  const hasAnyAdjustments = useMemo(() => {
    return timesheetGroups.some(group => group.hasAdjustments);
  }, [timesheetGroups]);

  const loadSubcontractors = useCallback(async () => {
    if (!user?.masterAccountId || !user?.siteId) {
      console.log('[Timesheets] Skipping subcontractor load: missing user context');
      setSubcontractors([]);
      return;
    }

    try {
      const q = query(
        collection(db, 'subcontractors'),
        where('masterAccountId', '==', user.masterAccountId),
        where('siteId', '==', user.siteId),
        where('status', '==', 'Active'),
        orderBy('name')
      );
      const snapshot = await getDocs(q);
      const subs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Subcontractor));
      setSubcontractors(subs);
      console.log('[Timesheets] Loaded subcontractors:', subs.length);
    } catch (error) {
      console.error('Error loading subcontractors:', error);
    }
  }, [user?.masterAccountId, user?.siteId]);

  useFocusEffect(
    useCallback(() => {
      console.log('[Timesheets] Screen focused - refreshing subcontractor list');
      loadSubcontractors();
    }, [loadSubcontractors])
  );

  useEffect(() => {
    if (activeTab === 'timesheets') {
      console.log('[Timesheets] Timesheets tab active - ensuring subcontractors loaded');
      loadSubcontractors();
    }
  }, [activeTab, loadSubcontractors]);

  const generateEPHReport = useCallback(
    async (assets: PlantAsset[], subcontractorId: string) => {
      console.log('[EPH] Generating EPH report for date range:', startDate.toISOString(), 'to', endDate.toISOString());
      console.log('[EPH] Assets to process:', assets.length);
      console.log('[EPH] Using billing config:', JSON.stringify(config, null, 2));

      const billingCalcConfig: BillingConfigForCalculation = {
        weekdays: { minHours: config.weekdays.minHours || 0 },
        saturday: { minHours: config.saturday.minHours || 0 },
        sunday: { minHours: config.sunday.minHours || 0 },
        publicHolidays: { minHours: config.publicHolidays.minHours || 0 },
        rainDays: { enabled: config.rainDays.enabled, minHours: config.rainDays.minHours },
        breakdown: { enabled: config.breakdown?.enabled ?? true },
      };

      try {
        const ephRecords: EPHRecord[] = await Promise.all(
          assets.map(async (asset) => {
            console.log('[EPH] Processing asset:', asset.assetId, asset.type, asset.plantNumber);
            const timesheetQuery = query(
              collection(db, 'verifiedTimesheets'),
              where('masterAccountId', '==', user?.masterAccountId),
              where('siteId', '==', user?.siteId),
              where('assetId', '==', asset.assetId),
              where('type', '==', 'plant_hours'),
              where('date', '>=', startDate.toISOString().split('T')[0]),
              where('date', '<=', endDate.toISOString().split('T')[0])
            );

            const timesheetSnapshot = await getDocs(timesheetQuery);
            console.log('[EPH] Found', timesheetSnapshot.docs.length, 'verified timesheets for asset:', asset.assetId);
            
            const rawEntries = timesheetSnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
            })) as TimesheetEntry[];

            setEphTimesheets(prev => {
              const newMap = new Map(prev);
              newMap.set(asset.assetId, rawEntries);
              return newMap;
            });
            
            const dedupedEntries = deduplicateTimesheetEntries(rawEntries);
            // For billing calculations, use only the effective entry per date (PM > operator hierarchy)
            const effectiveEntries = getEffectiveEntriesForBilling(rawEntries);
            console.log('[EPH] After deduplication:', dedupedEntries.length, 'entries, effective for billing:', effectiveEntries.length, 'entries');

            let actualNormalHours = 0;
            let actualSaturdayHours = 0;
            let actualSundayHours = 0;
            let actualPublicHolidayHours = 0;
            let actualBreakdownHours = 0;
            let actualRainDayHours = 0;
            let actualStrikeDayHours = 0;

            let billableNormalHours = 0;
            let billableSaturdayHours = 0;
            let billableSundayHours = 0;
            let billablePublicHolidayHours = 0;
            let billableBreakdownHours = 0;
            let billableRainDayHours = 0;
            let billableStrikeDayHours = 0;

            const billingResults: BillableHoursResult[] = [];
            // Create a map from date to billing result for EPH totals (uses effective entries only)
            const billingResultsByDate = new Map<string, BillableHoursResult>();
            // Create a map from entry ID to billing result for PDF generation (each entry needs its own calculation)
            const billingResultsById = new Map<string, BillableHoursResult>();

            // Calculate billing for ALL deduplicated entries (for PDF - each row needs its own billable hours)
            dedupedEntries.forEach((entry) => {
              const entryActualHours = entry.totalHours || 0;
              const entryBillingResult = calculateBillableHours(
                {
                  startTime: entry.openHours,
                  endTime: entry.closeHours,
                  date: entry.date,
                  isBreakdown: entry.isBreakdown || false,
                  isRainDay: entry.isRainDay || false,
                  isInclementWeather: entry.isRainDay || false,
                  isPublicHoliday: entry.isPublicHoliday || false,
                  totalHours: entryActualHours,
                },
                billingCalcConfig
              );
              billingResultsById.set(entry.id, entryBillingResult);
              console.log(`[EPH] Entry ID ${entry.id} (${entry.date}): actual=${entryActualHours}h, billable=${entryBillingResult.billableHours}h`);
            });

            // Use effective entries for EPH TOTALS (only one per date based on hierarchy)
            effectiveEntries.forEach((entry) => {
              const actualHours = entry.totalHours || 0;
              const date = new Date(entry.date);
              const dayOfWeek = date.getDay();
              const isBreakdown = entry.isBreakdown || false;
              const isRainDay = entry.isRainDay || false;
              const isStrikeDay = entry.isStrikeDay || false;
              const isPublicHoliday = entry.isPublicHoliday || false;

              const billingResult = calculateBillableHours(
                {
                  startTime: entry.openHours,
                  endTime: entry.closeHours,
                  date: entry.date,
                  isBreakdown,
                  isRainDay,
                  isInclementWeather: isRainDay,
                  isPublicHoliday,
                  totalHours: actualHours,
                },
                billingCalcConfig
              );
              billingResults.push(billingResult);
              billingResultsByDate.set(entry.date, billingResult);
              // Also store by ID for effective entries (in case lookup by ID is needed)
              billingResultsById.set(entry.id, billingResult);

              console.log(`[EPH] Effective Entry ${entry.date} (${entry.id}): actual=${actualHours}h, billable=${billingResult.billableHours}h, rule=${billingResult.appliedRule}`);

              if (isBreakdown) {
                actualBreakdownHours += actualHours;
                billableBreakdownHours += billingResult.billableHours;
              } else if (isRainDay) {
                actualRainDayHours += actualHours;
                billableRainDayHours += billingResult.billableHours;
              } else if (isStrikeDay) {
                actualStrikeDayHours += actualHours;
                billableStrikeDayHours += billingResult.billableHours;
              } else if (isPublicHoliday) {
                actualPublicHolidayHours += actualHours;
                billablePublicHolidayHours += billingResult.billableHours;
              } else if (dayOfWeek === 6) {
                actualSaturdayHours += actualHours;
                billableSaturdayHours += billingResult.billableHours;
              } else if (dayOfWeek === 0) {
                actualSundayHours += actualHours;
                billableSundayHours += billingResult.billableHours;
              } else {
                actualNormalHours += actualHours;
                billableNormalHours += billingResult.billableHours;
              }
            });

            const rate = asset.dryRate || asset.wetRate || 0;
            const rateType = asset.dryRate ? 'dry' : 'wet';
            
            const totalActualHours = actualNormalHours + actualSaturdayHours + actualSundayHours + 
              actualPublicHolidayHours + actualBreakdownHours + actualRainDayHours + actualStrikeDayHours;
            
            const totalBillableHours = billableNormalHours + billableSaturdayHours + billableSundayHours + 
              billablePublicHolidayHours + billableBreakdownHours + billableRainDayHours + billableStrikeDayHours;

            console.log(`[EPH] Asset ${asset.assetId}: totalActual=${totalActualHours}h, totalBillable=${totalBillableHours}h, cost=R${(totalBillableHours * rate).toFixed(2)}`);

            return {
              assetId: asset.assetId,
              assetType: asset.type,
              plantNumber: asset.plantNumber,
              registrationNumber: asset.registrationNumber,
              rate,
              rateType: rateType as 'wet' | 'dry',
              actualNormalHours,
              actualSaturdayHours,
              actualSundayHours,
              actualPublicHolidayHours,
              actualBreakdownHours,
              actualRainDayHours,
              actualStrikeDayHours,
              totalActualHours,
              billableNormalHours,
              billableSaturdayHours,
              billableSundayHours,
              billablePublicHolidayHours,
              billableBreakdownHours,
              billableRainDayHours,
              billableStrikeDayHours,
              totalBillableHours,
              estimatedCost: totalBillableHours * rate,
              rawTimesheets: dedupedEntries,
              billingResults,
              billingResultsByDate,
              billingResultsById,
            };
          })
        );

        setEphData(ephRecords);
      } catch (error) {
        console.error('Error generating EPH report:', error);
      }
    },
    [endDate, startDate, user?.masterAccountId, user?.siteId, config]
  );

  const loadPlantAssets = useCallback(
    async (subcontractorId: string) => {
      console.log('[loadPlantAssets] Starting load for subcontractor:', subcontractorId);
      console.log('[loadPlantAssets] Query params:', {
        masterAccountId: user?.masterAccountId,
        siteId: user?.siteId,
        ownerId: subcontractorId,
        ownerType: 'subcontractor'
      });
      
      setLoading(true);
      try {
        const q = query(
          collection(db, 'plantAssets'),
          where('masterAccountId', '==', user?.masterAccountId),
          where('siteId', '==', user?.siteId),
          where('ownerId', '==', subcontractorId),
          where('ownerType', '==', 'subcontractor')
        );
        const snapshot = await getDocs(q);
        console.log('[loadPlantAssets] Found', snapshot.docs.length, 'assets in query');
        
        const assets = snapshot.docs.map(doc => {
          const data = doc.data();
          console.log('[loadPlantAssets] Asset:', doc.id, data);
          return { id: doc.id, ...data } as PlantAsset;
        });
        
        console.log('[loadPlantAssets] Processed assets:', assets.length);
        setPlantAssets(assets);
        
        if (assets.length > 0) {
          console.log('[loadPlantAssets] Generating EPH report for', assets.length, 'assets');
          await generateEPHReport(assets, subcontractorId);
        } else {
          console.log('[loadPlantAssets]  No assets found - clearing EPH data');
          setEphData([]);
        }
      } catch (error) {
        console.error('[loadPlantAssets] Error:', error);
      } finally {
        setLoading(false);
      }
    },
    [generateEPHReport, user?.masterAccountId, user?.siteId]
  );

  const updateDayConfig = (
    dayType: keyof Omit<BillingConfig, 'rainDays'>,
    field: keyof DayTypeConfig,
    value: any
  ) => {
    setConfig(prev => ({
      ...prev,
      [dayType]: {
        ...prev[dayType],
        [field]: value,
      },
    }));
  };

  const toggleDayCard = (dayType: string) => {
    setExpandedDayCards(prev => {
      const newSet = new Set(prev);
      if (newSet.has(dayType)) {
        newSet.delete(dayType);
      } else {
        newSet.add(dayType);
      }
      return newSet;
    });
  };

  const applyGlobalBillingMethod = (method: BillingMethod) => {
    setGlobalBillingMethod(method);
    setConfig(prev => ({
      ...prev,
      weekdays: { ...prev.weekdays, billingMethod: method },
      saturday: { ...prev.saturday, billingMethod: method },
      sunday: { ...prev.sunday, billingMethod: method },
      publicHolidays: { ...prev.publicHolidays, billingMethod: method },
    }));
  };

  const updateRainDayConfig = (field: keyof BillingConfig['rainDays'], value: any) => {
    setConfig(prev => ({
      ...prev,
      rainDays: {
        ...prev.rainDays,
        [field]: value,
      },
    }));
  };

  const loadBillingConfig = useCallback(async () => {
    if (!user?.masterAccountId) return;
    
    try {
      const configDoc = await getDoc(
        doc(db, 'masterAccounts', user.masterAccountId, 'billingConfig', 'default')
      );
      
      if (configDoc.exists()) {
        const data = configDoc.data();
        const loadedConfig = data as BillingConfig;
        
        // Ensure breakdown config exists (for backward compatibility)
        if (!loadedConfig.breakdown) {
          loadedConfig.breakdown = {
            enabled: true,
          };
        }
        
        setConfig(loadedConfig);
        console.log('Loaded billing config from Firestore');
      } else {
        console.log('No saved billing config found, using defaults');
      }
    } catch (error) {
      console.error('Error loading billing config:', error);
    }
  }, [user?.masterAccountId]);

  useEffect(() => {
    loadBillingConfig();
  }, [loadBillingConfig]);

  const handleSave = async () => {
    console.log('[BILLING] Save button pressed');
    console.log('[BILLING] User:', user);
    console.log('[BILLING] MasterAccountId:', user?.masterAccountId);
    console.log('[BILLING] Config to save:', config);
    
    if (!user?.masterAccountId) {
      console.error('[BILLING] ERROR: No master account ID found');
      alert('Error: No master account ID found. Please log in again.');
      return;
    }

    try {
      const docPath = `masterAccounts/${user.masterAccountId}/billingConfig/default`;
      console.log('[BILLING] Saving to path:', docPath);
      
      await setDoc(
        doc(db, 'masterAccounts', user.masterAccountId, 'billingConfig', 'default'),
        config
      );
      
      console.log('[BILLING]  Billing config saved successfully');
      alert('Billing configuration saved successfully!');
    } catch (error) {
      console.error('[BILLING]  Error saving billing config:', error);
      alert(`Failed to save billing configuration: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  const formatDate = (date: Date): string => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };

  const handleDateChange = (type: 'start' | 'end', date: Date) => {
    if (type === 'start') {
      setStartDate(date);
      setShowStartDatePicker(false);
    } else {
      setEndDate(date);
      setShowEndDatePicker(false);
    }
    
    if (selectedSubcontractor && plantAssets.length > 0) {
      generateEPHReport(plantAssets, selectedSubcontractor);
    }
  };

  const handleRefreshReport = () => {
    if (selectedSubcontractor) {
      loadPlantAssets(selectedSubcontractor);
    }
  };

  const handleGeneratePDFReport = async (options: {
    scope: 'all' | 'selected';
    deliveryMethod: 'download' | 'email';
    recipientEmail?: string;
  }) => {
    console.log('[PDF] Starting PDF generation with options:', options);
    
    if (!selectedSubcontractor) {
      Alert.alert('Error', 'No subcontractor selected');
      return;
    }

    const selectedAssets = options.scope === 'selected'
      ? ephData.filter(record => selectedAssetIds.has(record.assetId))
      : ephData;

    if (selectedAssets.length === 0) {
      Alert.alert('Error', 'No assets to include in the report');
      return;
    }

    console.log('[PDF] Generating report for', selectedAssets.length, 'assets');

    try {
      setPdfGenerating(true);

      const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
      console.log('[PDF] Selected assets:', selectedAssets.map(a => ({ id: a.assetId, type: a.assetType, plant: a.plantNumber })));
      console.log('[PDF] ephTimesheets map has', ephTimesheets.size, 'assets');

      const groups = selectedAssets.map(record => {
        const rawTimesheets = ephTimesheets.get(record.assetId) || record.rawTimesheets || [];
        const timesheets = deduplicateTimesheetEntries(rawTimesheets);
        const billingResultsByDate = record.billingResultsByDate || new Map<string, BillableHoursResult>();
        
        console.log('[PDF] Asset', record.assetId, record.assetType, record.plantNumber, 'has', rawTimesheets.length, 'raw timesheets');
        console.log('[PDF] Sample timesheet data:', rawTimesheets[0]);
        console.log('[PDF] After dedup:', timesheets.length, 'entries');
        console.log('[PDF] Billing results available:', billingResultsByDate.size, 'dates');
        console.log('[PDF] Timesheets:', timesheets.map(ts => ({
          date: ts.date,
          operator: ts.operatorName,
          hours: ts.totalHours,
          open: ts.openHours,
          close: ts.closeHours
        })));
        
        return {
          key: record.assetId,
          title: record.assetType,
          subtitle: record.plantNumber || record.registrationNumber || record.assetId,
          entries: timesheets.map((ts: TimesheetEntry) => {
            // Get the billing result for this date to populate actualHours and billableHours
            const billingResult = billingResultsByDate.get(ts.date);
            
            return {
              id: ts.id,
              date: ts.date,
              operatorName: ts.operatorName,
              operatorId: ts.operatorName || '',
              verified: true,
              verifiedAt: ts.verifiedAt || new Date().toISOString(),
              verifiedBy: ts.adjustedBy || 'system',
              masterAccountId: user?.masterAccountId || '',
              siteId: user?.siteId || '',
              type: 'plant_hours' as const,
              openHours: parseFloat(ts.openHours) || 0,
              closeHours: parseFloat(ts.closeHours) || 0,
              totalHours: ts.totalHours || 0,
              // Use pre-calculated hours from billing logic - DO NOT recalculate in PDF
              actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
              billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
              assetRate: record.rate,
              totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
              billingRule: billingResult?.appliedRule,
              isBreakdown: ts.isBreakdown,
              inclementWeather: ts.isRainDay,
              isRainDay: ts.isRainDay,
              isStrikeDay: ts.isStrikeDay,
              isPublicHoliday: ts.isPublicHoliday,
              hasAttachment: false,
              assetId: record.assetId,
              assetType: record.assetType,
              plantNumber: record.plantNumber,
              registrationNumber: record.registrationNumber,
              ownerId: selectedSubcontractor,
              ownerType: 'subcontractor' as const,
              ownerName: subcontractor?.name,
              hasOriginalEntry: ts.hasOriginalEntry,
              originalEntryData: ts.originalEntryData,
              isAdjustment: ts.isAdjustment,
              originalEntryId: ts.originalEntryId,
              adjustedBy: ts.adjustedBy,
              adjustedAt: ts.adjustedAt,
              notes: ts.notes || ts.adminNotes || ts.billingNotes,
            };
          }),
          dateGroups: timesheets.map((ts: TimesheetEntry) => {
            const hasAdjustment = ts.hasOriginalEntry || ts.isAdjustment || Boolean(ts.adjustedBy);
            const billingResult = billingResultsByDate.get(ts.date);
            const originalBillingResult = ts.originalEntryData?.date 
              ? billingResultsByDate.get(ts.originalEntryData.date)
              : undefined;
            
            if (hasAdjustment && ts.originalEntryData) {
              return {
                date: ts.date,
                operatorEntry: {
                  ...ts.originalEntryData,
                  id: ts.originalEntryId || ts.id,
                  date: ts.date,
                  operatorName: ts.originalEntryData.operatorName || ts.operatorName,
                  openHours: parseFloat(String(ts.originalEntryData.openHours || 0)),
                  closeHours: parseFloat(String(ts.originalEntryData.closeHours || ts.originalEntryData.closingHours || 0)),
                  totalHours: ts.originalEntryData.totalHours || 0,
                  actualHours: ts.originalEntryData.totalHours || 0,
                  billableHours: originalBillingResult?.billableHours ?? ts.originalEntryData.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (originalBillingResult?.billableHours ?? ts.originalEntryData.totalHours ?? 0) * record.rate,
                  billingRule: originalBillingResult?.appliedRule,
                  isBreakdown: ts.originalEntryData.isBreakdown,
                  inclementWeather: ts.originalEntryData.isRainDay,
                  isRainDay: ts.originalEntryData.isRainDay,
                  isStrikeDay: ts.originalEntryData.isStrikeDay,
                  isPublicHoliday: ts.originalEntryData.isPublicHoliday,
                  notes: ts.originalEntryData.notes,
                  agreedByRole: 'Operator' as const,
                } as any,
                plantManagerEntry: {
                  ...ts,
                  id: ts.id,
                  date: ts.date,
                  operatorName: ts.operatorName,
                  openHours: parseFloat(String(ts.openHours || 0)),
                  closeHours: parseFloat(String(ts.closeHours || ts.closingHours || 0)),
                  totalHours: ts.totalHours || 0,
                  actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
                  billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
                  billingRule: billingResult?.appliedRule,
                  isBreakdown: ts.isBreakdown,
                  inclementWeather: ts.isRainDay,
                  isRainDay: ts.isRainDay,
                  isStrikeDay: ts.isStrikeDay,
                  isPublicHoliday: ts.isPublicHoliday,
                  notes: ts.notes || ts.adminNotes || ts.billingNotes,
                  adjustedBy: ts.adjustedBy,
                  adjustedAt: ts.adjustedAt,
                  agreedByRole: 'Plant Manager' as const,
                } as any,
                adminEntry: undefined,
                subcontractorEntry: undefined,
              };
            } else {
              return {
                date: ts.date,
                operatorEntry: {
                  id: ts.id,
                  date: ts.date,
                  operatorName: ts.operatorName,
                  openHours: parseFloat(String(ts.openHours || 0)),
                  closeHours: parseFloat(String(ts.closeHours || ts.closingHours || 0)),
                  totalHours: ts.totalHours || 0,
                  actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
                  billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
                  billingRule: billingResult?.appliedRule,
                  isBreakdown: ts.isBreakdown,
                  inclementWeather: ts.isRainDay,
                  isRainDay: ts.isRainDay,
                  isStrikeDay: ts.isStrikeDay,
                  isPublicHoliday: ts.isPublicHoliday,
                  notes: ts.notes || ts.operatorNotes,
                  agreedByRole: 'Operator' as const,
                } as any,
                plantManagerEntry: undefined,
                adminEntry: undefined,
                subcontractorEntry: undefined,
              };
            }
          }),
        };
      });

      console.log('[PDF] Calling generateTimesheetPDF with', groups.length, 'groups');
      
      const { uri, fileName } = await generateTimesheetPDF({
        groups,
        reportType: 'plant',
        subcontractorName: subcontractor?.name,
        dateRange: {
          from: startDate,
          to: endDate,
        },
        selectedOnly: options.scope === 'selected',
        selectedGroups: options.scope === 'selected' 
          ? new Set(selectedAssets.map(r => r.assetId))
          : undefined,
      });

      console.log('[PDF] PDF generated successfully:', uri);

      if (options.deliveryMethod === 'email') {
        console.log('[PDF] Sending via email to:', options.recipientEmail);
        await emailTimesheetPDF(uri, fileName, {
          recipientEmail: options.recipientEmail,
          subject: `Plant Hours Report - ${subcontractor?.name || 'Unknown'} - ${formatDate(startDate)} to ${formatDate(endDate)}`,
          body: `Please find attached the plant hours timesheet report for ${subcontractor?.name || 'Unknown Subcontractor'}.\n\nDate Range: ${formatDate(startDate)} to ${formatDate(endDate)}\nAssets Included: ${selectedAssets.length}`,
        });
        Alert.alert('Success', 'Report generated and email composer opened');
      } else {
        console.log('[PDF] Downloading/sharing PDF');
        await downloadTimesheetPDF(uri, fileName);
        Alert.alert('Success', 'Report generated successfully');
      }
    } catch (error) {
      console.error('[PDF] Error generating PDF:', error);
      Alert.alert('Error', `Failed to generate report: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setPdfGenerating(false);
    }
  };

  const renderDayTypeCard = (
    title: string,
    dayType: keyof Omit<BillingConfig, 'rainDays'>,
    icon: string,
    isExpanded: boolean,
    onToggle: () => void
  ) => {
    const dayConfig = config[dayType] as DayTypeConfig;

    return (
      <View style={styles.card}>
        <TouchableOpacity 
          style={styles.cardHeader}
          onPress={onToggle}
          activeOpacity={0.7}
        >
          <View style={styles.cardTitleRow}>
            <Text style={styles.cardIcon}>{icon}</Text>
            <Text style={styles.cardTitle}>{title}</Text>
          </View>
          {isExpanded ? (
            <ChevronUp size={24} color="#64748b" />
          ) : (
            <ChevronDown size={24} color="#64748b" />
          )}
        </TouchableOpacity>

        {isExpanded && (
          <View style={styles.cardContent}>
            <View style={styles.formGroup}>
              <Text style={styles.label}>Enabled</Text>
              <Switch
                value={dayConfig.enabled}
                onValueChange={(value) => updateDayConfig(dayType, 'enabled', value)}
                trackColor={{ false: '#d1d5db', true: '#3b82f6' }}
                thumbColor={dayConfig.enabled ? '#ffffff' : '#f3f4f6'}
              />
            </View>

            {dayConfig.billingMethod === 'MINIMUM_BILLING' && (
              <View style={styles.formGroup}>
                <Text style={styles.label}>Minimum Hours</Text>
                <TextInput
                  style={styles.input}
                  value={dayConfig.minHours?.toString() || '0'}
                  onChangeText={(text) =>
                    updateDayConfig(
                      dayType,
                      'minHours',
                      parseFloat(text) || 0
                    )
                  }
                  keyboardType="numeric"
                  placeholder="Enter minimum hours"
                  placeholderTextColor="#9ca3af"
                />
              </View>
            )}

            <View style={styles.formGroup}>
              <Text style={styles.label}>Rate Multiplier</Text>
              <View style={styles.inputWithIcon}>
                <Text style={styles.inputIcon}></Text>
                <TextInput
                  style={[styles.input, styles.inputWithIconField]}
                  value={dayConfig.rateMultiplier?.toString() || '1.0'}
                  onChangeText={(text) =>
                    updateDayConfig(
                      dayType,
                      'rateMultiplier',
                      parseFloat(text) || 1.0
                    )
                  }
                  keyboardType="decimal-pad"
                  placeholder="1.0"
                  placeholderTextColor="#9ca3af"
                />
              </View>
              <Text style={styles.helperText}>
                {dayConfig.rateMultiplier === 1.0
                  ? 'Standard rate'
                  : dayConfig.rateMultiplier > 1.0
                  ? `${((dayConfig.rateMultiplier - 1) * 100).toFixed(0)}% premium`
                  : dayConfig.rateMultiplier === 0
                  ? 'No billing'
                  : `${((1 - dayConfig.rateMultiplier) * 100).toFixed(0)}% reduced`}
              </Text>
            </View>
          </View>
        )}
      </View>
    );
  };

  const renderDayTypeCardMachine = (
    title: string,
    dayType: keyof Omit<BillingConfig, 'rainDays'>,
    icon: string,
    isExpanded: boolean,
    onToggle: () => void
  ) => {
    const dayConfig = config[dayType] as DayTypeConfig;

    return (
      <View style={styles.card}>
        <TouchableOpacity 
          style={styles.cardHeader}
          onPress={onToggle}
          activeOpacity={0.7}
        >
          <View style={styles.cardTitleRow}>
            <Text style={styles.cardIcon}>{icon}</Text>
            <Text style={styles.cardTitle}>{title}</Text>
          </View>
          {isExpanded ? (
            <ChevronUp size={24} color="#64748b" />
          ) : (
            <ChevronDown size={24} color="#64748b" />
          )}
        </TouchableOpacity>

        {isExpanded && (
          <View style={styles.cardContent}>
            <View style={styles.formGroup}>
              <Text style={styles.label}>Minimum Hours</Text>
              <TextInput
                style={styles.input}
                value={dayConfig.minHours?.toString() || '0'}
                onChangeText={(text) =>
                  updateDayConfig(
                    dayType,
                    'minHours',
                    parseFloat(text) || 0
                  )
                }
                keyboardType="numeric"
                placeholder="Enter minimum hours"
                placeholderTextColor="#9ca3af"
              />
            </View>
          </View>
        )}
      </View>
    );
  };

  const renderRainDayConfig = () => {
    const isExpanded = expandedDayCards.has('rainDays');
    
    return (
      <View style={styles.card}>
        <TouchableOpacity 
          style={styles.cardHeader}
          onPress={() => toggleDayCard('rainDays')}
          activeOpacity={0.7}
        >
          <View style={styles.cardTitleRow}>
            <CloudRain size={24} color="#3b82f6" style={{ marginRight: 12 }} />
            <Text style={styles.cardTitle}>Rain Day Configuration</Text>
          </View>
          {isExpanded ? (
            <ChevronUp size={24} color="#64748b" />
          ) : (
            <ChevronDown size={24} color="#64748b" />
          )}
        </TouchableOpacity>

        {isExpanded && (
          <View style={styles.cardContent}>
            <View style={styles.formGroup}>
              <Text style={styles.label}>Enabled</Text>
              <Switch
                value={config.rainDays.enabled}
                onValueChange={(value) => updateRainDayConfig('enabled', value)}
                trackColor={{ false: '#d1d5db', true: '#3b82f6' }}
                thumbColor={config.rainDays.enabled ? '#ffffff' : '#f3f4f6'}
              />
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Minimum Billing Hours (Rain Day)</Text>
              <TextInput
                style={styles.input}
                value={config.rainDays.minHours.toString()}
                onChangeText={(text) => updateRainDayConfig('minHours', parseFloat(text) || 0)}
                keyboardType="decimal-pad"
                placeholder="4.5"
                placeholderTextColor="#9ca3af"
              />
              <Text style={styles.helperText}>
                Minimum hours paid if meter reading exceeds threshold
              </Text>
            </View>

            <View style={styles.formGroup}>
              <Text style={styles.label}>Threshold Hours</Text>
              <TextInput
                style={styles.input}
                value={config.rainDays.thresholdHours.toString()}
                onChangeText={(text) => updateRainDayConfig('thresholdHours', parseFloat(text) || 0)}
                keyboardType="decimal-pad"
                placeholder="1"
                placeholderTextColor="#9ca3af"
              />
              <Text style={styles.helperText}>
                If meter reading exceeds this, minimum billing applies. If meter reading exceeds minimum hours, actual hours  rate is paid.
              </Text>
            </View>
          </View>
        )}
      </View>
    );
  };

  const updateBreakdownConfig = (field: keyof BillingConfig['breakdown'], value: any) => {
    setConfig(prev => ({
      ...prev,
      breakdown: {
        ...prev.breakdown,
        [field]: value,
      },
    }));
  };

  const renderBreakdownConfig = () => {
    const isExpanded = expandedDayCards.has('breakdown');
    
    if (!config.breakdown) {
      console.error('[Breakdown Config] config.breakdown is undefined');
      return null;
    }
    
    return (
      <View style={styles.card}>
        <TouchableOpacity 
          style={styles.cardHeader}
          onPress={() => toggleDayCard('breakdown')}
          activeOpacity={0.7}
        >
          <View style={styles.cardTitleRow}>
            <Wrench size={24} color="#3b82f6" style={{ marginRight: 12 }} />
            <Text style={styles.cardTitle}>Breakdown Configuration</Text>
          </View>
          {isExpanded ? (
            <ChevronUp size={24} color="#64748b" />
          ) : (
            <ChevronDown size={24} color="#64748b" />
          )}
        </TouchableOpacity>

        {isExpanded && (
          <View style={styles.cardContent}>
            <View style={styles.formGroup}>
              <Text style={styles.label}>Enabled</Text>
              <Switch
                value={config.breakdown.enabled}
                onValueChange={(value) => updateBreakdownConfig('enabled', value)}
                trackColor={{ false: '#d1d5db', true: '#3b82f6' }}
                thumbColor={config.breakdown.enabled ? '#ffffff' : '#f3f4f6'}
              />
              <Text style={styles.helperText}>
                When ENABLED: Breakdown days are billed at actual hours (end time - start time).{"\n"}When DISABLED: Breakdown days are billed at R0 (no charge).
              </Text>
            </View>
          </View>
        )}
      </View>
    );
  };

  const toggleCardExpansion = (assetId: string) => {
    setExpandedCards(prev => {
      const newSet = new Set(prev);
      if (newSet.has(assetId)) {
        newSet.delete(assetId);
      } else {
        newSet.add(assetId);
      }
      return newSet;
    });
  };

  const loadTimesheetsForAsset = async (asset: PlantAsset) => {
    setLoading(true);
    console.log('Loading timesheets for asset:', asset.assetId, 'from', startDate.toISOString(), 'to', endDate.toISOString());
    try {
      const timesheetQuery = query(
        collection(db, 'verifiedTimesheets'),
        where('masterAccountId', '==', user?.masterAccountId),
        where('assetId', '==', asset.assetId),
        where('type', '==', 'plant_hours'),
        where('date', '>=', startDate.toISOString().split('T')[0]),
        where('date', '<=', endDate.toISOString().split('T')[0])
      );

      console.log('[Timesheets] Executing query for asset:', asset.assetId);
      const snapshot = await getDocs(timesheetQuery);
      console.log('[Timesheets] Found', snapshot.docs.length, 'verified timesheets');
      
      const entries: TimesheetEntry[] = snapshot.docs.map(doc => {
        const data = doc.data();
        console.log('[Timesheets] Raw timesheet data for', doc.id, ':', {
          hasOriginalEntry: data.hasOriginalEntry,
          isAdjustment: data.isAdjustment,
          adjustedBy: data.adjustedBy,
          operatorName: data.operatorName,
          totalHours: data.totalHours,
          hasOriginalEntryData: !!data.originalEntryData,
        });
        const date = new Date(data.date);
        const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()];
        const rawNotes = typeof data.notes === 'string' ? data.notes : undefined;
        const operatorNotes = typeof data.operatorNotes === 'string' ? data.operatorNotes : undefined;
        const additionalNotes = typeof data.additionalNotes === 'string' ? data.additionalNotes : undefined;
        const adminNotes = typeof data.adminNotes === 'string' ? data.adminNotes : undefined;
        const billingNotes = typeof data.billingNotes === 'string' ? data.billingNotes : undefined;
        const comment = typeof data.comment === 'string' ? data.comment : undefined;
        const comments = typeof data.comments === 'string' ? data.comments : undefined;
        const extraNotes = typeof data.extraNotes === 'string' ? data.extraNotes : undefined;
        const noteSource: Partial<TimesheetEntry> = {
          notes: rawNotes,
          operatorNotes,
          additionalNotes,
          adminNotes,
          billingNotes,
          comment,
          comments,
          extraNotes,
          rawNotes,
        };
        const resolvedNotes = resolveDisplayNotes(noteSource);
        
        return {
          id: doc.id,
          date: data.date,
          dayOfWeek,
          openHours: toTimeString(data.openHours),
          closeHours: toTimeString(data.closeHours ?? data.closeHour ?? data.close_time ?? data.close ?? data.openHours),
          closingHours: toTimeString(data.closingHours ?? data.closeHours ?? data.closeHour ?? data.close_time ?? data.close ?? data.openHours),
          totalHours: Number(data.totalHours || 0),
          operatorName: data.operatorName || 'Unknown',
          isRainDay: Boolean(data.isRainDay || data.inclementWeather),
          isStrikeDay: Boolean(data.isStrikeDay),
          isBreakdown: Boolean(data.isBreakdown),
          isPublicHoliday: Boolean(data.isPublicHoliday),
          notes: resolvedNotes,
          operatorNotes,
          additionalNotes,
          adminNotes,
          billingNotes,
          comment,
          comments,
          extraNotes,
          rawNotes,
          verifiedAt: data.verifiedAt,
          hasOriginalEntry: data.hasOriginalEntry,
          originalEntryData: data.originalEntryData,
          originalEntryId: data.originalEntryId,
          adjustedBy: data.adjustedBy,
          adjustedAt: data.adjustedAt,
          isAdjustment: data.isAdjustment,
        };
      });

      entries.sort((a, b) => a.date.localeCompare(b.date));
      console.log('[Timesheets] Before dedup:', entries.length, 'entries');
      entries.forEach((e, i) => {
        console.log(`[Timesheets] Entry ${i}:`, {
          id: e.id.substring(0, 8),
          operator: e.operatorName,
          hours: e.totalHours,
          hasOriginalEntry: e.hasOriginalEntry,
          isAdjustment: e.isAdjustment,
          adjustedBy: e.adjustedBy,
          hasOriginalData: !!e.originalEntryData,
        });
      });
      const normalizedEntries = deduplicateTimesheetEntries(entries);
      normalizedEntries.sort((a, b) => a.date.localeCompare(b.date));
      console.log('[Timesheets] After dedup:', normalizedEntries.length, 'entries');
      normalizedEntries.forEach((e, i) => {
        console.log(`[Timesheets] Deduped Entry ${i}:`, {
          id: e.id.substring(0, 8),
          operator: e.operatorName,
          hours: e.totalHours,
          hasOriginalEntry: e.hasOriginalEntry,
          isAdjustment: e.isAdjustment,
          adjustedBy: e.adjustedBy,
          hasOriginalData: !!e.originalEntryData,
          originalOperator: e.originalEntryData?.operatorName,
          originalHours: e.originalEntryData?.totalHours,
        });
      });
      const grouped = buildTimesheetGroups(normalizedEntries);
      console.log('[Timesheets] Built display groups:', grouped.length);
      grouped.forEach((g, i) => {
        console.log(`[Timesheets] Group ${i} (${g.date}):`, {
          rows: g.rows.length,
          hasAdjustments: g.hasAdjustments,
          rowTypes: g.rows.map(r => r.badgeLabel).join(', '),
        });
      });
      setTimesheets(normalizedEntries);
      setTimesheetGroups(grouped);
      setShowOriginalRows(true);
      console.log('[Timesheets] Removed', entries.length - normalizedEntries.length, 'duplicate entries');
    } catch (error) {
      console.error('Error loading timesheets:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderManHoursView = () => (
    <View style={styles.timesheetsContainer}>
      <View style={styles.comingSoonContainer}>
        <Clock size={64} color="#94a3b8" />
        <Text style={styles.comingSoonTitle}>Man Hours Processing</Text>
        <Text style={styles.comingSoonText}>
          This section will handle operator man hours timesheets, allowing you to review and process operator work hours separately from plant asset hours.
        </Text>
        <View style={styles.comingSoonFeatureList}>
          <Text style={styles.comingSoonFeature}> Review operator daily timesheets</Text>
          <Text style={styles.comingSoonFeature}> Compare operator vs plant manager entries</Text>
          <Text style={styles.comingSoonFeature}> Process billing for labor costs</Text>
          <Text style={styles.comingSoonFeature}> Generate operator timesheet reports</Text>
        </View>
      </View>
    </View>
  );

  const renderMachineHoursConfig = () => (
    <ScrollView
      style={styles.scrollView}
      contentContainerStyle={[
        styles.scrollContent,
        { paddingBottom: insets.bottom + 20 },
      ]}
    >
      <View style={styles.infoCard}>
        <Wrench size={24} color="#3b82f6" />
        <View style={styles.infoContent}>
          <Text style={styles.infoTitle}>Billing Rules - Machine Hours</Text>
          <Text style={styles.infoText}>
            Configure minimum hours and billing rules for plant/machine hours. The billing method (Per Hour vs Minimum Billing) is set per asset during plant onboarding. Weekdays, weekends, and public holidays are automatically determined. Event-based conditions (rain days, breakdowns) are marked by operators in the timesheet.
          </Text>
        </View>
      </View>

      {renderDayTypeCardMachine('Weekdays (Monday - Friday)', 'weekdays', '', expandedDayCards.has('weekdays'), () => toggleDayCard('weekdays'))}
      {renderDayTypeCardMachine('Weekends (Saturday & Sunday)', 'saturday', '', expandedDayCards.has('saturday'), () => toggleDayCard('saturday'))}
      {renderRainDayConfig()}
      {renderBreakdownConfig()}
    </ScrollView>
  );

  const renderManHoursConfig = () => (
    <ScrollView
      style={styles.scrollView}
      contentContainerStyle={[
        styles.scrollContent,
        { paddingBottom: insets.bottom + 20 },
      ]}
    >
      <View style={styles.infoCard}>
        <Clock size={24} color="#3b82f6" />
        <View style={styles.infoContent}>
          <Text style={styles.infoTitle}>Billing Rules - Man Hours</Text>
          <Text style={styles.infoText}>
            Configure billing methods and rates for different day types for operator man hours. Weekdays,
            weekends, and public holidays are automatically determined. Event-based
            conditions (rain days, strike days, breakdowns) are marked by operators in
            the timesheet.
          </Text>
        </View>
      </View>

      <View style={styles.globalBillingMethodCard}>
        <Text style={styles.globalBillingMethodTitle}>Billing Method</Text>
        <Text style={styles.globalBillingMethodSubtitle}>Select billing method for all day types</Text>
        <View style={styles.buttonGroup}>
          <TouchableOpacity
            style={[
              styles.methodButton,
              globalBillingMethod === 'PER_HOUR' && styles.methodButtonActive,
            ]}
            onPress={() => applyGlobalBillingMethod('PER_HOUR')}
          >
            <Clock
              size={18}
              color={
                globalBillingMethod === 'PER_HOUR' ? '#ffffff' : '#64748b'
              }
            />
            <Text
              style={[
                styles.methodButtonText,
                globalBillingMethod === 'PER_HOUR' &&
                  styles.methodButtonTextActive,
              ]}
            >
              Per Hour
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.methodButton,
              globalBillingMethod === 'MINIMUM_BILLING' &&
                styles.methodButtonActive,
            ]}
            onPress={() => applyGlobalBillingMethod('MINIMUM_BILLING')}
          >
            <Calendar
              size={18}
              color={
                globalBillingMethod === 'MINIMUM_BILLING'
                  ? '#ffffff'
                  : '#64748b'
              }
            />
            <Text
              style={[
                styles.methodButtonText,
                globalBillingMethod === 'MINIMUM_BILLING' &&
                  styles.methodButtonTextActive,
              ]}
            >
              Minimum Billing
            </Text>
          </TouchableOpacity>
        </View>
      </View>

      {renderDayTypeCard('Weekdays', 'weekdays', '', expandedDayCards.has('weekdays'), () => toggleDayCard('weekdays'))}
      {renderDayTypeCard('Saturday', 'saturday', '', expandedDayCards.has('saturday'), () => toggleDayCard('saturday'))}
      {renderDayTypeCard('Sunday', 'sunday', '', expandedDayCards.has('sunday'), () => toggleDayCard('sunday'))}
      {renderDayTypeCard('Public Holidays', 'publicHolidays', '', expandedDayCards.has('publicHolidays'), () => toggleDayCard('publicHolidays'))}
      {renderRainDayConfig()}
    </ScrollView>
  );

  const renderTimesheetsView = () => (
    <View style={styles.timesheetsContainer}>
      {!selectedAssetForTimesheets ? (
        <View>
          <View style={styles.timesheetSelector}>
            <Text style={styles.timesheetSelectorLabel}>Select Subcontractor:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.subList}>
              {subcontractors.map(sub => (
                <TouchableOpacity
                  key={sub.id}
                  style={[
                    styles.subButton,
                    selectedSubcontractor === sub.id && styles.subButtonActive,
                  ]}
                  onPress={() => {
                    setSelectedSubcontractor(sub.id!);
                    loadPlantAssets(sub.id!);
                  }}
                >
                  <Text
                    style={[
                      styles.subButtonText,
                      selectedSubcontractor === sub.id && styles.subButtonTextActive,
                    ]}
                  >
                    {sub.name}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>

          <View style={styles.dateRangeContainer}>
            <View style={styles.dateRangeHeader}>
              <CalendarDays size={20} color="#1e3a8a" />
              <Text style={styles.dateRangeTitle}>Date Range</Text>
            </View>
            
            <View style={styles.datePickersRow}>
              <View style={styles.datePickerBlock}>
                <Text style={styles.datePickerLabel}>Start Date</Text>
                {Platform.OS === 'web' ? (
                  <input
                    type="date"
                    value={startDate.toISOString().split('T')[0]}
                    onChange={(e: any) => handleDateChange('start', new Date(e.target.value))}
                    style={{
                      height: 48,
                      borderWidth: 1,
                      borderColor: '#e2e8f0',
                      borderRadius: 8,
                      paddingLeft: 12,
                      paddingRight: 12,
                      fontSize: 15,
                      color: '#1e293b',
                      backgroundColor: '#ffffff',
                      fontFamily: 'system-ui',
                    }}
                  />
                ) : (
                  <TouchableOpacity
                    style={styles.dateButton}
                    onPress={() => setShowStartDatePicker(!showStartDatePicker)}
                  >
                    <Calendar size={18} color="#64748b" />
                    <Text style={styles.dateButtonText}>{formatDate(startDate)}</Text>
                  </TouchableOpacity>
                )}
              </View>

              <View style={styles.datePickerBlock}>
                <Text style={styles.datePickerLabel}>End Date</Text>
                {Platform.OS === 'web' ? (
                  <input
                    type="date"
                    value={endDate.toISOString().split('T')[0]}
                    onChange={(e: any) => handleDateChange('end', new Date(e.target.value))}
                    style={{
                      height: 48,
                      borderWidth: 1,
                      borderColor: '#e2e8f0',
                      borderRadius: 8,
                      paddingLeft: 12,
                      paddingRight: 12,
                      fontSize: 15,
                      color: '#1e293b',
                      backgroundColor: '#ffffff',
                      fontFamily: 'system-ui',
                    }}
                  />
                ) : (
                  <TouchableOpacity
                    style={styles.dateButton}
                    onPress={() => setShowEndDatePicker(!showEndDatePicker)}
                  >
                    <Calendar size={18} color="#64748b" />
                    <Text style={styles.dateButtonText}>{formatDate(endDate)}</Text>
                  </TouchableOpacity>
                )}
              </View>
            </View>
          </View>

          {plantAssets.length > 0 && (
            <View style={styles.assetListContainer}>
              <Text style={styles.assetListTitle}>Select Plant Asset:</Text>
              <FlatList
                data={plantAssets}
                keyExtractor={(item) => item.id || ''}
                renderItem={({ item }) => (
                  <TouchableOpacity
                    style={styles.assetListCard}
                    onPress={() => {
                      setSelectedAssetForTimesheets(item);
                      loadTimesheetsForAsset(item);
                    }}
                  >
                    <View style={styles.assetListIcon}>
                      <FileText size={24} color="#3b82f6" />
                    </View>
                    <View style={{ flex: 1 }}>
                      <Text style={styles.assetListType}>{item.type}</Text>
                      <Text style={styles.assetListNumber}>
                        {item.plantNumber || item.registrationNumber || item.assetId}
                      </Text>
                    </View>
                    <ChevronDown size={24} color="#64748b" style={{ transform: [{ rotate: '-90deg' }] }} />
                  </TouchableOpacity>
                )}
                contentContainerStyle={{ paddingBottom: 16 }}
              />
            </View>
          )}
        </View>
      ) : (
        <View style={styles.timesheetDataContainer}>
          <View style={styles.timesheetHeader}>
            <TouchableOpacity
              style={styles.backButton}
              onPress={() => {
                setSelectedAssetForTimesheets(null);
                setTimesheets([]);
              }}
            >
              <ChevronDown size={24} color="#1e3a8a" style={{ transform: [{ rotate: '90deg' }] }} />
              <Text style={styles.backButtonText}>Back to Assets</Text>
            </TouchableOpacity>

            <View style={styles.selectedAssetHeader}>
              <Text style={styles.selectedAssetTitle}>{selectedAssetForTimesheets.type}</Text>
              <Text style={styles.selectedAssetSubtitle}>
                {selectedAssetForTimesheets.plantNumber || selectedAssetForTimesheets.registrationNumber || selectedAssetForTimesheets.assetId}
              </Text>
              <Text style={styles.selectedAssetDateRange}>
                {formatDate(startDate)} - {formatDate(endDate)}
              </Text>
            </View>
          </View>

          {selectedEphAssetForTimesheets && (
            <View style={styles.ephLinkBanner}>
              <Text style={styles.ephLinkText}> Viewing timesheets for EPH Report</Text>
              <TouchableOpacity
                onPress={() => {
                  setActiveTab('eph');
                  setSelectedEphAssetForTimesheets(null);
                }}
              >
                <Text style={styles.ephLinkBackText}>Back to EPH</Text>
              </TouchableOpacity>
            </View>
          )}

          {loading ? (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Loading timesheets...</Text>
            </View>
          ) : timesheets.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>No timesheets found for this asset in the selected date range</Text>
            </View>
          ) : (
            <ScrollView
              style={styles.timesheetContent}
              contentContainerStyle={styles.timesheetContentContainer}
              testID="timesheet-detail-scroll"
            >
              <View style={styles.metricsRow}>
                <View style={styles.metricCard} testID="timesheet-metric-entries">
                  <Text style={styles.metricLabel}>Entries</Text>
                  <Text style={styles.metricValue}>{timesheets.length}</Text>
                </View>
                <View style={styles.metricCard} testID="timesheet-metric-range">
                  <Text style={styles.metricLabel}>Visible Range</Text>
                  <Text style={styles.metricValue}>
                    {timesheetGroups.length > 0
                      ? `${new Date(timesheetGroups[timesheetGroups.length - 1].date).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' })} - ${new Date(timesheetGroups[0].date).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' })}`
                      : ''}
                  </Text>
                </View>
              </View>

              <ScrollView
                horizontal
                showsHorizontalScrollIndicator
                style={styles.horizontalScroller}
                contentContainerStyle={styles.horizontalScrollerContent}
                testID="timesheet-horizontal-scroll"
              >
                <View style={styles.dataTable}>
                  <View style={styles.dataHeaderRow}>
                    <Text style={[styles.dataHeaderCell, styles.dateCell]}>Date</Text>
                    <Text style={[styles.dataHeaderCell, styles.dayCell]}>Day</Text>
                    <Text style={[styles.dataHeaderCell, styles.badgeCell]}>Entry</Text>
                    <Text style={[styles.dataHeaderCell, styles.operatorCell]}>Operator</Text>
                    <Text style={[styles.dataHeaderCell, styles.timeCell]}>Open</Text>
                    <Text style={[styles.dataHeaderCell, styles.timeCell]}>Close</Text>
                    <Text style={[styles.dataHeaderCell, styles.hoursCell]}>Hours</Text>
                    <Text style={[styles.dataHeaderCell, styles.statusCell]}>Rain</Text>
                    <Text style={[styles.dataHeaderCell, styles.statusCell]}>Strike</Text>
                    <Text style={[styles.dataHeaderCell, styles.statusCell]}>Break</Text>
                    <Text style={[styles.dataHeaderCell, styles.statusCell]}>Holiday</Text>
                    <Text style={[styles.dataHeaderCell, styles.notesCell]}>Notes</Text>
                  </View>

                  {timesheetGroups.map((group, groupIndex) => {
                    const visibleRows = group.rows;

                    if (visibleRows.length === 0) {
                      return null;
                    }

                    const groupDate = new Date(group.date);
                    // Calculate effective hours for this day using hierarchy:
                    // Admin edit > Plant Manager edit > Operator entry
                    const assetPendingEditsForGroup = selectedAssetForTimesheets
                      ? pendingEdits.get(selectedAssetForTimesheets.assetId) || []
                      : [];
                    const adminEditForDay = assetPendingEditsForGroup.find(
                      edit => edit.date === group.date && edit.editedBy === 'admin' && edit.status === 'pending_review'
                    );
                    
                    let groupHours = 0;
                    if (adminEditForDay) {
                      // Use admin's hours if admin edited this day
                      groupHours = adminEditForDay.totalHours;
                    } else {
                      // Look for PM entry (adjusted), if not found use operator entry
                      const pmRow = visibleRows.find(row => row.badgeLabel === 'PM');
                      const origRow = visibleRows.find(row => row.badgeLabel === 'ORIG');
                      
                      if (pmRow) {
                        groupHours = pmRow.totalHours;
                      } else if (origRow) {
                        groupHours = origRow.totalHours;
                      } else if (visibleRows.length > 0) {
                        // Fallback: use first visible row
                        groupHours = visibleRows[0].totalHours;
                      }
                    }
                    
                    const backgroundColor = groupIndex % 2 === 0 ? '#f8fafc' : '#ffffff';

                    return (
                      <View
                        key={group.date}
                        style={[styles.groupWrapper, { backgroundColor }]}
                        testID={`timesheet-group-${group.date}`}
                      >
                        <View style={styles.groupHeaderRow}>
                          <View style={styles.groupHeaderLeft}>
                            <Text style={styles.groupHeaderTextPrimary}>
                              {groupDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'long', year: 'numeric' })}
                            </Text>
                            <Text style={styles.groupHeaderTextSecondary}>
                              {groupDate.toLocaleDateString('en-GB', { weekday: 'long' })}
                            </Text>
                            <Text style={styles.groupHeaderInsight}>
                              {`${group.rows.filter(r => r.badgeLabel === 'ORIG').length} operator  ${group.rows.filter(r => r.badgeLabel === 'PM').length} plant manager entries`}
                            </Text>
                          </View>
                          <View style={styles.groupMeta}>
                            <Text style={styles.groupHours}>{groupHours.toFixed(2)}h</Text>
                            {group.hasAdjustments && (
                              <View style={styles.adjustmentPill}>
                                <Text style={styles.adjustmentPillText}>Has Adjustments</Text>
                              </View>
                            )}
                          </View>
                        </View>

                        {visibleRows.map((row) => (
                          <View key={row.id} style={styles.dataRow} testID={`timesheet-row-${row.id}`}>
                            <Text style={[styles.cell, styles.dateCell]}>{row.dateLabel}</Text>
                            <Text style={[styles.cell, styles.dayCell]}>{row.weekdayLabel}</Text>
                            <View style={[styles.cell, styles.badgeCell]}>
                              <View
                                style={[
                                  styles.entryBadge,
                                  row.isOriginal ? styles.entryBadgeOriginal : styles.entryBadgeAdjusted,
                                ]}
                              >
                                <Text style={styles.entryBadgeText}>{row.badgeLabel}</Text>
                              </View>
                            </View>
                            <Text style={[styles.cell, styles.operatorCell]} numberOfLines={1}>
                              {row.operatorName}
                            </Text>
                            <Text style={[styles.cell, styles.timeCell]}>{row.openHours}</Text>
                            <Text style={[styles.cell, styles.timeCell]}>{row.closeHours}</Text>
                            <Text style={[styles.cell, styles.hoursCell]}>{row.totalHours.toFixed(2)}h</Text>
                            <View style={[styles.cell, styles.statusCell]}>
                              {row.isRainDay ? (
                                <CloudRain size={16} color="#2563eb" />
                              ) : (
                                <Text style={styles.statusPlaceholder}></Text>
                              )}
                            </View>
                            <View style={[styles.cell, styles.statusCell]}>
                              {row.isStrikeDay ? (
                                <AlertTriangle size={16} color="#ef4444" />
                              ) : (
                                <Text style={styles.statusPlaceholder}></Text>
                              )}
                            </View>
                            <View style={[styles.cell, styles.statusCell]}>
                              {row.isBreakdown ? (
                                <Wrench size={16} color="#f59e0b" />
                              ) : (
                                <Text style={styles.statusPlaceholder}></Text>
                              )}
                            </View>
                            <View style={[styles.cell, styles.statusCell]}>
                              {row.isPublicHoliday ? (
                                <Text style={styles.statusHoliday}></Text>
                              ) : (
                                <Text style={styles.statusPlaceholder}></Text>
                              )}
                            </View>
                            <Text style={[styles.cell, styles.notesCell]} numberOfLines={1}>
                              {row.notes ?? ''}
                            </Text>
                          </View>
                        ))}
                      </View>
                    );
                  })}
                </View>
              </ScrollView>

              <View style={styles.summaryBar}>
                <Text style={styles.summaryLabel}>Total Hours</Text>
                <Text style={styles.summaryValue}>{totalTimesheetHours.toFixed(2)}h</Text>
              </View>

              {selectedEphAssetForTimesheets && (
                <View style={styles.timesheetAttachmentInfo}>
                  <Text style={styles.attachmentInfoText}>
                     These timesheets are included in the EPH report for this asset
                  </Text>
                </View>
              )}
            </ScrollView>
          )}
        </View>
      )}
    </View>
  );

  const handleViewTimesheets = (assetId: string) => {
    setSelectedEphAssetForTimesheets(assetId);
    setActiveTab('timesheets');
    const asset = plantAssets.find(a => a.id === assetId);
    if (asset) {
      setSelectedAssetForTimesheets(asset);
      loadTimesheetsForAsset(asset);
    }
  };

  const handleOpenAgreedHoursModal = async (assetId: string) => {
    console.log('[EPH] Opening agreed hours modal for asset:', assetId);
    const timesheets = ephTimesheets.get(assetId);
    
    if (!timesheets || timesheets.length === 0) {
      Alert.alert('No Timesheets', 'No timesheets found for this asset in the selected date range.');
      return;
    }

    const dedupedEntries = deduplicateTimesheetEntries(timesheets);
    
    if (dedupedEntries.length === 1) {
      const existingAgreed = await getAgreedTimesheetByOriginalId(dedupedEntries[0].id);
      if (existingAgreed) {
        Alert.alert(
          'Already Agreed',
          `This timesheet has already been agreed on ${new Date(existingAgreed.agreedAt.toDate()).toLocaleDateString('en-GB')}.\n\nAgreed Hours: ${existingAgreed.agreedHours}h\nOriginal Hours: ${existingAgreed.originalHours}h`,
          [
            { text: 'OK', style: 'default' },
          ]
        );
        return;
      }
      
      setSelectedTimesheetForAgreement(dedupedEntries[0]);
      setAgreedHoursModalVisible(true);
    } else {
      Alert.alert(
        'Multiple Timesheets',
        `This asset has ${dedupedEntries.length} timesheet entries in the selected date range. Please use the View Timesheets option to agree hours for individual dates.`,
        [{ text: 'OK' }]
      );
    }
  };

  const handleAgreeHours = async (data: { agreedHours?: number; agreedNotes?: string }) => {
    if (!selectedTimesheetForAgreement || !user) {
      console.error('[EPH] Missing timesheet or user');
      return;
    }

    try {
      console.log('[EPH] Agreeing hours:', data);
      const agreedByIdentifier = user.userId || user.id || 'Unknown Admin';
      
      const billingCalcConfig: BillingConfigForCalculation = {
        weekdays: { minHours: config.weekdays.minHours || 0 },
        saturday: { minHours: config.saturday.minHours || 0 },
        sunday: { minHours: config.sunday.minHours || 0 },
        publicHolidays: { minHours: config.publicHolidays.minHours || 0 },
        rainDays: { enabled: config.rainDays.enabled, minHours: config.rainDays.minHours },
        breakdown: { enabled: config.breakdown?.enabled ?? true },
      };
      
      await agreePlantAssetTimesheet(
        selectedTimesheetForAgreement,
        {
          agreedHours: data.agreedHours,
          agreedNotes: data.agreedNotes,
          isBreakdown: selectedTimesheetForAgreement.logBreakdown,
          isRainDay: selectedTimesheetForAgreement.inclementWeather,
          isInclementWeather: selectedTimesheetForAgreement.inclementWeather,
          isPublicHoliday: false,
        },
        agreedByIdentifier,
        'digital',
        'Admin',
        billingCalcConfig
      );

      Alert.alert('Success', 'Hours agreed successfully and ready for billing.');
      
      if (selectedSubcontractor) {
        await loadPlantAssets(selectedSubcontractor);
      }
    } catch (error) {
      console.error('[EPH] Error agreeing hours:', error);
      throw error;
    }
  };

  const toggleAssetSelection = (assetId: string) => {
    setSelectedAssetIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(assetId)) {
        newSet.delete(assetId);
      } else {
        newSet.add(assetId);
      }
      return newSet;
    });
  };

  const handleGenerateSelectedReport = () => {
    console.log('[Generate] Generate Selected clicked');
    if (selectedAssetIds.size === 0) {
      Alert.alert(
        'No Selection',
        'Please select at least one asset by tapping the checkbox next to it, then try again.',
        [{ text: 'OK' }]
      );
      return;
    }
    setReportGenerationModalVisible(true);
  };

  const handleGenerateAllReport = () => {
    console.log('[Generate] Generate All clicked');
    setReportGenerationModalVisible(true);
  };

  const loadPendingEdits = useCallback(async () => {
    if (!user?.masterAccountId) return;
    
    console.log('[EPH] Loading pending edits for all assets');
    const editsMap = new Map<string, EPHPendingEdit[]>();
    
    for (const asset of plantAssets) {
      const edits = await getAllPendingEditsByAssetId(asset.assetId, user.masterAccountId);
      if (edits.length > 0) {
        editsMap.set(asset.assetId, edits);
      }
    }
    
    setPendingEdits(editsMap);
    console.log('[EPH] Loaded pending edits for', editsMap.size, 'assets');
  }, [plantAssets, user?.masterAccountId]);

  useEffect(() => {
    if (activeTab === 'eph' && plantAssets.length > 0) {
      loadPendingEdits();
    }
  }, [activeTab, plantAssets, loadPendingEdits]);

  const handleEditHours = async (assetId: string) => {
    console.log('[EPH] Edit hours clicked for asset:', assetId);
    const timesheets = ephTimesheets.get(assetId);
    
    if (!timesheets || timesheets.length === 0) {
      Alert.alert('No Timesheets', 'No timesheets found for this asset.');
      return;
    }
    
    if (timesheets.length > 1) {
      Alert.alert(
        'Multiple Timesheets',
        `This asset has ${timesheets.length} timesheet entries. Please use View Timesheets to edit individual dates.`,
        [{ text: 'OK' }]
      );
      return;
    }
    
    const asset = plantAssets.find(a => a.assetId === assetId);
    setSelectedTimesheetForEdit({
      ...timesheets[0],
      assetType: asset?.type,
      plantNumber: asset?.plantNumber || asset?.registrationNumber,
    });
    setEditModalVisible(true);
  };

  const handleSaveEdit = async (editedValues: any) => {
    if (!selectedTimesheetForEdit || !user) {
      console.error('[EPH] Missing timesheet or user');
      return;
    }
    
    try {
      console.log('[EPH] Saving edit:', editedValues);
      const asset = plantAssets.find(a => a.assetId === selectedTimesheetForEdit.assetId);
      const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
      
      await createPendingEdit({
        originalTimesheetId: selectedTimesheetForEdit.id,
        assetId: selectedTimesheetForEdit.assetId,
        assetType: asset?.type || 'Unknown',
        plantNumber: asset?.plantNumber || asset?.registrationNumber,
        date: selectedTimesheetForEdit.date,
        editedBy: 'admin',
        editedByUserId: user.userId || user.id || 'unknown',
        editedByName: user.name || 'Admin',
        totalHours: editedValues.totalHours,
        openHours: editedValues.openHours,
        closeHours: editedValues.closeHours,
        isBreakdown: editedValues.isBreakdown,
        isRainDay: editedValues.isRainDay,
        isStrikeDay: editedValues.isStrikeDay,
        isPublicHoliday: editedValues.isPublicHoliday,
        notes: editedValues.adminNotes,
        originalTotalHours: selectedTimesheetForEdit.totalHours || 0,
        originalOpenHours: selectedTimesheetForEdit.openHours || '00:00',
        originalCloseHours: selectedTimesheetForEdit.closeHours || '00:00',
        masterAccountId: user.masterAccountId || '',
        siteId: user.siteId || '',
        subcontractorId: selectedSubcontractor || '',
        subcontractorName: subcontractor?.name || 'Unknown',
      });
      
      Alert.alert('Success', 'Hours edited successfully. Changes are pending subcontractor review.');
      await loadPendingEdits();
    } catch (error) {
      console.error('[EPH] Error saving edit:', error);
      throw error;
    }
  };

  const handleCompareVersions = async (assetId: string) => {
    console.log('[EPH] Compare versions clicked for asset:', assetId);
    const timesheets = ephTimesheets.get(assetId);
    const edits = pendingEdits.get(assetId);
    
    if (!timesheets || timesheets.length === 0) {
      Alert.alert('No Timesheets', 'No timesheets found for this asset.');
      return;
    }
    
    if (!edits || edits.length === 0) {
      Alert.alert('No Edits', 'No pending edits found for this asset.');
      return;
    }
    
    const plantManagerVersion = timesheets[0];
    const adminEdit = edits.find(e => e.editedBy === 'admin');
    const subcontractorEdit = edits.find(e => e.editedBy === 'subcontractor');
    
    const asset = plantAssets.find(a => a.assetId === assetId);
    
    setSelectedComparison({
      plantManager: {
        ...plantManagerVersion,
        assetType: asset?.type,
        plantNumber: asset?.plantNumber || asset?.registrationNumber,
      },
      adminEdited: adminEdit ? {
        id: adminEdit.id,
        date: adminEdit.date,
        operatorName: plantManagerVersion.operatorName,
        assetType: adminEdit.assetType,
        plantNumber: adminEdit.plantNumber,
        totalHours: adminEdit.totalHours,
        openHours: adminEdit.openHours,
        closeHours: adminEdit.closeHours,
        isBreakdown: adminEdit.isBreakdown,
        isRainDay: adminEdit.isRainDay,
        isStrikeDay: adminEdit.isStrikeDay,
        isPublicHoliday: adminEdit.isPublicHoliday,
        notes: adminEdit.notes,
      } : undefined,
      subcontractorEdited: subcontractorEdit ? {
        id: subcontractorEdit.id,
        date: subcontractorEdit.date,
        operatorName: plantManagerVersion.operatorName,
        assetType: subcontractorEdit.assetType,
        plantNumber: subcontractorEdit.plantNumber,
        totalHours: subcontractorEdit.totalHours,
        openHours: subcontractorEdit.openHours,
        closeHours: subcontractorEdit.closeHours,
        isBreakdown: subcontractorEdit.isBreakdown,
        isRainDay: subcontractorEdit.isRainDay,
        isStrikeDay: subcontractorEdit.isStrikeDay,
        isPublicHoliday: subcontractorEdit.isPublicHoliday,
        notes: subcontractorEdit.notes,
      } : undefined,
    });
    
    setComparisonModalVisible(true);
  };

  const handleDirectApproveEPH = async () => {
    if (!selectedSubcontractor || !user) {
      Alert.alert('Error', 'Missing subcontractor or user information');
      return;
    }
    
    console.log('[EPH] Direct approving EPH for selected assets');
    
    try {
      const selectedAssets = Array.from(selectedAssetIds).map(id => 
        ephData.find(record => record.assetId === id)
      ).filter(Boolean) as typeof ephData;
      
      if (selectedAssets.length === 0) {
        Alert.alert('Error', 'No assets selected');
        return;
      }
      
      const allTimesheets: any[] = [];
      for (const asset of selectedAssets) {
        const timesheets = ephTimesheets.get(asset.assetId) || [];
        const dedupedTimesheets = deduplicateTimesheetEntries(timesheets);
        allTimesheets.push(...dedupedTimesheets);
      }
      
      const agreedByIdentifier = user.userId || user.id || 'Admin';
      
      const billingCalcConfig: BillingConfigForCalculation = {
        weekdays: { minHours: config.weekdays.minHours || 0 },
        saturday: { minHours: config.saturday.minHours || 0 },
        sunday: { minHours: config.sunday.minHours || 0 },
        publicHolidays: { minHours: config.publicHolidays.minHours || 0 },
        rainDays: { enabled: config.rainDays.enabled, minHours: config.rainDays.minHours },
        breakdown: { enabled: config.breakdown?.enabled ?? true },
      };
      
      await directApproveEPHTimesheets(
        allTimesheets,
        agreedByIdentifier,
        `Direct approval by admin - ${new Date().toLocaleDateString('en-GB')}`,
        'Admin',
        billingCalcConfig
      );
      
      Alert.alert(
        'Success', 
        `${selectedAssets.length} asset(s) approved and finalized. You can now generate PDF reports manually.`,
        [
          {
            text: 'OK',
            onPress: () => {
              if (selectedSubcontractor) {
                loadPlantAssets(selectedSubcontractor);
              }
            },
          },
        ]
      );
    } catch (error) {
      console.error('[EPH] Error direct approving:', error);
      throw error;
    }
  };

  const handleSendToSubcontractor = async (recipientEmail: string, message: string) => {
    if (!selectedSubcontractor || !user) {
      Alert.alert('Error', 'Missing subcontractor or user information');
      return;
    }
    
    console.log('[EPH] Sending to subcontractor:', recipientEmail);
    
    try {
      const selectedAssets = Array.from(selectedAssetIds).map(id => 
        ephData.find(record => record.assetId === id)
      ).filter(Boolean) as typeof ephData;
      
      const totalHours = selectedAssets.reduce((sum, asset) => sum + asset.totalBillableHours, 0);
      const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
      
      const groups = selectedAssets.map(record => {
        const timesheets = ephTimesheets.get(record.assetId) || [];
        const dedupedTimesheets = deduplicateTimesheetEntries(timesheets);
        const billingResultsByDate = record.billingResultsByDate || new Map<string, BillableHoursResult>();
        
        return {
          key: record.assetId,
          title: record.assetType,
          subtitle: record.plantNumber || record.registrationNumber || record.assetId,
          entries: dedupedTimesheets.map(ts => {
            // Get the billing result for this date to populate actualHours and billableHours
            const billingResult = billingResultsByDate.get(ts.date);
            
            return {
              id: ts.id,
              date: ts.date,
              operatorName: ts.operatorName,
              operatorId: ts.operatorName || '',
              verified: true,
              verifiedAt: ts.verifiedAt || new Date().toISOString(),
              verifiedBy: ts.adjustedBy || 'system',
              masterAccountId: user?.masterAccountId || '',
              siteId: user?.siteId || '',
              type: 'plant_hours' as const,
              openHours: parseFloat(ts.openHours) || 0,
              closeHours: parseFloat(ts.closeHours) || 0,
              totalHours: ts.totalHours || 0,
              // Use pre-calculated hours from billing logic - DO NOT recalculate in PDF
              actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
              billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
              assetRate: record.rate,
              totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
              billingRule: billingResult?.appliedRule,
              isBreakdown: ts.isBreakdown,
              inclementWeather: ts.isRainDay,
              isRainDay: ts.isRainDay,
              isStrikeDay: ts.isStrikeDay,
              isPublicHoliday: ts.isPublicHoliday,
              hasAttachment: false,
              assetId: record.assetId,
              assetType: record.assetType,
              plantNumber: record.plantNumber,
              registrationNumber: record.registrationNumber,
              ownerId: selectedSubcontractor,
              ownerType: 'subcontractor' as const,
              ownerName: subcontractor?.name,
              hasOriginalEntry: ts.hasOriginalEntry,
              originalEntryData: ts.originalEntryData,
              isAdjustment: ts.isAdjustment,
              originalEntryId: ts.originalEntryId,
              adjustedBy: ts.adjustedBy,
              adjustedAt: ts.adjustedAt,
              notes: ts.notes || ts.adminNotes || ts.billingNotes,
            };
          }),
          dateGroups: dedupedTimesheets.map(ts => {
            const hasAdjustment = ts.hasOriginalEntry || ts.isAdjustment || Boolean(ts.adjustedBy);
            const billingResult = billingResultsByDate.get(ts.date);
            const originalBillingResult = ts.originalEntryData?.date 
              ? billingResultsByDate.get(ts.originalEntryData.date)
              : undefined;
            
            if (hasAdjustment && ts.originalEntryData) {
              return {
                date: ts.date,
                operatorEntry: {
                  ...ts.originalEntryData,
                  id: ts.originalEntryId || ts.id,
                  date: ts.date,
                  operatorName: ts.originalEntryData.operatorName || ts.operatorName,
                  openHours: parseFloat(String(ts.originalEntryData.openHours || 0)),
                  closeHours: parseFloat(String(ts.originalEntryData.closeHours || ts.originalEntryData.closingHours || 0)),
                  totalHours: ts.originalEntryData.totalHours || 0,
                  actualHours: ts.originalEntryData.totalHours || 0,
                  billableHours: originalBillingResult?.billableHours ?? ts.originalEntryData.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (originalBillingResult?.billableHours ?? ts.originalEntryData.totalHours ?? 0) * record.rate,
                  billingRule: originalBillingResult?.appliedRule,
                  isBreakdown: ts.originalEntryData.isBreakdown,
                  inclementWeather: ts.originalEntryData.isRainDay,
                  isRainDay: ts.originalEntryData.isRainDay,
                  isStrikeDay: ts.originalEntryData.isStrikeDay,
                  isPublicHoliday: ts.originalEntryData.isPublicHoliday,
                  notes: ts.originalEntryData.notes,
                  agreedByRole: 'Operator' as const,
                } as any,
                plantManagerEntry: {
                  ...ts,
                  id: ts.id,
                  date: ts.date,
                  operatorName: ts.operatorName,
                  openHours: parseFloat(String(ts.openHours || 0)),
                  closeHours: parseFloat(String(ts.closeHours || ts.closingHours || 0)),
                  totalHours: ts.totalHours || 0,
                  actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
                  billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
                  billingRule: billingResult?.appliedRule,
                  isBreakdown: ts.isBreakdown,
                  inclementWeather: ts.isRainDay,
                  isRainDay: ts.isRainDay,
                  isStrikeDay: ts.isStrikeDay,
                  isPublicHoliday: ts.isPublicHoliday,
                  notes: ts.notes || ts.adminNotes || ts.billingNotes,
                  adjustedBy: ts.adjustedBy,
                  adjustedAt: ts.adjustedAt,
                  agreedBy: ts.adjustedBy,
                  agreedByRole: 'Plant Manager' as const,
                } as any,
                adminEntry: undefined,
                subcontractorEntry: undefined,
              };
            } else {
              return {
                date: ts.date,
                operatorEntry: {
                  id: ts.id,
                  date: ts.date,
                  operatorName: ts.operatorName,
                  openHours: parseFloat(String(ts.openHours || 0)),
                  closeHours: parseFloat(String(ts.closeHours || ts.closingHours || 0)),
                  totalHours: ts.totalHours || 0,
                  actualHours: billingResult?.actualHours ?? ts.totalHours ?? 0,
                  billableHours: billingResult?.billableHours ?? ts.totalHours ?? 0,
                  assetRate: record.rate,
                  totalCost: (billingResult?.billableHours ?? ts.totalHours ?? 0) * record.rate,
                  billingRule: billingResult?.appliedRule,
                  isBreakdown: ts.isBreakdown,
                  inclementWeather: ts.isRainDay,
                  isRainDay: ts.isRainDay,
                  isStrikeDay: ts.isStrikeDay,
                  isPublicHoliday: ts.isPublicHoliday,
                  notes: ts.notes || ts.operatorNotes,
                  agreedByRole: 'Operator' as const,
                } as any,
                plantManagerEntry: undefined,
                adminEntry: undefined,
                subcontractorEntry: undefined,
              };
            }
          }),
        };
      });
      
      const { uri, fileName } = await generateTimesheetPDF({
        groups,
        reportType: 'plant',
        subcontractorName: subcontractor?.name,
        dateRange: {
          from: startDate,
          to: endDate,
        },
        selectedOnly: true,
        selectedGroups: new Set(selectedAssets.map(r => r.assetId)),
      });
      
      await sendEPHToSubcontractor({
        recipientEmail,
        message,
        pdfUri: uri,
        pdfFileName: fileName,
        subcontractorName: subcontractor?.name || 'Unknown',
        dateRange: { from: startDate, to: endDate },
        assetCount: selectedAssets.length,
        totalHours,
        companyName: user.companyName || 'Your Company',
      });
      
      Alert.alert('Success', 'EPH report sent to subcontractor');
    } catch (error) {
      console.error('[EPH] Error sending to subcontractor:', error);
      throw error;
    }
  };

  const renderEPHRecord = ({ item }: { item: EPHRecord }) => {
    const isExpanded = expandedCards.has(item.assetId);
    const isSelected = selectedAssetIds.has(item.assetId);
    const hasPendingEdits = pendingEdits.has(item.assetId);

    return (
      <View style={styles.ephCard}>
        <TouchableOpacity 
          style={styles.ephCardHeader}
          onPress={() => toggleCardExpansion(item.assetId)}
          activeOpacity={0.7}
        >
          <TouchableOpacity
            onPress={() => toggleAssetSelection(item.assetId)}
            style={styles.checkboxContainer}
          >
            {isSelected ? (
              <CheckSquare size={24} color="#1e3a8a" />
            ) : (
              <Square size={24} color="#94a3b8" />
            )}
          </TouchableOpacity>
          <View style={styles.ephHeaderLeft}>
            <View style={styles.ephHeaderTitleRow}>
              <Text style={styles.ephAssetType}>{item.assetType}</Text>
              {hasPendingEdits && (
                <View style={styles.pendingEditBadge}>
                  <Text style={styles.pendingEditBadgeText}>Edits Pending</Text>
                </View>
              )}
            </View>
            <Text style={styles.ephAssetNumber}>
              {item.plantNumber || item.registrationNumber || item.assetId}
            </Text>
          </View>
          {isExpanded ? (
            <ChevronUp size={24} color="#64748b" />
          ) : (
            <ChevronDown size={24} color="#64748b" />
          )}
        </TouchableOpacity>

        <View style={styles.ephMinimalInfo}>
          <View style={styles.ephInfoRow}>
            <Text style={styles.ephInfoLabel}>Rate:</Text>
            <View style={styles.ephRateContainer}>
              <Text style={styles.ephRateBadge}>{item.rateType.toUpperCase()}</Text>
              <Text style={styles.ephInfoValue}>R{item.rate.toFixed(2)}/hr</Text>
            </View>
          </View>
          <View style={styles.ephDivider} />
          <View style={styles.ephInfoRow}>
            <Text style={styles.ephInfoLabel}>Actual Clock Hours:</Text>
            <Text style={styles.ephInfoValue}>{item.totalActualHours.toFixed(1)}h</Text>
          </View>
          <View style={styles.ephInfoRow}>
            <Text style={styles.ephTotalLabel}>Billable Hours (per config):</Text>
            <Text style={styles.ephTotalValue}>{item.totalBillableHours.toFixed(1)}h</Text>
          </View>
          <View style={styles.ephInfoRow}>
            <Text style={styles.ephTotalLabel}>Total Cost:</Text>
            <Text style={styles.ephCostValue}>R{item.estimatedCost.toFixed(2)}</Text>
          </View>
        </View>

        {isExpanded && (
          <View style={styles.ephExpandedContent}>
            <View style={styles.ephDivider} />
            <Text style={styles.ephBreakdownTitle}>Hours Breakdown (Actual  Billable)</Text>
            <View style={styles.ephGrid}>
              <View style={styles.ephGridHeader}>
                <Text style={styles.ephGridHeaderLabel}>Day Type</Text>
                <Text style={styles.ephGridHeaderValue}>Actual</Text>
                <Text style={styles.ephGridHeaderValue}>Billable</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Weekdays:</Text>
                <Text style={styles.ephValueActual}>{item.actualNormalHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableNormalHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Saturday:</Text>
                <Text style={styles.ephValueActual}>{item.actualSaturdayHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableSaturdayHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Sunday:</Text>
                <Text style={styles.ephValueActual}>{item.actualSundayHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableSundayHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Public Holidays:</Text>
                <Text style={styles.ephValueActual}>{item.actualPublicHolidayHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billablePublicHolidayHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Breakdown:</Text>
                <Text style={styles.ephValueActual}>{item.actualBreakdownHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableBreakdownHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Rain Days:</Text>
                <Text style={styles.ephValueActual}>{item.actualRainDayHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableRainDayHours.toFixed(1)}h</Text>
              </View>
              <View style={styles.ephRow}>
                <Text style={styles.ephLabel}>Strike Days:</Text>
                <Text style={styles.ephValueActual}>{item.actualStrikeDayHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillable}>{item.billableStrikeDayHours.toFixed(1)}h</Text>
              </View>
              <View style={[styles.ephRow, styles.ephTotalRow]}>
                <Text style={[styles.ephLabel, styles.ephTotalLabelBold]}>TOTALS:</Text>
                <Text style={styles.ephValueActualTotal}>{item.totalActualHours.toFixed(1)}h</Text>
                <Text style={styles.ephValueBillableTotal}>{item.totalBillableHours.toFixed(1)}h</Text>
              </View>
            </View>
            
            <View style={styles.ephActions}>
              <TouchableOpacity
                style={styles.viewTimesheetsButton}
                onPress={() => handleViewTimesheets(item.assetId)}
              >
                <ClipboardList size={18} color="#1e3a8a" />
                <Text style={styles.viewTimesheetsButtonText}>View Timesheets</Text>
              </TouchableOpacity>

              <View style={styles.ephActionRow}>
                <TouchableOpacity
                  style={styles.editHoursButton}
                  onPress={() => handleEditHours(item.assetId)}
                >
                  <Edit3 size={16} color="#3b82f6" />
                  <Text style={styles.editHoursButtonText}>Edit Hours</Text>
                </TouchableOpacity>

                {hasPendingEdits && (
                  <TouchableOpacity
                    style={styles.compareButton}
                    onPress={() => handleCompareVersions(item.assetId)}
                  >
                    <GitCompare size={16} color="#10b981" />
                    <Text style={styles.compareButtonText}>Compare</Text>
                  </TouchableOpacity>
                )}
              </View>
              
              <TouchableOpacity
                style={styles.agreeHoursButton}
                onPress={() => handleOpenAgreedHoursModal(item.assetId)}
              >
                <Edit3 size={18} color="#ffffff" />
                <Text style={styles.agreeHoursButtonText}>Agree Hours</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          headerTitle: () => <HeaderTitleWithSync title="EPH" />,
          headerStyle: {
            backgroundColor: '#1e3a8a',
          },
          headerTintColor: '#ffffff',
          headerTitleStyle: {
            fontWeight: '600' as const,
          },
          headerRight: () => null,
        }}
      />

      <View style={styles.tabBar}>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'eph' && styles.tabActive]}
          onPress={() => setActiveTab('eph')}
        >
          <FileText size={20} color={activeTab === 'eph' ? '#1e3a8a' : '#64748b'} />
          <Text style={[styles.tabText, activeTab === 'eph' && styles.tabTextActive]}>
            EPH Report
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'timesheets' && styles.tabActive]}
          onPress={() => setActiveTab('timesheets')}
        >
          <ClipboardList size={20} color={activeTab === 'timesheets' ? '#1e3a8a' : '#64748b'} />
          <Text style={[styles.tabText, activeTab === 'timesheets' && styles.tabTextActive]}>
            Process Payments
          </Text>
        </TouchableOpacity>
      </View>

      {activeTab === 'timesheets' ? (
        <View style={styles.timesheetsMainContainer}>
          <View style={styles.timesheetsSubTabBar}>
            <TouchableOpacity
              style={[styles.timesheetsSubTab, timesheetsSubTab === 'machine' && styles.timesheetsSubTabActive]}
              onPress={() => setTimesheetsSubTab('machine')}
            >
              <Wrench size={18} color={timesheetsSubTab === 'machine' ? '#1e3a8a' : '#64748b'} />
              <Text style={[styles.timesheetsSubTabText, timesheetsSubTab === 'machine' && styles.timesheetsSubTabTextActive]}>
                Machine Hours
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.timesheetsSubTab, timesheetsSubTab === 'man' && styles.timesheetsSubTabActive]}
              onPress={() => setTimesheetsSubTab('man')}
            >
              <Clock size={18} color={timesheetsSubTab === 'man' ? '#1e3a8a' : '#64748b'} />
              <Text style={[styles.timesheetsSubTabText, timesheetsSubTab === 'man' && styles.timesheetsSubTabTextActive]}>
                Man Hours
              </Text>
            </TouchableOpacity>
          </View>
          {timesheetsSubTab === 'machine' ? renderTimesheetsView() : renderManHoursView()}
        </View>
      ) : (
        <View style={styles.ephContainer}>
          <View style={styles.ephSelector}>
            <Text style={styles.ephSelectorLabel}>Select Subcontractor:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.subList}>
              {subcontractors.map(sub => (
                <TouchableOpacity
                  key={sub.id}
                  style={[
                    styles.subButton,
                    selectedSubcontractor === sub.id && styles.subButtonActive,
                  ]}
                  onPress={() => {
                    setSelectedSubcontractor(sub.id!);
                    loadPlantAssets(sub.id!);
                  }}
                >
                  <Text
                    style={[
                      styles.subButtonText,
                      selectedSubcontractor === sub.id && styles.subButtonTextActive,
                    ]}
                  >
                    {sub.name}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>

          <View style={styles.dateRangeContainer}>
            <View style={styles.dateRangeHeader}>
              <CalendarDays size={20} color="#1e3a8a" />
              <Text style={styles.dateRangeTitle}>Billing Period</Text>
            </View>
            
            <View style={styles.datePickersRow}>
              <View style={styles.datePickerBlock}>
                <Text style={styles.datePickerLabel}>Start Date</Text>
                {Platform.OS === 'web' ? (
                  <input
                    type="date"
                    value={startDate.toISOString().split('T')[0]}
                    onChange={(e: any) => handleDateChange('start', new Date(e.target.value))}
                    style={{
                      height: 48,
                      borderWidth: 1,
                      borderColor: '#e2e8f0',
                      borderRadius: 8,
                      paddingLeft: 12,
                      paddingRight: 12,
                      fontSize: 15,
                      color: '#1e293b',
                      backgroundColor: '#ffffff',
                      fontFamily: 'system-ui',
                    }}
                  />
                ) : (
                  <TouchableOpacity
                    style={styles.dateButton}
                    onPress={() => setShowStartDatePicker(!showStartDatePicker)}
                  >
                    <Calendar size={18} color="#64748b" />
                    <Text style={styles.dateButtonText}>{formatDate(startDate)}</Text>
                  </TouchableOpacity>
                )}
              </View>

              <View style={styles.datePickerBlock}>
                <Text style={styles.datePickerLabel}>End Date</Text>
                {Platform.OS === 'web' ? (
                  <input
                    type="date"
                    value={endDate.toISOString().split('T')[0]}
                    onChange={(e: any) => handleDateChange('end', new Date(e.target.value))}
                    style={{
                      height: 48,
                      borderWidth: 1,
                      borderColor: '#e2e8f0',
                      borderRadius: 8,
                      paddingLeft: 12,
                      paddingRight: 12,
                      fontSize: 15,
                      color: '#1e293b',
                      backgroundColor: '#ffffff',
                      fontFamily: 'system-ui',
                    }}
                  />
                ) : (
                  <TouchableOpacity
                    style={styles.dateButton}
                    onPress={() => setShowEndDatePicker(!showEndDatePicker)}
                  >
                    <Calendar size={18} color="#64748b" />
                    <Text style={styles.dateButtonText}>{formatDate(endDate)}</Text>
                  </TouchableOpacity>
                )}
              </View>
            </View>

            {selectedSubcontractor && (
              <View style={styles.generateButtonsContainer}>
                <TouchableOpacity
                  style={[styles.generateButton, styles.generateButtonPrimary]}
                  onPress={handleGenerateAllReport}
                >
                  <FileText size={18} color="#ffffff" />
                  <Text style={styles.generateButtonText}>Generate All</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.generateButton,
                    styles.generateButtonSecondary,
                    selectedAssetIds.size === 0 && styles.generateButtonDisabled,
                  ]}
                  onPress={handleGenerateSelectedReport}
                  disabled={selectedAssetIds.size === 0}
                >
                  <CheckSquare size={18} color={selectedAssetIds.size === 0 ? "#94a3b8" : "#1e3a8a"} />
                  <Text style={[
                    styles.generateButtonTextSecondary,
                    selectedAssetIds.size === 0 && styles.generateButtonTextDisabled,
                  ]}>
                    Generate Selected ({selectedAssetIds.size})
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.generateButton,
                    styles.sendToSubButton,
                    selectedAssetIds.size === 0 && styles.generateButtonDisabled,
                  ]}
                  onPress={() => {
                    if (selectedAssetIds.size === 0) {
                      Alert.alert('No Selection', 'Please select at least one asset');
                      return;
                    }
                    const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
                    if (!subcontractor) {
                      Alert.alert('Error', 'Subcontractor not found');
                      return;
                    }
                    setSendModalVisible(true);
                  }}
                  disabled={selectedAssetIds.size === 0}
                >
                  <Send size={18} color={selectedAssetIds.size === 0 ? "#94a3b8" : "#10b981"} />
                  <Text style={[
                    styles.sendToSubButtonText,
                    selectedAssetIds.size === 0 && styles.generateButtonTextDisabled,
                  ]}>
                    Send to Subcontractor
                  </Text>
                </TouchableOpacity>
              </View>
            )}
          </View>

          {loading ? (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Loading plant assets...</Text>
            </View>
          ) : ephData.length > 0 ? (
            <FlatList
              data={ephData}
              renderItem={renderEPHRecord}
              keyExtractor={(item) => item.assetId}
              contentContainerStyle={[
                styles.ephList,
                { paddingBottom: insets.bottom + 20 },
              ]}
            />
          ) : selectedSubcontractor ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>No plant assets found for this subcontractor</Text>
            </View>
          ) : (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>Select a subcontractor to view EPH report</Text>
            </View>
          )}
        </View>
      )}

      <AgreedHoursModal
        visible={agreedHoursModalVisible}
        onClose={() => {
          setAgreedHoursModalVisible(false);
          setSelectedTimesheetForAgreement(null);
        }}
        onSubmit={handleAgreeHours}
        timesheet={selectedTimesheetForAgreement}
        viewMode="plant"
      />

      <ReportGenerationModal
        visible={reportGenerationModalVisible}
        onClose={() => setReportGenerationModalVisible(false)}
        onGenerate={handleGeneratePDFReport}
        hasSelection={selectedAssetIds.size > 0}
        selectedCount={selectedAssetIds.size}
        totalCount={ephData.length}
      />

      <EditEPHHoursModal
        visible={editModalVisible}
        onClose={() => {
          setEditModalVisible(false);
          setSelectedTimesheetForEdit(null);
        }}
        onSave={handleSaveEdit}
        timesheet={selectedTimesheetForEdit}
      />

      <TimesheetComparisonModal
        visible={comparisonModalVisible}
        onClose={() => {
          setComparisonModalVisible(false);
          setSelectedComparison(null);
        }}
        comparison={selectedComparison}
      />

      <SendConfirmationModal
        visible={sendModalVisible}
        onClose={() => setSendModalVisible(false)}
        onSend={handleSendToSubcontractor}
        onDirectApprove={handleDirectApproveEPH}
        subcontractorName={subcontractors.find(s => s.id === selectedSubcontractor)?.name || 'Unknown'}
        assetCount={selectedAssetIds.size}
        dateRange={{ from: startDate, to: endDate }}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
  },
  infoCard: {
    flexDirection: 'row',
    backgroundColor: '#eff6ff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#bfdbfe',
  },
  infoContent: {
    flex: 1,
    marginLeft: 12,
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e3a8a',
    marginBottom: 4,
  },
  infoText: {
    fontSize: 14,
    color: '#475569',
    lineHeight: 20,
  },
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  cardTitleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  cardIcon: {
    fontSize: 24,
    marginRight: 12,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  cardContent: {
    padding: 16,
  },
  formGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
    marginBottom: 8,
  },
  input: {
    height: 48,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    fontSize: 15,
    color: '#1e293b',
    backgroundColor: '#ffffff',
  },
  inputWithIcon: {
    position: 'relative' as const,
  },
  inputIcon: {
    position: 'absolute' as const,
    left: 12,
    top: 14,
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#64748b',
    zIndex: 1,
  },
  inputWithIconField: {
    paddingLeft: 32,
  },
  helperText: {
    fontSize: 12,
    color: '#64748b',
    marginTop: 6,
    fontStyle: 'italic' as const,
  },
  buttonGroup: {
    flexDirection: 'row',
    gap: 8,
  },
  methodButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#ffffff',
    gap: 8,
  },
  methodButtonActive: {
    backgroundColor: '#3b82f6',
    borderColor: '#3b82f6',
  },
  methodButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  methodButtonTextActive: {
    color: '#ffffff',
  },
  saveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginRight: 8,
  },
  saveButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  tabBar: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  tab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    gap: 8,
    borderBottomWidth: 3,
    borderBottomColor: 'transparent',
  },
  tabActive: {
    borderBottomColor: '#1e3a8a',
  },
  tabText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  tabTextActive: {
    color: '#1e3a8a',
  },
  ephContainer: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  ephSelector: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  ephSelectorLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
    marginBottom: 12,
  },
  subList: {
    flexDirection: 'row',
  },
  subButton: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#ffffff',
    marginRight: 8,
  },
  subButtonActive: {
    backgroundColor: '#1e3a8a',
    borderColor: '#1e3a8a',
  },
  subButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
  },
  subButtonTextActive: {
    color: '#ffffff',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    fontSize: 16,
    color: '#64748b',
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center',
  },
  ephList: {
    padding: 16,
  },
  ephCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  ephHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingBottom: 12,
    marginBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  ephHeaderLeft: {
    flex: 1,
  },
  ephAssetType: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  ephAssetNumber: {
    fontSize: 14,
    color: '#64748b',
  },
  ephMinimalInfo: {
    gap: 10,
  },
  ephInfoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  ephInfoLabel: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#475569',
  },
  ephInfoValue: {
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#1e3a8a',
  },
  ephRateContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  ephRateBadge: {
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    backgroundColor: '#3b82f6',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 4,
  },
  ephDivider: {
    height: 1,
    backgroundColor: '#e2e8f0',
    marginVertical: 8,
  },
  ephExpandedContent: {
    marginTop: 8,
  },
  ephBreakdownTitle: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#64748b',
    marginBottom: 12,
    textTransform: 'uppercase' as const,
    letterSpacing: 0.5,
  },
  ephGrid: {
    gap: 8,
  },
  ephRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  ephLabel: {
    fontSize: 14,
    color: '#64748b',
  },
  ephValue: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  ephGridHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingBottom: 8,
    marginBottom: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  ephGridHeaderLabel: {
    flex: 1,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#64748b',
    textTransform: 'uppercase' as const,
  },
  ephGridHeaderValue: {
    width: 70,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#64748b',
    textTransform: 'uppercase' as const,
    textAlign: 'right' as const,
  },
  ephValueActual: {
    width: 70,
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#64748b',
    textAlign: 'right' as const,
  },
  ephValueBillable: {
    width: 70,
    fontSize: 14,
    fontWeight: '700' as const,
    color: '#10b981',
    textAlign: 'right' as const,
  },
  ephTotalRow: {
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
  },
  ephTotalLabelBold: {
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  ephValueActualTotal: {
    width: 70,
    fontSize: 14,
    fontWeight: '700' as const,
    color: '#475569',
    textAlign: 'right' as const,
  },
  ephValueBillableTotal: {
    width: 70,
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#10b981',
    textAlign: 'right' as const,
  },

  ephTotalLabel: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#475569',
  },
  ephTotalValue: {
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#1e3a8a',
  },
  ephCostValue: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#16a34a',
  },
  dateRangeContainer: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  dateRangeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    gap: 8,
  },
  dateRangeTitle: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  datePickersRow: {
    flexDirection: 'row',
    gap: 12,
  },
  datePickerBlock: {
    flex: 1,
  },
  datePickerLabel: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#64748b',
    marginBottom: 8,
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    height: 48,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    backgroundColor: '#ffffff',
  },
  dateButtonText: {
    fontSize: 15,
    color: '#1e293b',
    fontWeight: '500' as const,
  },
  refreshButton: {
    marginTop: 16,
    backgroundColor: '#1e3a8a',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  refreshButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  timesheetsContainer: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  timesheetSelector: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  timesheetSelectorLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
    marginBottom: 12,
  },
  assetListContainer: {
    padding: 16,
  },
  assetListTitle: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 12,
  },
  assetListCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  assetListIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#eff6ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  assetListType: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  assetListNumber: {
    fontSize: 14,
    color: '#64748b',
    marginTop: 2,
  },
  timesheetDataContainer: {
    flex: 1,
  },
  timesheetHeader: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  backButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e3a8a',
    marginLeft: 4,
  },
  selectedAssetHeader: {
    alignItems: 'center',
  },
  selectedAssetTitle: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  selectedAssetSubtitle: {
    fontSize: 14,
    color: '#64748b',
    marginTop: 2,
  },
  selectedAssetDateRange: {
    fontSize: 12,
    color: '#94a3b8',
    marginTop: 4,
  },
  timesheetContent: {
    flex: 1,
    paddingHorizontal: 16,
  },
  timesheetContentContainer: {
    paddingBottom: 32,
  },
  metricsRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
    marginBottom: 16,
  },
  metricCard: {
    flex: 1,
    minWidth: 150,
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  metricLabel: {
    fontSize: 12,
    fontWeight: '700' as const,
    color: '#94a3b8',
    textTransform: 'uppercase' as const,
    letterSpacing: 0.6,
  },
  metricValue: {
    fontSize: 22,
    fontWeight: '700' as const,
    color: '#0f172a',
    marginTop: 6,
  },
  toggleOriginalButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    flexGrow: 1,
    width: '100%',
    minHeight: 56,
    gap: 8,
    paddingHorizontal: 16,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: '#94a3b8',
    backgroundColor: '#ffffff',
  },
  toggleOriginalButtonActive: {
    borderColor: '#1e3a8a',
    backgroundColor: '#e0e7ff',
  },
  toggleOriginalButtonDisabled: {
    opacity: 0.4,
  },
  toggleOriginalButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#0f172a',
  },
  toggleOriginalButtonTextActive: {
    color: '#1e3a8a',
  },
  toggleOriginalButtonTextDisabled: {
    color: '#94a3b8',
  },
  horizontalScroller: {
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#ffffff',
    marginBottom: 16,
  },
  horizontalScrollerContent: {
    flexGrow: 1,
  },
  dataTable: {
    minWidth: 1160,
  },
  dataHeaderRow: {
    flexDirection: 'row',
    backgroundColor: '#0f172a',
    paddingVertical: 14,
    paddingHorizontal: 20,
  },
  dataHeaderCell: {
    fontSize: 12,
    fontWeight: '700' as const,
    color: '#e2e8f0',
    textTransform: 'uppercase' as const,
    letterSpacing: 0.5,
  },
  groupWrapper: {
    paddingHorizontal: 20,
    paddingTop: 14,
    paddingBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  groupHeaderRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  groupHeaderLeft: {
    flexShrink: 1,
  },
  groupHeaderTextPrimary: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#0f172a',
  },
  groupHeaderTextSecondary: {
    fontSize: 13,
    color: '#475569',
    marginTop: 2,
  },
  groupHeaderInsight: {
    fontSize: 12,
    color: '#64748b',
    marginTop: 4,
  },
  groupMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  groupHours: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#1e3a8a',
  },
  adjustmentPill: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: '#fef3c7',
  },
  adjustmentPillText: {
    fontSize: 12,
    fontWeight: '700' as const,
    color: '#92400e',
    textTransform: 'uppercase' as const,
  },
  dataRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderRadius: 8,
  },
  cell: {
    fontSize: 13,
    color: '#0f172a',
  },
  dateCell: {
    width: 120,
    fontWeight: '600' as const,
  },
  dayCell: {
    width: 120,
    color: '#475569',
  },
  badgeCell: {
    width: 100,
  },
  entryBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
    alignSelf: 'flex-start',
  },
  entryBadgeOriginal: {
    backgroundColor: '#e2e8f0',
  },
  entryBadgeAdjusted: {
    backgroundColor: '#dbeafe',
  },
  entryBadgeText: {
    fontSize: 12,
    fontWeight: '700' as const,
    color: '#0f172a',
  },
  operatorCell: {
    width: 200,
  },
  timeCell: {
    width: 120,
  },
  hoursCell: {
    width: 120,
    fontWeight: '700' as const,
    color: '#16a34a',
  },
  statusCell: {
    width: 100,
    alignItems: 'center',
  },
  statusPlaceholder: {
    fontSize: 16,
    color: '#cbd5f5',
  },
  statusHoliday: {
    fontSize: 18,
  },
  notesCell: {
    width: 200,
    color: '#475569',
  },
  summaryBar: {
    backgroundColor: '#0f172a',
    borderRadius: 16,
    paddingVertical: 14,
    paddingHorizontal: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#e2e8f0',
  },
  summaryValue: {
    fontSize: 22,
    fontWeight: '700' as const,
    color: '#facc15',
  },
  viewTimesheetsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    marginTop: 12,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#eff6ff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#3b82f6',
  },
  viewTimesheetsButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e3a8a',
  },
  ephActions: {
    gap: 8,
    marginTop: 12,
  },
  agreeHoursButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 16,
    backgroundColor: '#10b981',
    borderRadius: 8,
  },
  agreeHoursButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  ephLinkBanner: {
    backgroundColor: '#eff6ff',
    padding: 12,
    marginBottom: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#3b82f6',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  ephLinkText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e3a8a',
  },
  ephLinkBackText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#3b82f6',
    textDecorationLine: 'underline' as const,
  },
  timesheetAttachmentInfo: {
    backgroundColor: '#f0fdf4',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#d1fae5',
  },
  attachmentInfoText: {
    fontSize: 13,
    color: '#15803d',
    textAlign: 'center',
    fontWeight: '500' as const,
  },
  ephCardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingBottom: 12,
    marginBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
    gap: 12,
  },
  checkboxContainer: {
    paddingRight: 8,
  },
  generateButtonsContainer: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 16,
  },
  generateButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  generateButtonPrimary: {
    backgroundColor: '#1e3a8a',
  },
  generateButtonSecondary: {
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#1e3a8a',
  },
  generateButtonDisabled: {
    backgroundColor: '#f1f5f9',
    borderColor: '#e2e8f0',
  },
  generateButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  generateButtonTextSecondary: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e3a8a',
  },
  generateButtonTextDisabled: {
    color: '#94a3b8',
  },
  sendToSubButton: {
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#10b981',
  },
  sendToSubButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#10b981',
  },
  ephHeaderTitleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  pendingEditBadge: {
    backgroundColor: '#fef3c7',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#fbbf24',
  },
  pendingEditBadgeText: {
    fontSize: 10,
    fontWeight: '700' as const,
    color: '#92400e',
    textTransform: 'uppercase' as const,
  },
  ephActionRow: {
    flexDirection: 'row',
    gap: 8,
  },
  editHoursButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#eff6ff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#3b82f6',
  },
  editHoursButtonText: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#3b82f6',
  },
  compareButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#f0fdf4',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#10b981',
  },
  compareButtonText: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#10b981',
  },
  timesheetsMainContainer: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  timesheetsSubTabBar: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
    paddingHorizontal: 16,
  },
  timesheetsSubTab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    gap: 8,
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  timesheetsSubTabActive: {
    borderBottomColor: '#1e3a8a',
  },
  timesheetsSubTabText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  timesheetsSubTabTextActive: {
    color: '#1e3a8a',
  },
  comingSoonContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  comingSoonTitle: {
    fontSize: 24,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginTop: 16,
    marginBottom: 8,
  },
  comingSoonText: {
    fontSize: 15,
    color: '#64748b',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 24,
  },
  comingSoonFeatureList: {
    alignSelf: 'stretch',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    gap: 12,
  },
  comingSoonFeature: {
    fontSize: 14,
    color: '#475569',
    lineHeight: 20,
  },
  configMainContainer: {
    flex: 1,
    backgroundColor: '#f1f5f9',
  },
  configSubTabBar: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
    paddingHorizontal: 16,
  },
  configSubTab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    gap: 8,
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  configSubTabActive: {
    borderBottomColor: '#1e3a8a',
  },
  configSubTabText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  configSubTabTextActive: {
    color: '#1e3a8a',
  },
  globalBillingMethodCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  globalBillingMethodTitle: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  globalBillingMethodSubtitle: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 16,
  },
});


--- END OF FILE: app/billing-config.tsx ---


================================================================================
CATEGORY: Billing Integration
FILE: components/accounts/PlantAssetsTimesheetsTab.tsx
================================================================================

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  ScrollView,
  Platform,
  Alert,
} from 'react-native';
import { Truck, User, FileDown, ChevronDown, ChevronUp, AlertCircle, Calendar, FileText, CheckSquare, Square } from 'lucide-react-native';
import { collection, query, where, getDocs, Timestamp, doc, getDoc } from 'firebase/firestore';
import { useFocusEffect } from 'expo-router';
import { db } from '@/config/firebase';
import { useAuth } from '@/contexts/AuthContext';
import FiltersBar, { FilterValues } from './FiltersBar';
import ExportRequestModal, { ExportRequest, ExportType } from './ExportRequestModal';
import ReportGenerationModal from './ReportGenerationModal';
import { getAgreedTimesheetsByDateRange } from '@/utils/agreedTimesheetManager';
import { generateTimesheetPDF, emailTimesheetPDF, downloadTimesheetPDF } from '@/utils/timesheetPdfGenerator';
import { BillingConfigForCalculation } from '@/utils/billableHoursCalculator';

type ViewMode = 'plant' | 'man';

type VerifiedTimesheet = {
  id: string;
  date: string;
  operatorName: string;
  operatorId: string;
  verified: boolean;
  verifiedAt: string;
  verifiedBy: string;
  masterAccountId: string;
  siteId: string;
  type: 'plant_hours' | 'man_hours';
  actualHours?: number;
  billableHours?: number;
  billingRule?: string;
  assetRate?: number;
  totalCost?: number;
  
  openHours?: number;
  closeHours?: number;
  totalHours?: number;
  isBreakdown?: boolean;
  inclementWeather?: boolean;
  hasAttachment?: boolean;
  
  assetId?: string;
  assetType?: string;
  plantNumber?: string;
  location?: string;
  registrationNumber?: string;
  ownerId?: string;
  ownerType?: string;
  ownerName?: string;
  
  startTime?: string;
  stopTime?: string;
  totalManHours?: number;
  normalHours?: number;
  overtimeHours?: number;
  sundayHours?: number;
  publicHolidayHours?: number;
  noLunchBreak?: boolean;
  
  hasOriginalEntry?: boolean;
  originalEntryData?: any;
  isAdjustment?: boolean;
  originalEntryId?: string;
  adjustedBy?: string;
  adjustedAt?: string;
  
  agreedHours?: number;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  agreedBy?: string;
  agreedAt?: string;
  agreedNotes?: string;
  hasAgreedEntry?: boolean;
  agreedByRole?: 'Admin' | 'Plant Manager' | 'Operator' | 'Subcontractor';
  
  fuelAmount?: number;
  fuelMeterReading?: number;
  fuelMeterType?: 'HOUR_METER' | 'ODOMETER';
  fuelConsumption?: number;
};

type DateGroup = {
  date: string;
  operatorEntry?: VerifiedTimesheet;
  plantManagerEntry?: VerifiedTimesheet;
  adminEntry?: VerifiedTimesheet;
  subcontractorEntry?: VerifiedTimesheet;
};

type TimesheetGroup = {
  key: string;
  title: string;
  subtitle: string;
  entries: VerifiedTimesheet[];
  dateGroups: DateGroup[];
  originalEntry?: VerifiedTimesheet;
  adjustmentEntry?: VerifiedTimesheet;
};

type Props = {
  filters: FilterValues;
  onFiltersChange: (filters: FilterValues) => void;
  onExport: (request: ExportRequest) => Promise<void>;
};

export default function PlantAssetsTimesheetsTab({
  filters,
  onFiltersChange,
  onExport,
}: Props) {
  const { user } = useAuth();
  const [viewMode, setViewMode] = useState<ViewMode>('plant');
  const [exportModalVisible, setExportModalVisible] = useState(false);
  const [exportType, setExportType] = useState<ExportType>('plantHours');
  const [reportModalVisible, setReportModalVisible] = useState(false);
  const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set());
  const [timesheets, setTimesheets] = useState<VerifiedTimesheet[]>([]);
  const [groups, setGroups] = useState<TimesheetGroup[]>([]);
  const [loading, setLoading] = useState(true);
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());
  const [showOriginalTimesheets, setShowOriginalTimesheets] = useState<Set<string>>(new Set());
  const [subcontractors, setSubcontractors] = useState<{ id: string; name: string }[]>([]);
  const [billingConfig, setBillingConfig] = useState<BillingConfigForCalculation | null>(null);
  const [plantAssets, setPlantAssets] = useState<{ id: string; type: string; plantNumber?: string; registrationNumber?: string; assetId: string }[]>([]);
  const [showSelector, setShowSelector] = useState(true);
  const [tempSubcontractor, setTempSubcontractor] = useState<string | null>(null);
  const [tempAsset, setTempAsset] = useState<string | null>(null);
  const [tempStartDate, setTempStartDate] = useState<Date>(() => {
    const date = new Date();
    date.setDate(1);
    return date;
  });
  const [tempEndDate, setTempEndDate] = useState<Date>(new Date());

  useFocusEffect(
    useCallback(() => {
      console.log('[PlantAssetsTimesheetsTab] Tab focused, loading subcontractors');
      if (user?.siteId && user?.masterAccountId) {
        loadSubcontractors();
        loadBillingConfig();
      }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [user?.siteId, user?.masterAccountId])
  );

  useEffect(() => {
    if (tempSubcontractor) {
      loadPlantAssets(tempSubcontractor);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tempSubcontractor]);

  useEffect(() => {
    if (billingConfig !== null || !user?.masterAccountId) {
      loadVerifiedTimesheets();
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.siteId, user?.masterAccountId, viewMode, filters, billingConfig]);

  useEffect(() => {
    groupTimesheets();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [timesheets]);

  const loadSubcontractors = useCallback(async () => {
    if (!user?.siteId || !user?.masterAccountId) return;

    try {
      const subcontractorsRef = collection(db, 'subcontractors');
      const q = query(
        subcontractorsRef,
        where('masterAccountId', '==', user.masterAccountId),
        where('siteId', '==', user.siteId),
        where('status', '==', 'Active')
      );
      const snapshot = await getDocs(q);
      const subs = snapshot.docs.map(doc => ({
        id: doc.id,
        name: doc.data().name || 'Unknown',
      }));
      console.log('[PlantAssetsTimesheetsTab] Loaded subcontractors:', subs.length);
      setSubcontractors(subs);
    } catch (error) {
      console.error('[PlantAssetsTimesheetsTab] Error loading subcontractors:', error);
    }
  }, [user?.siteId, user?.masterAccountId]);

  const loadBillingConfig = useCallback(async () => {
    if (!user?.masterAccountId) return;

    try {
      // Load from same path as billing-config.tsx for consistency
      const configDoc = await getDoc(
        doc(db, 'masterAccounts', user.masterAccountId, 'billingConfig', 'default')
      );
      
      if (configDoc.exists()) {
        const configData = configDoc.data();
        const config: BillingConfigForCalculation = {
          weekdays: {
            minHours: configData.weekdays?.minHours ?? 0,
          },
          saturday: {
            minHours: configData.saturday?.minHours ?? 0,
          },
          sunday: {
            minHours: configData.sunday?.minHours ?? 0,
          },
          publicHolidays: {
            minHours: configData.publicHolidays?.minHours ?? 0,
          },
          rainDays: {
            enabled: configData.rainDays?.enabled ?? true,
            minHours: configData.rainDays?.minHours ?? 0,
          },
          breakdown: {
            enabled: configData.breakdown?.enabled ?? true,
          },
        };
        console.log('[PlantAssetsTimesheetsTab] Loaded billing config from masterAccounts path:', config);
        setBillingConfig(config);
      } else {
        console.log('[PlantAssetsTimesheetsTab] No billing config found at masterAccounts path');
        setBillingConfig(null);
      }
    } catch (error) {
      console.error('[PlantAssetsTimesheetsTab] Error loading billing config:', error);
      setBillingConfig(null);
    }
  }, [user?.masterAccountId]);

  const loadPlantAssets = async (subcontractorId: string) => {
    if (!user?.siteId || !user?.masterAccountId) return;

    try {
      const assetsRef = collection(db, 'plantAssets');
      const q = query(
        assetsRef,
        where('masterAccountId', '==', user.masterAccountId),
        where('siteId', '==', user.siteId),
        where('ownerId', '==', subcontractorId),
        where('ownerType', '==', 'subcontractor')
      );
      const snapshot = await getDocs(q);
      const assets = snapshot.docs.map(doc => ({
        id: doc.id,
        type: doc.data().type || 'Unknown',
        plantNumber: doc.data().plantNumber,
        registrationNumber: doc.data().registrationNumber,
        assetId: doc.data().assetId || doc.id,
      }));
      console.log('[PlantAssetsTimesheetsTab] Loaded plant assets:', assets.length);
      if (assets.length > 0) {
        console.log('[PlantAssetsTimesheetsTab] Sample asset:', JSON.stringify(assets[0], null, 2));
      }
      setPlantAssets(assets);
    } catch (error) {
      console.error('[PlantAssetsTimesheetsTab] Error loading plant assets:', error);
    }
  };

  const loadVerifiedTimesheets = async () => {
    if (!user?.siteId || !user?.masterAccountId) {
      console.log('[PlantAssetsTimesheetsTab] No siteId or masterAccountId');
      setLoading(false);
      return;
    }

    console.log('[PlantAssetsTimesheetsTab] ===== LOADING AGREED TIMESHEETS (APPROVED FOR BILLING) =====');
    console.log('[PlantAssetsTimesheetsTab] masterAccountId:', user.masterAccountId);
    console.log('[PlantAssetsTimesheetsTab] siteId:', user.siteId);
    console.log('[PlantAssetsTimesheetsTab] viewMode:', viewMode);
    console.log('[PlantAssetsTimesheetsTab] filters:', filters);
    setLoading(true);

    try {
      const fromDateStr = filters.fromDate?.toISOString().split('T')[0] || '2020-01-01';
      const toDateStr = filters.toDate?.toISOString().split('T')[0] || '2099-12-31';

      console.log('[PlantAssetsTimesheetsTab] Fetching agreed timesheets from', fromDateStr, 'to', toDateStr);
      
      const getRolePriority = (role?: string): number => {
        if (role === 'Admin' || role === 'admin') return 3;
        if (role === 'Plant Manager') return 2;
        if (role === 'Operator') return 1;
        return 0;
      };

      const deduplicateByAssetAndDate = (timesheets: any[]): any[] => {
        const groupedMap = new Map<string, any[]>();
        
        timesheets.forEach(ts => {
          const key = `${ts.assetId || ts.operatorId}-${ts.date}`;
          if (!groupedMap.has(key)) {
            groupedMap.set(key, []);
          }
          groupedMap.get(key)!.push(ts);
        });
        
        const deduplicated: any[] = [];
        groupedMap.forEach((entries, key) => {
          if (entries.length === 1) {
            deduplicated.push(entries[0]);
          } else {
            entries.sort((a, b) => {
              const priorityA = getRolePriority(a.agreedByRole);
              const priorityB = getRolePriority(b.agreedByRole);
              if (priorityB !== priorityA) return priorityB - priorityA;
              const timeA = a.agreedAt?.toDate?.()?.getTime() || 0;
              const timeB = b.agreedAt?.toDate?.()?.getTime() || 0;
              return timeB - timeA;
            });
            console.log('[PlantAssetsTimesheetsTab] Deduplicating', key, '- keeping entry with role:', entries[0].agreedByRole, 'hours:', entries[0].agreedHours);
            deduplicated.push(entries[0]);
          }
        });
        
        return deduplicated;
      };
      
      const agreedTimesheets = await getAgreedTimesheetsByDateRange(
        user.masterAccountId,
        fromDateStr,
        toDateStr
      );

      console.log('[PlantAssetsTimesheetsTab] Query returned', agreedTimesheets.length, 'agreed timesheets (before deduplication)');
      
      const deduplicatedTimesheets = deduplicateByAssetAndDate(agreedTimesheets);
      console.log('[PlantAssetsTimesheetsTab] After deduplication:', deduplicatedTimesheets.length, 'agreed timesheets');
      
      const uniqueAssetIds = [...new Set(deduplicatedTimesheets.filter(at => at.timesheetType === 'plant_asset').map(at => at.assetId))];
      const ratesMap = new Map<string, { dryRate?: number; wetRate?: number; dailyRate?: number; location?: string }>();
      
      if (uniqueAssetIds.length > 0) {
        console.log('[PlantAssetsTimesheetsTab] Fetching rates for', uniqueAssetIds.length, 'assets');
        const plantAssetsRef = collection(db, 'plantAssets');
        
        // Handle more than 10 assets by batching queries
        const batchSize = 10;
        for (let i = 0; i < uniqueAssetIds.length; i += batchSize) {
          const batch = uniqueAssetIds.slice(i, i + batchSize);
          const plantAssetsQuery = query(
            plantAssetsRef,
            where('masterAccountId', '==', user.masterAccountId),
            where('assetId', 'in', batch)
          );
          const plantAssetsSnapshot = await getDocs(plantAssetsQuery);
          
          plantAssetsSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.assetId) {
              ratesMap.set(data.assetId, {
                dryRate: data.dryRate,
                wetRate: data.wetRate,
                dailyRate: data.dailyRate,
                location: data.location,
              });
            }
          });
        }
        console.log('[PlantAssetsTimesheetsTab] Loaded rates for', ratesMap.size, 'assets');
      }
      
      const fuelLogsMap = new Map<string, any>();
      if (deduplicatedTimesheets.length > 0) {
        const assetIds = [...new Set(deduplicatedTimesheets.filter(at => at.timesheetType === 'plant_asset').map(at => at.assetId))];
        
        if (assetIds.length > 0) {
          console.log('[PlantAssetsTimesheetsTab] Fetching fuel logs for', assetIds.length, 'assets');
          const fuelLogsRef = collection(db, 'fuelLogs');
          const fuelLogsQuery = query(
            fuelLogsRef,
            where('masterAccountId', '==', user.masterAccountId),
            where('assetId', 'in', assetIds.slice(0, 10)),
            where('date', '>=', fromDateStr),
            where('date', '<=', toDateStr)
          );
          const fuelSnapshot = await getDocs(fuelLogsQuery);
          
          fuelSnapshot.forEach(doc => {
            const data = doc.data();
            const key = `${data.assetId}-${data.date}`;
            if (!fuelLogsMap.has(key)) {
              fuelLogsMap.set(key, data);
            }
          });
          console.log('[PlantAssetsTimesheetsTab] Loaded', fuelLogsMap.size, 'fuel logs');
        }
      }
      
      const getActualHoursBasedOnPriority = (agreedTimesheet: any): number => {
        const hours = agreedTimesheet.agreedHours;
        console.log('[PlantAssetsTimesheetsTab] Using agreed hours (actual):', hours, 'for asset:', agreedTimesheet.assetId, 'date:', agreedTimesheet.date);
        return hours ?? 0;
      };
      
      const getBillableHoursFromAgreed = (agreedTimesheet: any): number | undefined => {
        if (agreedTimesheet.billableHours !== undefined && agreedTimesheet.billableHours !== null) {
          console.log('[PlantAssetsTimesheetsTab]  Using STORED billable hours:', agreedTimesheet.billableHours, 'for asset:', agreedTimesheet.assetId, 'date:', agreedTimesheet.date);
          return agreedTimesheet.billableHours;
        }
        console.warn('[PlantAssetsTimesheetsTab]  No billable hours stored in agreedTimesheet for asset:', agreedTimesheet.assetId, 'date:', agreedTimesheet.date);
        return undefined;
      };
      
      let loadedTimesheets: VerifiedTimesheet[] = deduplicatedTimesheets.map(at => {
        const isPlant = at.timesheetType === 'plant_asset';
        const hasAdjustment = at.originalHours !== at.agreedHours;
        
        const fuelLogKey = `${at.assetId}-${at.date}`;
        const fuelLog = fuelLogsMap.get(fuelLogKey);
        
        let fuelConsumption: number | undefined;
        if (fuelLog && isPlant && at.agreedHours > 0) {
          if (fuelLog.meterType === 'HOUR_METER') {
            fuelConsumption = fuelLog.fuelAmount / at.agreedHours;
          } else {
            fuelConsumption = fuelLog.fuelAmount / (fuelLog.meterReading || 1);
          }
        }
        
        let billableHours: number | undefined;
        let billingRule: string | undefined;
        let assetRate: number | undefined;
        let totalCost: number | undefined;
        let location: string | undefined;
        
        const actualHours = getActualHoursBasedOnPriority(at);
        
        if (isPlant) {
          console.log('[PlantAssetsTimesheetsTab] ===== READING BILLABLE HOURS FROM AGREED TIMESHEET (NOT RECALCULATING) =====');
          billableHours = getBillableHoursFromAgreed(at);
          billingRule = at.billingRule;
          
          if (at.assetId) {
            const rates = ratesMap.get(at.assetId);
            if (rates) {
              assetRate = rates.dryRate || rates.wetRate || rates.dailyRate;
              location = rates.location;
              if (assetRate && billableHours !== undefined) {
                totalCost = billableHours * assetRate;
              }
            }
          }
          
          console.log('[PlantAssetsTimesheetsTab] Asset:', at.assetId, 'Date:', at.date);
          console.log('[PlantAssetsTimesheetsTab] Actual Hours:', actualHours);
          console.log('[PlantAssetsTimesheetsTab] Billable Hours (stored):', billableHours);
          console.log('[PlantAssetsTimesheetsTab] Billing Rule:', billingRule);
          console.log('[PlantAssetsTimesheetsTab] Rate:', assetRate);
          console.log('[PlantAssetsTimesheetsTab] Total Cost:', totalCost);
        }
        
        const baseEntry: VerifiedTimesheet = {
          id: at.id,
          date: at.date,
          operatorName: at.operatorName || '',
          operatorId: at.operatorId || '',
          verified: true,
          verifiedAt: at.agreedAt ? (at.agreedAt as Timestamp).toDate().toISOString() : new Date().toISOString(),
          verifiedBy: at.agreedBy,
          masterAccountId: at.masterAccountId,
          siteId: at.siteId || '',
          type: isPlant ? 'plant_hours' : 'man_hours',
          
          actualHours: getActualHoursBasedOnPriority(at),
          billableHours,
          billingRule,
          assetRate,
          totalCost,
          
          // Use agreed hours directly - NOT calculated from meter readings
          totalHours: isPlant ? getActualHoursBasedOnPriority(at) : undefined,
          // Convert meter readings to numbers - Firestore may store as strings
          // Use originalOpenHours/originalCloseHours from agreedTimesheet (stored when approved)
          // CRITICAL: Add fallbacks so PDF can calculate Actual from meters (close - open)
          // If no meter data stored, use 0 for open and originalHours for close
          openHours: isPlant ? (at.originalOpenHours != null ? Number(at.originalOpenHours) : 0) : undefined,
          closeHours: isPlant ? (at.originalCloseHours != null ? Number(at.originalCloseHours) : (at.originalHours ?? at.agreedHours ?? 0)) : undefined,
          
          assetId: at.assetId,
          assetType: at.assetType,
          plantNumber: at.assetId,
          location: location,
          registrationNumber: undefined,
          ownerId: at.subcontractorId,
          ownerType: 'subcontractor',
          ownerName: at.subcontractorName,
          
          totalManHours: !isPlant ? getActualHoursBasedOnPriority(at) : undefined,
          normalHours: at.agreedNormalHours,
          overtimeHours: at.agreedOvertimeHours,
          sundayHours: at.agreedSundayHours,
          publicHolidayHours: at.agreedPublicHolidayHours,
          
          agreedHours: at.agreedHours,
          agreedNormalHours: at.agreedNormalHours,
          agreedOvertimeHours: at.agreedOvertimeHours,
          agreedSundayHours: at.agreedSundayHours,
          agreedPublicHolidayHours: at.agreedPublicHolidayHours,
          agreedBy: at.agreedBy,
          agreedAt: at.agreedAt ? (at.agreedAt as Timestamp).toDate().toISOString() : undefined,
          agreedNotes: at.adminNotes,
          hasAgreedEntry: true,
          agreedByRole: at.agreedByRole as 'Admin' | 'Plant Manager' | 'Operator' | 'Subcontractor',
          
          fuelAmount: fuelLog?.fuelAmount,
          fuelMeterReading: fuelLog?.meterReading,
          fuelMeterType: fuelLog?.meterType,
          fuelConsumption,
        };
        
        if (hasAdjustment) {
          const originalEntry: VerifiedTimesheet = {
            ...baseEntry,
            id: `${at.id}-original`,
            // For original entry, show original hours (before adjustment)
            actualHours: at.originalHours,
            totalHours: isPlant ? at.originalHours : undefined,
            closeHours: isPlant ? (at.originalCloseHours ?? at.originalHours) : undefined,
            openHours: isPlant ? (at.originalOpenHours ?? 0) : undefined,
            totalManHours: !isPlant ? at.originalHours : undefined,
            normalHours: at.originalNormalHours,
            overtimeHours: at.originalOvertimeHours,
            sundayHours: at.originalSundayHours,
            publicHolidayHours: at.originalPublicHolidayHours,
            billableHours: undefined, // Original entry doesn't have billing calc
            agreedHours: undefined,
            agreedNormalHours: undefined,
            agreedOvertimeHours: undefined,
            agreedSundayHours: undefined,
            agreedPublicHolidayHours: undefined,
            agreedNotes: undefined,
            hasAgreedEntry: false,
          };
          
          baseEntry.hasOriginalEntry = true;
          baseEntry.originalEntryData = originalEntry;
          
          console.log('[PlantAssetsTimesheetsTab] Adjustment entry - Original hours:', at.originalHours, 'Agreed hours:', at.agreedHours);
        }
        
        return baseEntry;
      });

      loadedTimesheets.sort((a, b) => {
        const timeA = new Date(a.verifiedAt).getTime();
        const timeB = new Date(b.verifiedAt).getTime();
        return timeB - timeA;
      });

      console.log('[PlantAssetsTimesheetsTab] Before filtering:', loadedTimesheets.length, 'timesheets');

      if (viewMode === 'plant') {
        loadedTimesheets = loadedTimesheets.filter(t => t.type === 'plant_hours');
      } else {
        loadedTimesheets = loadedTimesheets.filter(t => t.type === 'man_hours');
      }
      console.log('[PlantAssetsTimesheetsTab] After type filter:', loadedTimesheets.length, 'timesheets');

      if (filters.assetId) {
        console.log('[PlantAssetsTimesheetsTab] Filtering by assetId:', filters.assetId);
        loadedTimesheets = loadedTimesheets.filter(t => t.assetId === filters.assetId);
        console.log('[PlantAssetsTimesheetsTab] After asset filter:', loadedTimesheets.length, 'timesheets');
      }

      if (filters.subcontractorId) {
        console.log('[PlantAssetsTimesheetsTab] Filtering by subcontractorId:', filters.subcontractorId);
        loadedTimesheets = loadedTimesheets.filter(t => t.ownerId === filters.subcontractorId);
        console.log('[PlantAssetsTimesheetsTab] After subcontractor filter:', loadedTimesheets.length, 'timesheets');
      }

      if (filters.siteId) {
        console.log('[PlantAssetsTimesheetsTab] Filtering by siteId:', filters.siteId);
        loadedTimesheets = loadedTimesheets.filter(t => t.siteId === filters.siteId);
        console.log('[PlantAssetsTimesheetsTab] After siteId filter:', loadedTimesheets.length, 'timesheets');
      }

      console.log('[PlantAssetsTimesheetsTab] Final filtered count:', loadedTimesheets.length, 'timesheets');
      
      const adjustedTimesheetIds = new Set(
        loadedTimesheets
          .filter(t => t.originalEntryId)
          .map(t => t.originalEntryId)
      );
      console.log('[PlantAssetsTimesheetsTab] Found', adjustedTimesheetIds.size, 'superseded original timesheets to exclude');
      
      const finalTimesheets = loadedTimesheets.filter(t => !adjustedTimesheetIds.has(t.id));
      console.log('[PlantAssetsTimesheetsTab] After removing superseded originals:', finalTimesheets.length, 'timesheets');
      
      if (finalTimesheets.length > 0) {
        console.log('[PlantAssetsTimesheetsTab] First timesheet sample:', JSON.stringify(finalTimesheets[0], null, 2));
      }
      
      setTimesheets(finalTimesheets);
    } catch (error) {
      console.error('[PlantAssetsTimesheetsTab]  Error loading agreed timesheets:', error);
      console.error('[PlantAssetsTimesheetsTab] Error details:', JSON.stringify(error, null, 2));
      setTimesheets([]);
    } finally {
      setLoading(false);
    }
  };

  const groupTimesheets = () => {
    const groupMap = new Map<string, TimesheetGroup>();

    timesheets.forEach(timesheet => {
      let key: string;
      let title: string;
      let subtitle: string;

      if (viewMode === 'plant') {
        key = `${timesheet.assetId || timesheet.plantNumber}`;
        title = `${timesheet.assetType || 'Unknown Asset'}`;
        subtitle = timesheet.plantNumber || timesheet.registrationNumber || timesheet.assetId || 'N/A';
      } else {
        key = timesheet.operatorId || timesheet.operatorName;
        title = timesheet.operatorName;
        subtitle = `Operator ID: ${timesheet.operatorId || 'N/A'}`;
      }

      if (!groupMap.has(key)) {
        groupMap.set(key, {
          key,
          title,
          subtitle,
          entries: [],
          dateGroups: [],
        });
      }

      const group = groupMap.get(key)!;
      group.entries.push(timesheet);
    });

    groupMap.forEach(group => {
      const dateMap = new Map<string, DateGroup>();
      
      group.entries.forEach(entry => {
        if (!dateMap.has(entry.date)) {
          dateMap.set(entry.date, {
            date: entry.date,
          });
        }
        
        const dateGroup = dateMap.get(entry.date)!;
        
        const role = entry.agreedByRole;
        if (role === 'Admin') {
          if (!dateGroup.adminEntry) {
            dateGroup.adminEntry = entry;
          }
        } else if (role === 'Plant Manager') {
          if (!dateGroup.plantManagerEntry) {
            dateGroup.plantManagerEntry = entry;
          }
        } else if (role === 'Operator') {
          if (!dateGroup.operatorEntry) {
            dateGroup.operatorEntry = entry;
          }
        } else if (role === 'Subcontractor') {
          if (!dateGroup.subcontractorEntry) {
            dateGroup.subcontractorEntry = entry;
          }
        } else {
          if (!dateGroup.operatorEntry) {
            dateGroup.operatorEntry = entry;
          }
        }
      });
      
      group.dateGroups = Array.from(dateMap.values()).sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      );
    });

    setGroups(Array.from(groupMap.values()));
  };

  const toggleGroupExpansion = (key: string) => {
    setExpandedGroups(prev => {
      const newSet = new Set(prev);
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
      }
      return newSet;
    });
  };

  const toggleShowOriginals = (key: string) => {
    setShowOriginalTimesheets(prev => {
      const newSet = new Set(prev);
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
      }
      return newSet;
    });
  };

  const handleExport = () => {
    setExportType(viewMode === 'plant' ? 'plantHours' : 'workerTimesheets');
    setExportModalVisible(true);
  };

  const handleGenerateReport = () => {
    setReportModalVisible(true);
  };

  const handleReportGenerate = async (options: {
    scope: 'all' | 'selected';
    deliveryMethod: 'download' | 'email';
    recipientEmail?: string;
  }) => {
    console.log('[PlantAssetsTimesheetsTab] ===== GENERATING REPORT =====');
    console.log('[PlantAssetsTimesheetsTab] Options:', JSON.stringify(options));
    console.log('[PlantAssetsTimesheetsTab] Total groups:', groups.length);
    console.log('[PlantAssetsTimesheetsTab] Selected groups size:', selectedGroups.size);
    console.log('[PlantAssetsTimesheetsTab] Selected groups:', Array.from(selectedGroups));
    console.log('[PlantAssetsTimesheetsTab] View mode:', viewMode);
    console.log('[PlantAssetsTimesheetsTab] Groups data:', JSON.stringify(groups.slice(0, 2), null, 2));

    try {
      const subcontractorName = filters.subcontractorId 
        ? subcontractors.find(s => s.id === filters.subcontractorId)?.name
        : undefined;

      console.log('[PlantAssetsTimesheetsTab] Subcontractor name:', subcontractorName);
      console.log('[PlantAssetsTimesheetsTab] Calling generateTimesheetPDF...');

      const { uri, fileName } = await generateTimesheetPDF({
        groups,
        reportType: viewMode,
        subcontractorName,
        dateRange: {
          from: filters.fromDate || new Date(new Date().setDate(1)),
          to: filters.toDate || new Date(),
        },
        selectedOnly: options.scope === 'selected',
        selectedGroups: options.scope === 'selected' ? selectedGroups : undefined,
      });

      console.log('[PlantAssetsTimesheetsTab] PDF generated successfully:');
      console.log('[PlantAssetsTimesheetsTab] URI:', uri);
      console.log('[PlantAssetsTimesheetsTab] Filename:', fileName);

      if (options.deliveryMethod === 'email') {
        console.log('[PlantAssetsTimesheetsTab] Opening email composer...');
        await emailTimesheetPDF(uri, fileName, {
          recipientEmail: options.recipientEmail,
        });
      } else {
        console.log('[PlantAssetsTimesheetsTab] Downloading/sharing report...');
        await downloadTimesheetPDF(uri, fileName);
      }

      console.log('[PlantAssetsTimesheetsTab] ===== REPORT GENERATION COMPLETE =====');
    } catch (error) {
      console.error('[PlantAssetsTimesheetsTab]  Error generating report:', error);
      console.error('[PlantAssetsTimesheetsTab] Error details:', JSON.stringify(error, null, 2));
      Alert.alert(
        'Error',
        `Failed to generate report: ${error instanceof Error ? error.message : 'Unknown error'}. Check console for details.`
      );
      throw error;
    }
  };

  const renderTimesheetRow = (timesheet: VerifiedTimesheet, isOriginal: boolean = false, rowBg: string) => {
    const getLabelAndColor = (role?: 'Admin' | 'Plant Manager' | 'Operator' | 'Subcontractor') => {
      switch (role) {
        case 'Admin':
          return { label: 'ADMIN', color: '#dc2626' };
        case 'Plant Manager':
          return { label: 'PM', color: '#3b82f6' };
        case 'Subcontractor':
          return { label: 'SUB', color: '#7c3aed' };
        case 'Operator':
        default:
          return { label: 'ORIG', color: '#64748b' };
      }
    };
    
    const { label: rowLabel, color: rowLabelColor } = getLabelAndColor(timesheet.agreedByRole);
    
    if (viewMode === 'plant') {
      return (
        <View style={[styles.timesheetRow, { backgroundColor: rowBg }]}>
          <View style={styles.dateCell}>
            <Text style={styles.cellText}>{new Date(timesheet.date).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: '2-digit' })}</Text>
            <View style={[styles.rowBadge, { backgroundColor: rowLabelColor }]}>
              <Text style={styles.rowBadgeText}>{rowLabel}</Text>
            </View>
          </View>
          <Text style={[styles.operatorCell, styles.cellText]} numberOfLines={2}>{timesheet.operatorName}</Text>
          <Text style={[styles.hoursCell, styles.cellText]}>{timesheet.openHours}</Text>
          <Text style={[styles.hoursCell, styles.cellText]}>{timesheet.closeHours}</Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.actualHours?.toFixed(1)}h
          </Text>
          <Text style={[styles.hoursCell, styles.cellText, styles.boldText, { color: '#10b981' }]}>
            {timesheet.billableHours?.toFixed(1)}h
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.assetRate ? `R${timesheet.assetRate.toFixed(2)}` : '-'}
          </Text>
          <Text style={[styles.hoursCell, styles.cellText, styles.boldText, { color: '#1e3a8a' }]}>
            {timesheet.totalCost ? `R${timesheet.totalCost.toFixed(2)}` : '-'}
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.fuelAmount ? timesheet.fuelAmount.toFixed(1) : '-'}
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.fuelMeterReading ? `${timesheet.fuelMeterReading.toFixed(0)}${timesheet.fuelMeterType === 'HOUR_METER' ? 'h' : 'km'}` : '-'}
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.fuelConsumption ? timesheet.fuelConsumption.toFixed(2) : '-'}
          </Text>
          <Text style={[styles.verifiedCell, styles.cellText, styles.smallText]}>
            {new Date(timesheet.verifiedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' })}
          </Text>
        </View>
      );
    } else {
      return (
        <View style={[styles.timesheetRow, { backgroundColor: rowBg }]}>
          <View style={styles.dateCell}>
            <Text style={styles.cellText}>{new Date(timesheet.date).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: '2-digit' })}</Text>
            <View style={[styles.rowBadge, { backgroundColor: rowLabelColor }]}>
              <Text style={styles.rowBadgeText}>{rowLabel}</Text>
            </View>
          </View>
          <Text style={[styles.timeCell, styles.cellText]}>{timesheet.startTime}</Text>
          <Text style={[styles.timeCell, styles.cellText]}>{timesheet.stopTime}</Text>
          <Text style={[styles.hoursCell, styles.cellText, styles.boldText]}>
            {timesheet.totalManHours?.toFixed(1)}h
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.normalHours?.toFixed(1)}h
          </Text>
          <Text style={[styles.hoursCell, styles.cellText]}>
            {timesheet.overtimeHours?.toFixed(1)}h
          </Text>
          <Text style={[styles.verifiedCell, styles.cellText, styles.smallText]}>
            {new Date(timesheet.verifiedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short' })}
          </Text>
        </View>
      );
    }
  };

  const toggleGroupSelection = (key: string) => {
    setSelectedGroups(prev => {
      const newSet = new Set(prev);
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
      }
      return newSet;
    });
  };

  const renderGroup = ({ item }: { item: TimesheetGroup }) => {
    const isExpanded = expandedGroups.has(item.key);
    const showOriginals = showOriginalTimesheets.has(item.key);
    const hasAdjustments = item.dateGroups.some(dg => 
      (dg.operatorEntry && (dg.plantManagerEntry || dg.adminEntry || dg.subcontractorEntry)) ||
      (dg.plantManagerEntry && (dg.adminEntry || dg.subcontractorEntry)) ||
      (dg.adminEntry && dg.subcontractorEntry)
    );
    const isSelected = selectedGroups.has(item.key);
    
    const getHighestPriorityEntry = (dateGroup: DateGroup): VerifiedTimesheet | undefined => {
      if (dateGroup.adminEntry) return dateGroup.adminEntry;
      if (dateGroup.plantManagerEntry) return dateGroup.plantManagerEntry;
      if (dateGroup.operatorEntry) return dateGroup.operatorEntry;
      return undefined;
    };

    const totals = item.dateGroups.reduce((acc, dateGroup) => {
      const entry = getHighestPriorityEntry(dateGroup);
      if (entry && viewMode === 'plant') {
        return {
          actualHours: acc.actualHours + (entry.actualHours || 0),
          billableHours: acc.billableHours + (entry.billableHours || 0),
          totalCost: acc.totalCost + (entry.totalCost || 0),
        };
      }
      return acc;
    }, { actualHours: 0, billableHours: 0, totalCost: 0 });

    return (
      <View style={styles.groupCard}>
        <View style={styles.groupHeader}>
          <TouchableOpacity
            style={styles.checkboxContainer}
            onPress={() => toggleGroupSelection(item.key)}
            activeOpacity={0.7}
          >
            {isSelected ? (
              <CheckSquare size={24} color="#10b981" />
            ) : (
              <Square size={24} color="#94a3b8" />
            )}
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.groupHeaderContent}
            onPress={() => toggleGroupExpansion(item.key)}
            activeOpacity={0.7}
          >
            <Text style={styles.groupTitle}>{item.title}</Text>
            <Text style={styles.groupSubtitle}>{item.subtitle}</Text>
            <View style={styles.groupMeta}>
              <Text style={styles.groupMetaText}>
                {item.dateGroups.length} days
              </Text>
              {hasAdjustments && (
                <View style={styles.adjustmentIndicator}>
                  <AlertCircle size={14} color="#f59e0b" />
                  <Text style={styles.adjustmentText}>Has Adjustments</Text>
                </View>
              )}
            </View>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.expandButton}
            onPress={() => toggleGroupExpansion(item.key)}
            activeOpacity={0.7}
          >
            {isExpanded ? (
              <ChevronUp size={24} color="#64748b" />
            ) : (
              <ChevronDown size={24} color="#64748b" />
            )}
          </TouchableOpacity>
        </View>

        {isExpanded && (
          <View style={styles.groupContent}>
            {hasAdjustments && (
              <TouchableOpacity
                style={styles.showOriginalsButton}
                onPress={() => toggleShowOriginals(item.key)}
              >
                {showOriginals ? (
                  <ChevronUp size={18} color="#3b82f6" />
                ) : (
                  <ChevronDown size={18} color="#3b82f6" />
                )}
                <Text style={styles.showOriginalsText}>
                  {showOriginals ? 'Hide' : 'Show'} Original Operator Entries
                </Text>
              </TouchableOpacity>
            )}
            
            <ScrollView horizontal showsHorizontalScrollIndicator={true} persistentScrollbar={true}>
              <View>
                <View style={styles.tableHeader}>
                  <Text style={styles.dateHeaderCell}>Date</Text>
                  {viewMode === 'plant' ? (
                    <>
                      <Text style={styles.operatorHeaderCell}>Operator</Text>
                      <Text style={styles.hoursHeaderCell}>Open</Text>
                      <Text style={styles.hoursHeaderCell}>Close</Text>
                      <Text style={styles.hoursHeaderCell}>Actual</Text>
                      <Text style={styles.hoursHeaderCell}>Billable</Text>
                      <Text style={styles.hoursHeaderCell}>Rate</Text>
                      <Text style={styles.hoursHeaderCell}>Cost</Text>
                      <Text style={styles.hoursHeaderCell}>Fuel (L)</Text>
                      <Text style={styles.hoursHeaderCell}>Meter</Text>
                      <Text style={styles.hoursHeaderCell}>L/h</Text>
                    </>
                  ) : (
                    <>
                      <Text style={styles.timeHeaderCell}>Start</Text>
                      <Text style={styles.timeHeaderCell}>Stop</Text>
                      <Text style={styles.hoursHeaderCell}>Total</Text>
                      <Text style={styles.hoursHeaderCell}>Normal</Text>
                      <Text style={styles.hoursHeaderCell}>Overtime</Text>
                    </>
                  )}
                  <Text style={styles.verifiedHeaderCell}>Verified</Text>
                </View>

                {item.dateGroups.map((dateGroup, index) => {
                  const rowBg = index % 2 === 0 ? '#f8fafc' : '#ffffff';
                  const hasMultiple = [
                    dateGroup.operatorEntry,
                    dateGroup.plantManagerEntry,
                    dateGroup.adminEntry,
                    dateGroup.subcontractorEntry
                  ].filter(Boolean).length > 1;
                  
                  return (
                    <View key={dateGroup.date}>
                      {showOriginals && hasMultiple && dateGroup.operatorEntry && (
                        renderTimesheetRow(dateGroup.operatorEntry, true, rowBg)
                      )}
                      {showOriginals && hasMultiple && dateGroup.plantManagerEntry && (
                        renderTimesheetRow(dateGroup.plantManagerEntry, false, rowBg)
                      )}
                      {showOriginals && hasMultiple && dateGroup.adminEntry && (
                        renderTimesheetRow(dateGroup.adminEntry, false, rowBg)
                      )}
                      {showOriginals && hasMultiple && dateGroup.subcontractorEntry && (
                        renderTimesheetRow(dateGroup.subcontractorEntry, false, rowBg)
                      )}
                      {!showOriginals && getHighestPriorityEntry(dateGroup) && (
                        renderTimesheetRow(getHighestPriorityEntry(dateGroup)!, false, rowBg)
                      )}
                    </View>
                  );
                })}
                
                {viewMode === 'plant' && (
                  <View style={[styles.timesheetRow, styles.summaryRow]}>
                    <View style={styles.dateCell}>
                      <Text style={[styles.cellText, styles.boldText]}>TOTALS</Text>
                    </View>
                    <Text style={[styles.operatorCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText, styles.boldText]}>
                      {totals.actualHours.toFixed(1)}h
                    </Text>
                    <Text style={[styles.hoursCell, styles.cellText, styles.boldText, { color: '#10b981' }]}>
                      {totals.billableHours.toFixed(1)}h
                    </Text>
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText, styles.boldText, { color: '#1e3a8a' }]}>
                      {totals.totalCost > 0 ? `R${totals.totalCost.toFixed(2)}` : '-'}
                    </Text>
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.hoursCell, styles.cellText]} />
                    <Text style={[styles.verifiedCell, styles.cellText]} />
                  </View>
                )}
              </View>
            </ScrollView>
          </View>
        )}
      </View>
    );
  };

  const handleApplyFilters = () => {
    onFiltersChange({
      ...filters,
      subcontractorId: tempSubcontractor || undefined,
      assetId: tempAsset || undefined,
      fromDate: tempStartDate,
      toDate: tempEndDate,
    });
    setShowSelector(false);
  };

  const handleClearSelection = () => {
    setTempSubcontractor(null);
    setTempAsset(null);
    setPlantAssets([]);
    onFiltersChange({});
    setShowSelector(true);
  };

  const formatDate = (date: Date): string => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };

  const handleDateChange = (type: 'start' | 'end', dateString: string) => {
    const date = new Date(dateString);
    if (type === 'start') {
      setTempStartDate(date);
    } else {
      setTempEndDate(date);
    }
  };

  if (showSelector) {
    return (
      <View style={styles.container}>
        <ScrollView style={styles.selectorContainer}>
          <View style={styles.selectorSection}>
            <Text style={styles.selectorLabel}>Select Subcontractor:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.subList}>
              {subcontractors.map(sub => (
                <TouchableOpacity
                  key={sub.id}
                  style={[
                    styles.subButton,
                    tempSubcontractor === sub.id && styles.subButtonActive,
                  ]}
                  onPress={() => setTempSubcontractor(sub.id)}
                >
                  <Text
                    style={[
                      styles.subButtonText,
                      tempSubcontractor === sub.id && styles.subButtonTextActive,
                    ]}
                  >
                    {sub.name}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>

          {tempSubcontractor && (
            <View style={styles.selectorSection}>
              <View style={styles.dateRangeContainer}>
                <View style={styles.dateRangeHeader}>
                  <Calendar size={20} color="#1e3a8a" />
                  <Text style={styles.dateRangeTitle}>Date Range</Text>
                </View>
                
                <View style={styles.datePickersRow}>
                  <View style={styles.datePickerBlock}>
                    <Text style={styles.datePickerLabel}>Start Date</Text>
                    {Platform.OS === 'web' ? (
                      <input
                        type="date"
                        value={tempStartDate.toISOString().split('T')[0]}
                        onChange={(e: any) => handleDateChange('start', e.target.value)}
                        style={{
                          height: 48,
                          borderWidth: 1,
                          borderColor: '#e2e8f0',
                          borderRadius: 8,
                          paddingLeft: 12,
                          paddingRight: 12,
                          fontSize: 15,
                          color: '#1e293b',
                          backgroundColor: '#ffffff',
                          fontFamily: 'system-ui',
                        }}
                      />
                    ) : (
                      <TouchableOpacity style={styles.dateButton}>
                        <Calendar size={18} color="#64748b" />
                        <Text style={styles.dateButtonText}>{formatDate(tempStartDate)}</Text>
                      </TouchableOpacity>
                    )}
                  </View>

                  <View style={styles.datePickerBlock}>
                    <Text style={styles.datePickerLabel}>End Date</Text>
                    {Platform.OS === 'web' ? (
                      <input
                        type="date"
                        value={tempEndDate.toISOString().split('T')[0]}
                        onChange={(e: any) => handleDateChange('end', e.target.value)}
                        style={{
                          height: 48,
                          borderWidth: 1,
                          borderColor: '#e2e8f0',
                          borderRadius: 8,
                          paddingLeft: 12,
                          paddingRight: 12,
                          fontSize: 15,
                          color: '#1e293b',
                          backgroundColor: '#ffffff',
                          fontFamily: 'system-ui',
                        }}
                      />
                    ) : (
                      <TouchableOpacity style={styles.dateButton}>
                        <Calendar size={18} color="#64748b" />
                        <Text style={styles.dateButtonText}>{formatDate(tempEndDate)}</Text>
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>

              <Text style={styles.selectorLabel}>Select Plant Asset:</Text>
              {plantAssets.length > 0 ? (
                <FlatList
                  data={plantAssets}
                  keyExtractor={(item) => item.id}
                  renderItem={({ item }) => (
                    <TouchableOpacity
                      style={[
                        styles.assetCard,
                        tempAsset === item.assetId && styles.assetCardActive,
                      ]}
                      onPress={() => setTempAsset(item.assetId)}
                    >
                      <View style={styles.assetCardContent}>
                        <Text style={styles.assetType}>{item.type}</Text>
                        <Text style={styles.assetNumber}>
                          {item.plantNumber || item.registrationNumber || item.assetId}
                        </Text>
                      </View>
                      {tempAsset === item.assetId && (
                        <View style={styles.selectedBadge}>
                          <Text style={styles.selectedBadgeText}></Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                  scrollEnabled={false}
                />
              ) : (
                <View style={styles.emptyAssets}>
                  <Text style={styles.emptyText}>No plant assets found for this subcontractor</Text>
                </View>
              )}

              {tempAsset && (
                <TouchableOpacity
                  style={styles.applyButton}
                  onPress={handleApplyFilters}
                >
                  <Text style={styles.applyButtonText}>View Timesheets</Text>
                </TouchableOpacity>
              )}
            </View>
          )}
        </ScrollView>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity
        style={styles.backToSelectorButton}
        onPress={handleClearSelection}
      >
        <ChevronDown size={24} color="#1e3a8a" style={{ transform: [{ rotate: '90deg' }] }} />
        <Text style={styles.backToSelectorText}>Back to Assets</Text>
      </TouchableOpacity>
      <FiltersBar
        filters={filters}
        onFiltersChange={onFiltersChange}
        subcontractors={subcontractors}
        showAssetFilters
      />

      {selectedGroups.size > 0 && (
        <View style={styles.selectionBanner}>
          <CheckSquare size={18} color="#10b981" />
          <Text style={styles.selectionBannerText}>
            {selectedGroups.size} {viewMode === 'plant' ? 'asset' : 'operator'}{selectedGroups.size > 1 ? 's' : ''} selected
          </Text>
          <TouchableOpacity 
            onPress={() => setSelectedGroups(new Set())}
            style={styles.clearSelectionButton}
          >
            <Text style={styles.clearSelectionText}>Clear</Text>
          </TouchableOpacity>
        </View>
      )}
      
      <View style={styles.controls}>
        <View style={styles.viewModeToggle}>
          <TouchableOpacity
            style={[styles.toggleButton, viewMode === 'plant' && styles.toggleButtonActive]}
            onPress={() => setViewMode('plant')}
            testID="view-plant"
          >
            <Truck size={18} color={viewMode === 'plant' ? '#3b82f6' : '#64748b'} />
            <Text
              style={[
                styles.toggleButtonText,
                viewMode === 'plant' && styles.toggleButtonTextActive,
              ]}
            >
              Plant Hours ({groups.length})
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.toggleButton, viewMode === 'man' && styles.toggleButtonActive]}
            onPress={() => setViewMode('man')}
            testID="view-man"
          >
            <User size={18} color={viewMode === 'man' ? '#10b981' : '#64748b'} />
            <Text
              style={[
                styles.toggleButtonText,
                viewMode === 'man' && styles.toggleButtonTextActive,
              ]}
            >
              Man Hours ({groups.length})
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.buttonsContainer}>
          <TouchableOpacity
            style={styles.generateReportButton}
            onPress={handleGenerateReport}
            testID="generate-report-button"
          >
            <FileText size={18} color="#ffffff" />
            <Text style={styles.generateReportButtonText}>Generate Report</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.exportButton}
            onPress={handleExport}
            testID="export-button"
          >
            <FileDown size={18} color="#ffffff" />
            <Text style={styles.exportButtonText}>Export</Text>
          </TouchableOpacity>
        </View>
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#3b82f6" />
          <Text style={styles.loadingText}>Loading approved billing timesheets...</Text>
        </View>
      ) : groups.length === 0 ? (
        <View style={styles.emptyState}>
          {viewMode === 'plant' ? (
            <Truck size={48} color="#cbd5e1" />
          ) : (
            <User size={48} color="#cbd5e1" />
          )}
          <Text style={styles.emptyTitle}>No approved timesheets for billing</Text>
          <Text style={styles.emptyText}>
            {viewMode === 'plant'
              ? 'No plant hours timesheets have been approved from EPH yet'
              : 'No man hours timesheets have been approved from EPH yet'}
          </Text>
        </View>
      ) : (
        <FlatList
          data={groups}
          keyExtractor={(item) => item.key}
          renderItem={renderGroup}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
        />
      )}

      <ExportRequestModal
        visible={exportModalVisible}
        onClose={() => setExportModalVisible(false)}
        onSubmit={onExport}
        exportType={exportType}
        prefilledFilters={filters}
      />

      <ReportGenerationModal
        visible={reportModalVisible}
        onClose={() => setReportModalVisible(false)}
        onGenerate={handleReportGenerate}
        hasSelection={selectedGroups.size > 0}
        selectedCount={selectedGroups.size}
        totalCount={groups.length}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  controls: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  viewModeToggle: {
    flexDirection: 'row',
    gap: 8,
    flex: 1,
  },
  toggleButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 8,
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e5e7eb',
  },
  toggleButtonActive: {
    backgroundColor: '#eff6ff',
    borderColor: '#3b82f6',
  },
  toggleButtonText: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#64748b',
  },
  toggleButtonTextActive: {
    color: '#3b82f6',
    fontWeight: '600' as const,
  },
  buttonsContainer: {
    flexDirection: 'row',
    gap: 8,
    marginLeft: 12,
  },
  generateReportButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#10b981',
    borderRadius: 8,
  },
  generateReportButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  exportButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#1e3a8a',
    borderRadius: 8,
  },
  exportButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#64748b',
  },
  listContent: {
    padding: 16,
  },
  groupCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    overflow: 'hidden',
  },
  groupHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    gap: 12,
  },
  checkboxContainer: {
    padding: 4,
  },
  groupHeaderContent: {
    flex: 1,
  },
  expandButton: {
    padding: 4,
  },
  groupTitle: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  groupSubtitle: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 8,
  },
  groupMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  groupMetaText: {
    fontSize: 12,
    color: '#64748b',
  },
  adjustmentIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  adjustmentText: {
    fontSize: 11,
    fontWeight: '600' as const,
    color: '#f59e0b',
  },
  groupContent: {
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
    padding: 12,
  },
  tableHeader: {
    flexDirection: 'row',
    backgroundColor: '#1e3a8a',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderBottomWidth: 2,
    borderBottomColor: '#e5e7eb',
  },
  dateHeaderCell: {
    width: 120,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    textTransform: 'uppercase' as const,
  },
  operatorHeaderCell: {
    width: 160,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    textTransform: 'uppercase' as const,
  },
  hoursHeaderCell: {
    width: 100,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    textTransform: 'uppercase' as const,
  },
  timeHeaderCell: {
    width: 120,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    textTransform: 'uppercase' as const,
  },
  verifiedHeaderCell: {
    width: 120,
    fontSize: 11,
    fontWeight: '700' as const,
    color: '#ffffff',
    textTransform: 'uppercase' as const,
  },
  timesheetRow: {
    flexDirection: 'row',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    alignItems: 'center',
  },
  showOriginalsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    backgroundColor: '#eff6ff',
    borderRadius: 8,
    marginBottom: 12,
    gap: 6,
  },
  showOriginalsText: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#3b82f6',
  },
  dateCell: {
    width: 120,
    justifyContent: 'center',
  },
  operatorCell: {
    width: 160,
    justifyContent: 'center',
  },
  hoursCell: {
    width: 100,
    justifyContent: 'center',
  },
  timeCell: {
    width: 120,
    justifyContent: 'center',
  },
  verifiedCell: {
    width: 120,
    justifyContent: 'center',
  },
  cellText: {
    fontSize: 13,
    color: '#475569',
  },
  boldText: {
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  smallText: {
    fontSize: 11,
  },
  rowBadge: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
    marginTop: 4,
    alignSelf: 'flex-start',
  },
  rowBadgeText: {
    fontSize: 9,
    fontWeight: '700' as const,
    color: '#ffffff',
  },
  summaryRow: {
    backgroundColor: '#f1f5f9',
    borderTopWidth: 2,
    borderTopColor: '#1e3a8a',
    borderBottomWidth: 0,
  },
  emptyState: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
  },
  selectorContainer: {
    flex: 1,
  },
  selectorSection: {
    padding: 16,
    backgroundColor: '#ffffff',
    marginBottom: 8,
  },
  selectorLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
    marginBottom: 12,
  },
  subList: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  subButton: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#ffffff',
    marginRight: 8,
  },
  subButtonActive: {
    backgroundColor: '#1e3a8a',
    borderColor: '#1e3a8a',
  },
  subButtonText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#475569',
  },
  subButtonTextActive: {
    color: '#ffffff',
  },
  dateRangeContainer: {
    marginBottom: 16,
  },
  dateRangeHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    gap: 8,
  },
  dateRangeTitle: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  datePickersRow: {
    flexDirection: 'row',
    gap: 12,
  },
  datePickerBlock: {
    flex: 1,
  },
  datePickerLabel: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#64748b',
    marginBottom: 8,
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    height: 48,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    backgroundColor: '#ffffff',
  },
  dateButtonText: {
    fontSize: 15,
    color: '#1e293b',
    fontWeight: '500' as const,
  },
  assetCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  assetCardActive: {
    borderColor: '#3b82f6',
    backgroundColor: '#eff6ff',
  },
  assetCardContent: {
    flex: 1,
  },
  assetType: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  assetNumber: {
    fontSize: 14,
    color: '#64748b',
    marginTop: 2,
  },
  selectedBadge: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#3b82f6',
    alignItems: 'center',
    justifyContent: 'center',
  },
  selectedBadgeText: {
    fontSize: 16,
    fontWeight: '700' as const,
    color: '#ffffff',
  },
  emptyAssets: {
    padding: 32,
    alignItems: 'center',
  },
  applyButton: {
    backgroundColor: '#1e3a8a',
    paddingVertical: 14,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 16,
  },
  applyButtonText: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  backToSelectorButton: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  backToSelectorText: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e3a8a',
    marginLeft: 4,
  },
  selectionBanner: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    padding: 12,
    backgroundColor: '#d1fae5',
    borderBottomWidth: 1,
    borderBottomColor: '#10b981',
  },
  selectionBannerText: {
    flex: 1,
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#065f46',
  },
  clearSelectionButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    backgroundColor: '#ffffff',
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#10b981',
  },
  clearSelectionText: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#10b981',
  },
});


--- END OF FILE: components/accounts/PlantAssetsTimesheetsTab.tsx ---


================================================================================
CATEGORY: Billing Integration
FILE: components/accounts/AgreedHoursModal.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  TextInput,
  ScrollView,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { X, Check } from 'lucide-react-native';

type ViewMode = 'plant' | 'man';

type AgreedHoursData = {
  agreedHours?: number;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  agreedNotes?: string;
};

type TimesheetEntry = {
  id: string;
  date: string;
  operatorName: string;
  assetType?: string;
  plantNumber?: string;
  totalHours?: number;
  totalManHours?: number;
  normalHours?: number;
  overtimeHours?: number;
  sundayHours?: number;
  publicHolidayHours?: number;
  agreedHours?: number;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  agreedNotes?: string;
};

type Props = {
  visible: boolean;
  onClose: () => void;
  onSubmit: (data: AgreedHoursData) => Promise<void>;
  timesheet: TimesheetEntry | null;
  viewMode: ViewMode;
};

export default function AgreedHoursModal({
  visible,
  onClose,
  onSubmit,
  timesheet,
  viewMode,
}: Props) {
  const [agreedHours, setAgreedHours] = useState<string>('');
  const [agreedNormalHours, setAgreedNormalHours] = useState<string>('');
  const [agreedOvertimeHours, setAgreedOvertimeHours] = useState<string>('');
  const [agreedSundayHours, setAgreedSundayHours] = useState<string>('');
  const [agreedPublicHolidayHours, setAgreedPublicHolidayHours] = useState<string>('');
  const [agreedNotes, setAgreedNotes] = useState<string>('');
  const [submitting, setSubmitting] = useState(false);

  useEffect(() => {
    if (timesheet) {
      if (viewMode === 'plant') {
        setAgreedHours(timesheet.agreedHours?.toString() || timesheet.totalHours?.toString() || '');
      } else {
        setAgreedNormalHours(timesheet.agreedNormalHours?.toString() || timesheet.normalHours?.toString() || '');
        setAgreedOvertimeHours(timesheet.agreedOvertimeHours?.toString() || timesheet.overtimeHours?.toString() || '');
        setAgreedSundayHours(timesheet.agreedSundayHours?.toString() || timesheet.sundayHours?.toString() || '');
        setAgreedPublicHolidayHours(timesheet.agreedPublicHolidayHours?.toString() || timesheet.publicHolidayHours?.toString() || '');
      }
      setAgreedNotes(timesheet.agreedNotes || '');
    }
  }, [timesheet, viewMode]);

  const handleSubmit = async () => {
    if (viewMode === 'plant') {
      const hours = parseFloat(agreedHours);
      if (isNaN(hours) || hours < 0) {
        Alert.alert('Invalid Input', 'Please enter a valid number for agreed hours');
        return;
      }
    } else {
      const normal = parseFloat(agreedNormalHours || '0');
      const overtime = parseFloat(agreedOvertimeHours || '0');
      const sunday = parseFloat(agreedSundayHours || '0');
      const publicHoliday = parseFloat(agreedPublicHolidayHours || '0');
      
      if (isNaN(normal) || isNaN(overtime) || isNaN(sunday) || isNaN(publicHoliday)) {
        Alert.alert('Invalid Input', 'Please enter valid numbers for all hour fields');
        return;
      }
      
      if (normal < 0 || overtime < 0 || sunday < 0 || publicHoliday < 0) {
        Alert.alert('Invalid Input', 'Hours cannot be negative');
        return;
      }
    }

    setSubmitting(true);
    try {
      const data: AgreedHoursData = {
        agreedNotes,
      };

      if (viewMode === 'plant') {
        data.agreedHours = parseFloat(agreedHours);
      } else {
        data.agreedNormalHours = parseFloat(agreedNormalHours || '0');
        data.agreedOvertimeHours = parseFloat(agreedOvertimeHours || '0');
        data.agreedSundayHours = parseFloat(agreedSundayHours || '0');
        data.agreedPublicHolidayHours = parseFloat(agreedPublicHolidayHours || '0');
      }

      await onSubmit(data);
      handleClose();
    } catch (error) {
      console.error('[AgreedHoursModal] Submit error:', error);
      Alert.alert('Error', 'Failed to save agreed hours');
    } finally {
      setSubmitting(false);
    }
  };

  const handleClose = () => {
    setAgreedHours('');
    setAgreedNormalHours('');
    setAgreedOvertimeHours('');
    setAgreedSundayHours('');
    setAgreedPublicHolidayHours('');
    setAgreedNotes('');
    onClose();
  };

  if (!timesheet) return null;

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={handleClose}
    >
      <View style={styles.overlay}>
        <View style={styles.modal}>
          <View style={styles.header}>
            <View>
              <Text style={styles.title}>Agree Hours for Billing</Text>
              <Text style={styles.subtitle}>
                {new Date(timesheet.date).toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: 'short',
                  year: 'numeric',
                })}
              </Text>
              <Text style={styles.subtitle}>
                {viewMode === 'plant'
                  ? `${timesheet.assetType || 'Asset'} - ${timesheet.plantNumber || 'N/A'}`
                  : timesheet.operatorName}
              </Text>
            </View>
            <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.content}>
            {viewMode === 'plant' ? (
              <View style={styles.inputGroup}>
                <Text style={styles.label}>
                  Agreed Total Hours <Text style={styles.required}>*</Text>
                </Text>
                <Text style={styles.hint}>
                  Plant Manager: {timesheet.totalHours?.toFixed(1) || 0}h
                </Text>
                <TextInput
                  style={styles.input}
                  value={agreedHours}
                  onChangeText={setAgreedHours}
                  keyboardType="decimal-pad"
                  placeholder="0.0"
                />
              </View>
            ) : (
              <>
                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Agreed Normal Hours</Text>
                  <Text style={styles.hint}>
                    Plant Manager: {timesheet.normalHours?.toFixed(1) || 0}h
                  </Text>
                  <TextInput
                    style={styles.input}
                    value={agreedNormalHours}
                    onChangeText={setAgreedNormalHours}
                    keyboardType="decimal-pad"
                    placeholder="0.0"
                  />
                </View>

                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Agreed Overtime Hours</Text>
                  <Text style={styles.hint}>
                    Plant Manager: {timesheet.overtimeHours?.toFixed(1) || 0}h
                  </Text>
                  <TextInput
                    style={styles.input}
                    value={agreedOvertimeHours}
                    onChangeText={setAgreedOvertimeHours}
                    keyboardType="decimal-pad"
                    placeholder="0.0"
                  />
                </View>

                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Agreed Sunday Hours</Text>
                  <Text style={styles.hint}>
                    Plant Manager: {timesheet.sundayHours?.toFixed(1) || 0}h
                  </Text>
                  <TextInput
                    style={styles.input}
                    value={agreedSundayHours}
                    onChangeText={setAgreedSundayHours}
                    keyboardType="decimal-pad"
                    placeholder="0.0"
                  />
                </View>

                <View style={styles.inputGroup}>
                  <Text style={styles.label}>Agreed Public Holiday Hours</Text>
                  <Text style={styles.hint}>
                    Plant Manager: {timesheet.publicHolidayHours?.toFixed(1) || 0}h
                  </Text>
                  <TextInput
                    style={styles.input}
                    value={agreedPublicHolidayHours}
                    onChangeText={setAgreedPublicHolidayHours}
                    keyboardType="decimal-pad"
                    placeholder="0.0"
                  />
                </View>
              </>
            )}

            <View style={styles.inputGroup}>
              <Text style={styles.label}>Billing Notes</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={agreedNotes}
                onChangeText={setAgreedNotes}
                placeholder="Add notes about agreed hours..."
                multiline
                numberOfLines={4}
                textAlignVertical="top"
              />
            </View>
          </ScrollView>

          <View style={styles.footer}>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={handleClose}
              disabled={submitting}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.submitButton, submitting && styles.submitButtonDisabled]}
              onPress={handleSubmit}
              disabled={submitting}
            >
              {submitting ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <Check size={20} color="#ffffff" />
                  <Text style={styles.submitButtonText}>Agree Hours</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  modal: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    width: '100%',
    maxWidth: 500,
    maxHeight: '90%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    color: '#64748b',
    marginTop: 2,
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 20,
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  required: {
    color: '#ef4444',
  },
  hint: {
    fontSize: 12,
    color: '#64748b',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    padding: 12,
    fontSize: 15,
    color: '#1e293b',
    backgroundColor: '#ffffff',
  },
  textArea: {
    minHeight: 100,
    paddingTop: 12,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  cancelButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  cancelButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  submitButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#10b981',
  },
  submitButtonDisabled: {
    opacity: 0.5,
  },
  submitButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
});


--- END OF FILE: components/accounts/AgreedHoursModal.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/TimesheetComparisonModal.tsx
================================================================================

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  ScrollView,
} from 'react-native';
import { X, ArrowRight } from 'lucide-react-native';

type TimesheetEntry = {
  id: string;
  date: string;
  operatorName: string;
  assetType?: string;
  plantNumber?: string;
  totalHours?: number;
  openHours?: string | number;
  closeHours?: string | number;
  isBreakdown?: boolean;
  isRainDay?: boolean;
  isStrikeDay?: boolean;
  isPublicHoliday?: boolean;
  notes?: string;
};

type ComparisonData = {
  plantManager: TimesheetEntry;
  adminEdited?: TimesheetEntry;
  subcontractorEdited?: TimesheetEntry;
};

type Props = {
  visible: boolean;
  onClose: () => void;
  comparison: ComparisonData | null;
};

export default function TimesheetComparisonModal({
  visible,
  onClose,
  comparison,
}: Props) {
  if (!comparison) return null;

  const renderComparisonRow = (label: string, pmValue: any, adminValue: any, subValue?: any) => {
    const hasAdminChange = adminValue !== undefined && adminValue !== pmValue;
    const hasSubChange = subValue !== undefined && subValue !== pmValue && subValue !== adminValue;

    return (
      <View style={styles.comparisonRow}>
        <Text style={styles.comparisonLabel}>{label}</Text>
        <View style={styles.comparisonValues}>
          <View style={styles.valueBox}>
            <Text style={styles.valueLabel}>PM</Text>
            <Text style={styles.valueText}>{pmValue?.toString() || ''}</Text>
          </View>
          
          {adminValue !== undefined && (
            <>
              <ArrowRight size={16} color="#94a3b8" />
              <View style={[styles.valueBox, hasAdminChange && styles.valueBoxHighlight]}>
                <Text style={styles.valueLabel}>Admin</Text>
                <Text style={[styles.valueText, hasAdminChange && styles.valueTextHighlight]}>
                  {adminValue?.toString() || ''}
                </Text>
              </View>
            </>
          )}

          {subValue !== undefined && (
            <>
              <ArrowRight size={16} color="#94a3b8" />
              <View style={[styles.valueBox, hasSubChange && styles.valueBoxSubHighlight]}>
                <Text style={styles.valueLabel}>Sub</Text>
                <Text style={[styles.valueText, hasSubChange && styles.valueTextSubHighlight]}>
                  {subValue?.toString() || ''}
                </Text>
              </View>
            </>
          )}
        </View>
      </View>
    );
  };

  const renderConditionRow = (label: string, pmValue: boolean, adminValue?: boolean, subValue?: boolean) => {
    return (
      <View style={styles.comparisonRow}>
        <Text style={styles.comparisonLabel}>{label}</Text>
        <View style={styles.comparisonValues}>
          <View style={styles.valueBox}>
            <Text style={styles.valueLabel}>PM</Text>
            <Text style={styles.valueText}>{pmValue ? '' : ''}</Text>
          </View>
          
          {adminValue !== undefined && (
            <>
              <ArrowRight size={16} color="#94a3b8" />
              <View style={[styles.valueBox, adminValue !== pmValue && styles.valueBoxHighlight]}>
                <Text style={styles.valueLabel}>Admin</Text>
                <Text style={[styles.valueText, adminValue !== pmValue && styles.valueTextHighlight]}>
                  {adminValue ? '' : ''}
                </Text>
              </View>
            </>
          )}

          {subValue !== undefined && (
            <>
              <ArrowRight size={16} color="#94a3b8" />
              <View style={[styles.valueBox, subValue !== adminValue && styles.valueBoxSubHighlight]}>
                <Text style={styles.valueLabel}>Sub</Text>
                <Text style={[styles.valueText, subValue !== adminValue && styles.valueTextSubHighlight]}>
                  {subValue ? '' : ''}
                </Text>
              </View>
            </>
          )}
        </View>
      </View>
    );
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.overlay}>
        <View style={styles.modal}>
          <View style={styles.header}>
            <View>
              <Text style={styles.title}>Timesheet Comparison</Text>
              <Text style={styles.subtitle}>
                {new Date(comparison.plantManager.date).toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: 'short',
                  year: 'numeric',
                })}
              </Text>
              <Text style={styles.subtitle}>
                {comparison.plantManager.assetType} - {comparison.plantManager.plantNumber}
              </Text>
            </View>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.content}>
            <View style={styles.legend}>
              <View style={styles.legendItem}>
                <View style={[styles.legendBox, { backgroundColor: '#eff6ff' }]} />
                <Text style={styles.legendText}>Plant Manager Original</Text>
              </View>
              <View style={styles.legendItem}>
                <View style={[styles.legendBox, { backgroundColor: '#fef3c7' }]} />
                <Text style={styles.legendText}>Admin Edited</Text>
              </View>
              {comparison.subcontractorEdited && (
                <View style={styles.legendItem}>
                  <View style={[styles.legendBox, { backgroundColor: '#dbeafe' }]} />
                  <Text style={styles.legendText}>Subcontractor Edit</Text>
                </View>
              )}
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Hours Information</Text>
              {renderComparisonRow(
                'Total Hours',
                comparison.plantManager.totalHours?.toFixed(1),
                comparison.adminEdited?.totalHours?.toFixed(1),
                comparison.subcontractorEdited?.totalHours?.toFixed(1)
              )}
              {renderComparisonRow(
                'Open Hours',
                comparison.plantManager.openHours,
                comparison.adminEdited?.openHours,
                comparison.subcontractorEdited?.openHours
              )}
              {renderComparisonRow(
                'Close Hours',
                comparison.plantManager.closeHours,
                comparison.adminEdited?.closeHours,
                comparison.subcontractorEdited?.closeHours
              )}
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Conditions</Text>
              {renderConditionRow(
                'Breakdown',
                comparison.plantManager.isBreakdown || false,
                comparison.adminEdited?.isBreakdown,
                comparison.subcontractorEdited?.isBreakdown
              )}
              {renderConditionRow(
                'Rain Day',
                comparison.plantManager.isRainDay || false,
                comparison.adminEdited?.isRainDay,
                comparison.subcontractorEdited?.isRainDay
              )}
              {renderConditionRow(
                'Strike Day',
                comparison.plantManager.isStrikeDay || false,
                comparison.adminEdited?.isStrikeDay,
                comparison.subcontractorEdited?.isStrikeDay
              )}
              {renderConditionRow(
                'Public Holiday',
                comparison.plantManager.isPublicHoliday || false,
                comparison.adminEdited?.isPublicHoliday,
                comparison.subcontractorEdited?.isPublicHoliday
              )}
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Notes</Text>
              <View style={styles.notesContainer}>
                <View style={styles.noteBlock}>
                  <Text style={styles.noteLabel}>Plant Manager:</Text>
                  <Text style={styles.noteText}>
                    {comparison.plantManager.notes || 'No notes'}
                  </Text>
                </View>
                {comparison.adminEdited?.notes && (
                  <View style={styles.noteBlock}>
                    <Text style={styles.noteLabel}>Admin:</Text>
                    <Text style={styles.noteText}>
                      {comparison.adminEdited.notes}
                    </Text>
                  </View>
                )}
                {comparison.subcontractorEdited?.notes && (
                  <View style={styles.noteBlock}>
                    <Text style={styles.noteLabel}>Subcontractor:</Text>
                    <Text style={styles.noteText}>
                      {comparison.subcontractorEdited.notes}
                    </Text>
                  </View>
                )}
              </View>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            <TouchableOpacity style={styles.closeButtonFooter} onPress={onClose}>
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  modal: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    width: '100%',
    maxWidth: 600,
    maxHeight: '90%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 13,
    color: '#64748b',
    marginTop: 2,
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 20,
  },
  legend: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
    marginBottom: 20,
    padding: 12,
    backgroundColor: '#f8fafc',
    borderRadius: 8,
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  legendBox: {
    width: 16,
    height: 16,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#cbd5e1',
  },
  legendText: {
    fontSize: 12,
    color: '#64748b',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 12,
    textTransform: 'uppercase' as const,
    letterSpacing: 0.5,
  },
  comparisonRow: {
    marginBottom: 16,
  },
  comparisonLabel: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#475569',
    marginBottom: 8,
  },
  comparisonValues: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  valueBox: {
    flex: 1,
    backgroundColor: '#f8fafc',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  valueBoxHighlight: {
    backgroundColor: '#fef3c7',
    borderColor: '#fbbf24',
  },
  valueBoxSubHighlight: {
    backgroundColor: '#dbeafe',
    borderColor: '#3b82f6',
  },
  valueLabel: {
    fontSize: 10,
    fontWeight: '700' as const,
    color: '#94a3b8',
    textTransform: 'uppercase' as const,
    marginBottom: 4,
  },
  valueText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  valueTextHighlight: {
    color: '#92400e',
  },
  valueTextSubHighlight: {
    color: '#1e40af',
  },
  notesContainer: {
    gap: 12,
  },
  noteBlock: {
    backgroundColor: '#f8fafc',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  noteLabel: {
    fontSize: 12,
    fontWeight: '700' as const,
    color: '#64748b',
    marginBottom: 4,
  },
  noteText: {
    fontSize: 14,
    color: '#1e293b',
    lineHeight: 20,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  closeButtonFooter: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#1e3a8a',
  },
  closeButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
});


--- END OF FILE: components/accounts/TimesheetComparisonModal.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/SendConfirmationModal.tsx
================================================================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  TextInput,
  ScrollView,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { X, Send, Mail } from 'lucide-react-native';

type Props = {
  visible: boolean;
  onClose: () => void;
  onSend: (recipientEmail: string, message: string) => Promise<void>;
  onDirectApprove?: () => Promise<void>;
  subcontractorName: string;
  assetCount: number;
  dateRange: { from: Date; to: Date };
};

export default function SendConfirmationModal({
  visible,
  onClose,
  onSend,
  onDirectApprove,
  subcontractorName,
  assetCount,
  dateRange,
}: Props) {
  const [recipientEmail, setRecipientEmail] = useState('');
  const [message, setMessage] = useState('');
  const [sending, setSending] = useState(false);
  const [approving, setApproving] = useState(false);

  const handleSend = async () => {
    if (!recipientEmail.trim()) {
      Alert.alert('Required Field', 'Please enter recipient email address');
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(recipientEmail)) {
      Alert.alert('Invalid Email', 'Please enter a valid email address');
      return;
    }

    setSending(true);
    try {
      await onSend(recipientEmail, message);
      handleClose();
    } catch (error) {
      console.error('[SendConfirmationModal] Error sending:', error);
      Alert.alert('Error', 'Failed to send EPH report');
    } finally {
      setSending(false);
    }
  };

  const handleDirectApprove = async () => {
    if (!onDirectApprove) return;
    
    Alert.alert(
      'Direct Approval',
      'This will approve the EPH without subcontractor digital approval. You can send the PDF manually afterwards. Continue?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Approve',
          style: 'default',
          onPress: async () => {
            setApproving(true);
            try {
              await onDirectApprove();
              handleClose();
            } catch (error) {
              console.error('[SendConfirmationModal] Error approving:', error);
              Alert.alert('Error', 'Failed to approve EPH');
            } finally {
              setApproving(false);
            }
          },
        },
      ]
    );
  };

  const handleClose = () => {
    setRecipientEmail('');
    setMessage('');
    onClose();
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={handleClose}
    >
      <View style={styles.overlay}>
        <View style={styles.modal}>
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.iconContainer}>
                <Mail size={24} color="#3b82f6" />
              </View>
              <View>
                <Text style={styles.title}>Send EPH to Subcontractor</Text>
                <Text style={styles.subtitle}>
                  {subcontractorName}
                </Text>
              </View>
            </View>
            <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.content}>
            <View style={styles.summaryBox}>
              <Text style={styles.summaryTitle}>EPH Summary</Text>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Period:</Text>
                <Text style={styles.summaryValue}>
                  {formatDate(dateRange.from)} - {formatDate(dateRange.to)}
                </Text>
              </View>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Assets:</Text>
                <Text style={styles.summaryValue}>{assetCount} plant asset(s)</Text>
              </View>
            </View>

            <View style={styles.infoBox}>
              <Text style={styles.infoText}>
                 The subcontractor will receive the EPH report and can review/edit before agreement
              </Text>
            </View>

            {onDirectApprove && (
              <View style={styles.dividerContainer}>
                <View style={styles.divider} />
                <Text style={styles.dividerText}>OR</Text>
                <View style={styles.divider} />
              </View>
            )}

            {onDirectApprove && (
              <View style={styles.directApprovalBox}>
                <Text style={styles.directApprovalTitle}>Direct Approval (No Digital Workflow)</Text>
                <Text style={styles.directApprovalDescription}>
                  If subcontractor does not have app access, you can approve directly and send PDF manually via email/WhatsApp.
                </Text>
                <TouchableOpacity
                  style={[styles.directApproveButton, approving && styles.directApproveButtonDisabled]}
                  onPress={handleDirectApprove}
                  disabled={approving || sending}
                >
                  {approving ? (
                    <ActivityIndicator size="small" color="#ffffff" />
                  ) : (
                    <>
                      <Text style={styles.directApproveButtonText}>Approve & Finalize</Text>
                    </>
                  )}
                </TouchableOpacity>
              </View>
            )}

            {onDirectApprove && (
              <View style={styles.dividerContainer}>
                <View style={styles.divider} />
              </View>
            )}

            <Text style={styles.sectionTitle}>Send for Digital Approval</Text>

            <View style={styles.inputGroup}>
              <Text style={styles.label}>
                Recipient Email <Text style={styles.required}>*</Text>
              </Text>
              <TextInput
                style={styles.input}
                value={recipientEmail}
                onChangeText={setRecipientEmail}
                placeholder="subcontractor@example.com"
                placeholderTextColor="#9ca3af"
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
              />
            </View>

            <View style={styles.inputGroup}>
              <Text style={styles.label}>Message (Optional)</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={message}
                onChangeText={setMessage}
                placeholder="Add a message for the subcontractor..."
                placeholderTextColor="#9ca3af"
                multiline
                numberOfLines={4}
                textAlignVertical="top"
              />
            </View>

            <View style={styles.noteBox}>
              <Text style={styles.noteText}>
                Note: Subcontractor will need to review and approve before hours are finalized
              </Text>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={handleClose}
              disabled={sending || approving}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.sendButton, (sending || approving) && styles.sendButtonDisabled]}
              onPress={handleSend}
              disabled={sending || approving}
            >
              {sending ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <Send size={20} color="#ffffff" />
                  <Text style={styles.sendButtonText}>Send for Approval</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  modal: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    width: '100%',
    maxWidth: 500,
    maxHeight: '90%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    flex: 1,
  },
  iconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#eff6ff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 2,
  },
  subtitle: {
    fontSize: 14,
    color: '#64748b',
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 20,
  },
  summaryBox: {
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  summaryTitle: {
    fontSize: 14,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 12,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  summaryLabel: {
    fontSize: 14,
    color: '#64748b',
  },
  summaryValue: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  infoBox: {
    backgroundColor: '#eff6ff',
    borderRadius: 8,
    padding: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#bfdbfe',
  },
  infoText: {
    fontSize: 13,
    color: '#1e40af',
    lineHeight: 18,
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 8,
  },
  required: {
    color: '#ef4444',
  },
  input: {
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    padding: 12,
    fontSize: 15,
    color: '#1e293b',
    backgroundColor: '#ffffff',
  },
  textArea: {
    minHeight: 100,
    paddingTop: 12,
  },
  noteBox: {
    backgroundColor: '#fef3c7',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#fde047',
  },
  noteText: {
    fontSize: 12,
    color: '#92400e',
    lineHeight: 16,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  cancelButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  cancelButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  sendButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#3b82f6',
  },
  sendButtonDisabled: {
    opacity: 0.5,
  },
  sendButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 20,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#e2e8f0',
  },
  dividerText: {
    fontSize: 12,
    fontWeight: '600' as const,
    color: '#94a3b8',
    marginHorizontal: 16,
  },
  directApprovalBox: {
    backgroundColor: '#f0fdf4',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#86efac',
  },
  directApprovalTitle: {
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#15803d',
    marginBottom: 8,
  },
  directApprovalDescription: {
    fontSize: 13,
    color: '#166534',
    lineHeight: 18,
    marginBottom: 12,
  },
  directApproveButton: {
    backgroundColor: '#16a34a',
    borderRadius: 8,
    paddingVertical: 12,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 44,
  },
  directApproveButtonDisabled: {
    opacity: 0.5,
  },
  directApproveButtonText: {
    fontSize: 15,
    fontWeight: '700' as const,
    color: '#ffffff',
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 16,
  },
});


--- END OF FILE: components/accounts/SendConfirmationModal.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/FiltersBar.tsx
================================================================================

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
} from 'react-native';
import { Filter, X } from 'lucide-react-native';

export type FilterValues = {
  companyId?: string;
  siteId?: string;
  fromDate?: Date;
  toDate?: Date;
  subcontractorId?: string;
  assetId?: string;
  workerId?: string;
  supervisorId?: string;
  search?: string;
};

type Props = {
  filters: FilterValues;
  onFiltersChange: (filters: FilterValues) => void;
  companies?: { id: string; name: string }[];
  sites?: { id: string; name: string }[];
  subcontractors?: { id: string; name: string }[];
  showAssetFilters?: boolean;
  showProgressFilters?: boolean;
};

export default function FiltersBar({
  filters,
  onFiltersChange,
  companies = [],
  sites = [],
  subcontractors = [],
  showAssetFilters = false,
  showProgressFilters = false,
}: Props) {
  const hasActiveFilters = Object.keys(filters).some(
    (key) => filters[key as keyof FilterValues] !== undefined
  );

  const clearFilters = () => {
    onFiltersChange({});
  };

  const handleSearchChange = (text: string) => {
    onFiltersChange({ ...filters, search: text });
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.titleRow}>
          <Filter size={20} color="#1e293b" />
          <Text style={styles.title}>Filters</Text>
        </View>
        {hasActiveFilters && (
          <TouchableOpacity
            style={styles.clearButton}
            onPress={clearFilters}
            testID="clear-filters"
          >
            <X size={16} color="#ef4444" />
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.filtersContent}
        style={styles.scrollView}
      >
        <View style={styles.searchContainer}>
          <TextInput
            style={styles.searchInput}
            placeholder="Search..."
            value={filters.search || ''}
            onChangeText={handleSearchChange}
            placeholderTextColor="#94a3b8"
            testID="search-input"
          />
        </View>

        {companies.length > 0 && (
          <View style={styles.filterItem}>
            <Text style={styles.filterLabel}>Company</Text>
            <Text style={styles.filterValue}>
              {filters.companyId
                ? companies.find((c) => c.id === filters.companyId)?.name ||
                  'Select'
                : 'All'}
            </Text>
          </View>
        )}

        {sites.length > 0 && (
          <View style={styles.filterItem}>
            <Text style={styles.filterLabel}>Site</Text>
            <Text style={styles.filterValue}>
              {filters.siteId
                ? sites.find((s) => s.id === filters.siteId)?.name || 'Select'
                : 'All'}
            </Text>
          </View>
        )}

        <View style={styles.filterItem}>
          <Text style={styles.filterLabel}>Date Range</Text>
          <Text style={styles.filterValue}>
            {filters.fromDate && filters.toDate
              ? `${filters.fromDate.toLocaleDateString()} - ${filters.toDate.toLocaleDateString()}`
              : 'All Time'}
          </Text>
        </View>

        {showAssetFilters && (
          <>
            <View style={styles.filterItem}>
              <Text style={styles.filterLabel}>Asset</Text>
              <Text style={styles.filterValue}>
                {filters.assetId ? 'Selected' : 'All'}
              </Text>
            </View>

            {subcontractors.length > 0 && (
              <View style={styles.filterItem}>
                <Text style={styles.filterLabel}>Subcontractor</Text>
                <Text style={styles.filterValue}>
                  {filters.subcontractorId 
                    ? subcontractors.find(s => s.id === filters.subcontractorId)?.name || 'Selected'
                    : 'All'}
                </Text>
              </View>
            )}
          </>
        )}

        {showProgressFilters && (
          <View style={styles.filterItem}>
            <Text style={styles.filterLabel}>Supervisor</Text>
            <Text style={styles.filterValue}>
              {filters.supervisorId ? 'Selected' : 'All'}
            </Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    paddingVertical: 12,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 12,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  title: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
  },
  clearButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
    backgroundColor: '#fef2f2',
  },
  clearText: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#ef4444',
  },
  scrollView: {
    flexGrow: 0,
  },
  filtersContent: {
    paddingHorizontal: 16,
    gap: 12,
    flexDirection: 'row',
  },
  searchContainer: {
    minWidth: 200,
    marginRight: 8,
  },
  searchInput: {
    height: 40,
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    paddingHorizontal: 12,
    fontSize: 14,
    color: '#1e293b',
  },
  filterItem: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    minWidth: 120,
  },
  filterLabel: {
    fontSize: 11,
    fontWeight: '600' as const,
    color: '#64748b',
    textTransform: 'uppercase',
    marginBottom: 2,
  },
  filterValue: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#1e293b',
  },
});


--- END OF FILE: components/accounts/FiltersBar.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/ExportRequestModal.tsx
================================================================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  ScrollView,
  Switch,
  ActivityIndicator,
} from 'react-native';
import { X, FileDown, AlertCircle } from 'lucide-react-native';

export type ExportType =
  | 'plantHours'
  | 'workerTimesheets'
  | 'activityActuals'
  | 'boqComparison'
  | 'faceAudit'
  | 'qcInspections'
  | 'supervisorPerformance';

export type ExportFormat = 'csv' | 'json' | 'xlsx';

export type GroupBy = 'none' | 'subcontractor' | 'asset' | 'supervisor' | 'activityGroup';

export type ExportRequest = {
  type: ExportType;
  format: ExportFormat;
  groupBy: GroupBy;
  includeAttachments: boolean;
  filters: {
    companyId?: string;
    siteId?: string;
    fromDate?: Date;
    toDate?: Date;
    assetIds?: string[];
    workerIds?: string[];
    taskIds?: string[];
    subcontractorIds?: string[];
  };
  notifyEmails?: string[];
};

type Props = {
  visible: boolean;
  onClose: () => void;
  onSubmit: (request: ExportRequest) => Promise<void>;
  exportType: ExportType;
  prefilledFilters?: Partial<ExportRequest['filters']>;
  estimatedRows?: number;
  isLargeExport?: boolean;
};

const EXPORT_TYPE_LABELS: Record<ExportType, string> = {
  plantHours: 'Plant Hours',
  workerTimesheets: 'Worker Timesheets',
  activityActuals: 'Activity Actuals',
  boqComparison: 'BOQ Comparison',
  faceAudit: 'Face Clock Audit',
  qcInspections: 'QC Inspections',
  supervisorPerformance: 'Supervisor Performance',
};

const FORMAT_OPTIONS: ExportFormat[] = ['csv', 'json', 'xlsx'];

const GROUP_BY_OPTIONS: Record<ExportType, GroupBy[]> = {
  plantHours: ['none', 'subcontractor', 'asset'],
  workerTimesheets: ['none', 'subcontractor'],
  activityActuals: ['none', 'supervisor', 'activityGroup'],
  boqComparison: ['none', 'activityGroup'],
  faceAudit: ['none', 'supervisor'],
  qcInspections: ['none', 'supervisor'],
  supervisorPerformance: ['none'],
};

export default function ExportRequestModal({
  visible,
  onClose,
  onSubmit,
  exportType,
  prefilledFilters = {},
  estimatedRows = 0,
  isLargeExport = false,
}: Props) {
  const [format, setFormat] = useState<ExportFormat>('csv');
  const [groupBy, setGroupBy] = useState<GroupBy>('none');
  const [includeAttachments, setIncludeAttachments] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async () => {
    setLoading(true);
    try {
      await onSubmit({
        type: exportType,
        format,
        groupBy,
        includeAttachments,
        filters: prefilledFilters,
      });
      onClose();
    } catch (error) {
      console.error('[ExportRequestModal] Submit error:', error);
    } finally {
      setLoading(false);
    }
  };

  const availableGroupByOptions = GROUP_BY_OPTIONS[exportType] || ['none'];

  return (
    <Modal
      visible={visible}
      transparent
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.overlay}>
        <View style={styles.modal}>
          <View style={styles.header}>
            <View style={styles.headerLeft}>
              <FileDown size={24} color="#1e3a8a" />
              <Text style={styles.title}>Create Export</Text>
            </View>
            <TouchableOpacity
              onPress={onClose}
              style={styles.closeButton}
              testID="close-modal"
            >
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.content}>
            <View style={styles.section}>
              <Text style={styles.label}>Export Type</Text>
              <View style={styles.card}>
                <Text style={styles.cardValue}>
                  {EXPORT_TYPE_LABELS[exportType]}
                </Text>
              </View>
            </View>

            {isLargeExport && (
              <View style={styles.warningBox}>
                <AlertCircle size={20} color="#f59e0b" />
                <View style={styles.warningTextContainer}>
                  <Text style={styles.warningTitle}>Large Export</Text>
                  <Text style={styles.warningText}>
                    This export contains approximately {estimatedRows.toLocaleString()} rows.
                    It will be processed server-side and you&apos;ll be notified when ready.
                  </Text>
                </View>
              </View>
            )}

            <View style={styles.section}>
              <Text style={styles.label}>Format</Text>
              <View style={styles.optionsRow}>
                {FORMAT_OPTIONS.map((fmt) => (
                  <TouchableOpacity
                    key={fmt}
                    style={[
                      styles.optionButton,
                      format === fmt && styles.optionButtonActive,
                    ]}
                    onPress={() => setFormat(fmt)}
                    testID={`format-${fmt}`}
                  >
                    <Text
                      style={[
                        styles.optionText,
                        format === fmt && styles.optionTextActive,
                      ]}
                    >
                      {fmt.toUpperCase()}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.label}>Group By</Text>
              <View style={styles.optionsColumn}>
                {availableGroupByOptions.map((option) => (
                  <TouchableOpacity
                    key={option}
                    style={[
                      styles.optionButtonFull,
                      groupBy === option && styles.optionButtonActive,
                    ]}
                    onPress={() => setGroupBy(option)}
                    testID={`groupby-${option}`}
                  >
                    <Text
                      style={[
                        styles.optionText,
                        groupBy === option && styles.optionTextActive,
                      ]}
                    >
                      {option === 'none' ? 'Single File' : option.replace(/([A-Z])/g, ' $1').trim()}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            <View style={styles.section}>
              <View style={styles.switchRow}>
                <Text style={styles.label}>Include Attachments</Text>
                <Switch
                  value={includeAttachments}
                  onValueChange={setIncludeAttachments}
                  testID="include-attachments-switch"
                />
              </View>
              <Text style={styles.helperText}>
                Include image and document attachments in the export (may increase file size significantly)
              </Text>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={onClose}
              disabled={loading}
              testID="cancel-button"
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.submitButton, loading && styles.submitButtonDisabled]}
              onPress={handleSubmit}
              disabled={loading}
              testID="submit-button"
            >
              {loading ? (
                <ActivityIndicator color="#ffffff" size="small" />
              ) : (
                <>
                  <FileDown size={20} color="#ffffff" />
                  <Text style={styles.submitButtonText}>Create Export</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modal: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  title: {
    fontSize: 20,
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  closeButton: {
    padding: 4,
  },
  content: {
    flex: 1,
    padding: 20,
  },
  section: {
    marginBottom: 24,
  },
  label: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 8,
  },
  card: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    padding: 12,
  },
  cardValue: {
    fontSize: 16,
    fontWeight: '500' as const,
    color: '#1e293b',
  },
  warningBox: {
    flexDirection: 'row',
    gap: 12,
    backgroundColor: '#fffbeb',
    borderWidth: 1,
    borderColor: '#fbbf24',
    borderRadius: 8,
    padding: 12,
    marginBottom: 24,
  },
  warningTextContainer: {
    flex: 1,
  },
  warningTitle: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#92400e',
    marginBottom: 4,
  },
  warningText: {
    fontSize: 13,
    color: '#78350f',
    lineHeight: 18,
  },
  optionsRow: {
    flexDirection: 'row',
    gap: 8,
  },
  optionsColumn: {
    gap: 8,
  },
  optionButton: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    backgroundColor: '#ffffff',
    alignItems: 'center',
  },
  optionButtonFull: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    backgroundColor: '#ffffff',
    alignItems: 'center',
  },
  optionButtonActive: {
    backgroundColor: '#eff6ff',
    borderColor: '#3b82f6',
  },
  optionText: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#64748b',
  },
  optionTextActive: {
    color: '#3b82f6',
    fontWeight: '600' as const,
  },
  switchRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  helperText: {
    fontSize: 12,
    color: '#64748b',
    lineHeight: 16,
  },
  footer: {
    flexDirection: 'row',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 14,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  submitButton: {
    flex: 2,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 14,
    backgroundColor: '#1e3a8a',
    borderRadius: 8,
  },
  submitButtonDisabled: {
    opacity: 0.6,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
});


--- END OF FILE: components/accounts/ExportRequestModal.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/ReportGenerationModal.tsx
================================================================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  TextInput,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { X, FileText, Mail, Download, CheckSquare, Square } from 'lucide-react-native';

type ReportScope = 'all' | 'selected';
type DeliveryMethod = 'download' | 'email';

type Props = {
  visible: boolean;
  onClose: () => void;
  onGenerate: (options: {
    scope: ReportScope;
    deliveryMethod: DeliveryMethod;
    recipientEmail?: string;
  }) => Promise<void>;
  hasSelection: boolean;
  selectedCount: number;
  totalCount: number;
};

export default function ReportGenerationModal({
  visible,
  onClose,
  onGenerate,
  hasSelection,
  selectedCount,
  totalCount,
}: Props) {
  const [scope, setScope] = useState<ReportScope>('all');
  const [deliveryMethod, setDeliveryMethod] = useState<DeliveryMethod>('download');
  const [recipientEmail, setRecipientEmail] = useState<string>('');
  const [generating, setGenerating] = useState(false);

  const handleGenerate = async () => {
    console.log('[ReportGenerationModal] Generate button pressed');
    console.log('[ReportGenerationModal] Scope:', scope);
    console.log('[ReportGenerationModal] Has Selection:', hasSelection);
    console.log('[ReportGenerationModal] Delivery Method:', deliveryMethod);

    if (deliveryMethod === 'email' && !recipientEmail.trim()) {
      console.log('[ReportGenerationModal] Email required but not provided');
      Alert.alert('Email Required', 'Please enter a recipient email address');
      return;
    }

    if (scope === 'selected' && !hasSelection) {
      console.log('[ReportGenerationModal] No selection made');
      Alert.alert(
        'No Selection',
        'Please select at least one asset/operator by tapping the checkbox next to them, then try again.',
        [{ text: 'OK' }]
      );
      return;
    }

    console.log('[ReportGenerationModal] Starting PDF generation...');
    setGenerating(true);
    try {
      await onGenerate({
        scope,
        deliveryMethod,
        recipientEmail: deliveryMethod === 'email' ? recipientEmail.trim() : undefined,
      });
      console.log('[ReportGenerationModal] PDF generation completed');
      handleClose();
    } catch (error) {
      console.error('[ReportGenerationModal] Generate error:', error);
      Alert.alert(
        'Generation Failed',
        'Failed to generate the report. Please check the console for details.',
        [{ text: 'OK' }]
      );
    } finally {
      setGenerating(false);
    }
  };

  const handleClose = () => {
    setScope('all');
    setDeliveryMethod('download');
    setRecipientEmail('');
    onClose();
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={handleClose}
    >
      <View style={styles.overlay}>
        <View style={styles.modal}>
          <View style={styles.header}>
            <View style={styles.headerLeft}>
              <FileText size={24} color="#1e3a8a" />
              <Text style={styles.title}>Generate Timesheet Report</Text>
            </View>
            <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
              <X size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.content}>
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Report Scope</Text>
              <Text style={styles.sectionDescription}>
                Choose which assets/operators to include in the report
              </Text>

              <TouchableOpacity
                style={[styles.option, scope === 'all' && styles.optionActive]}
                onPress={() => setScope('all')}
                activeOpacity={0.7}
              >
                <View style={styles.optionLeft}>
                  {scope === 'all' ? (
                    <CheckSquare size={24} color="#1e3a8a" />
                  ) : (
                    <Square size={24} color="#94a3b8" />
                  )}
                  <View style={styles.optionText}>
                    <Text style={styles.optionTitle}>All Assets</Text>
                    <Text style={styles.optionDescription}>
                      Include all {totalCount} items in the report
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.option, scope === 'selected' && styles.optionActive]}
                onPress={() => setScope('selected')}
                activeOpacity={0.7}
                disabled={!hasSelection}
              >
                <View style={styles.optionLeft}>
                  {scope === 'selected' ? (
                    <CheckSquare size={24} color="#1e3a8a" />
                  ) : (
                    <Square size={24} color={hasSelection ? '#94a3b8' : '#cbd5e1'} />
                  )}
                  <View style={styles.optionText}>
                    <Text style={[styles.optionTitle, !hasSelection && styles.optionDisabled]}>
                      Selected Only
                    </Text>
                    <Text style={[styles.optionDescription, !hasSelection && styles.optionDisabled]}>
                      {hasSelection
                        ? `Include only ${selectedCount} selected item${selectedCount > 1 ? 's' : ''}`
                        : 'No items selected'}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Delivery Method</Text>
              <Text style={styles.sectionDescription}>
                How would you like to receive the report?
              </Text>

              <TouchableOpacity
                style={[styles.option, deliveryMethod === 'download' && styles.optionActive]}
                onPress={() => setDeliveryMethod('download')}
                activeOpacity={0.7}
              >
                <View style={styles.optionLeft}>
                  <Download size={24} color={deliveryMethod === 'download' ? '#1e3a8a' : '#94a3b8'} />
                  <View style={styles.optionText}>
                    <Text style={styles.optionTitle}>Download/Share PDF</Text>
                    <Text style={styles.optionDescription}>
                      Save to device or share via other apps
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.option, deliveryMethod === 'email' && styles.optionActive]}
                onPress={() => setDeliveryMethod('email')}
                activeOpacity={0.7}
              >
                <View style={styles.optionLeft}>
                  <Mail size={24} color={deliveryMethod === 'email' ? '#1e3a8a' : '#94a3b8'} />
                  <View style={styles.optionText}>
                    <Text style={styles.optionTitle}>Email PDF</Text>
                    <Text style={styles.optionDescription}>
                      Send report via email
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              {deliveryMethod === 'email' && (
                <View style={styles.emailInputContainer}>
                  <Text style={styles.inputLabel}>Recipient Email</Text>
                  <TextInput
                    style={styles.input}
                    value={recipientEmail}
                    onChangeText={setRecipientEmail}
                    placeholder="email@example.com"
                    keyboardType="email-address"
                    autoCapitalize="none"
                    autoCorrect={false}
                  />
                </View>
              )}
            </View>
          </ScrollView>

          <View style={styles.footer}>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={handleClose}
              disabled={generating}
            >
              <Text style={styles.cancelButtonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.generateButton, generating && styles.generateButtonDisabled]}
              onPress={handleGenerate}
              disabled={generating}
            >
              {generating ? (
                <>
                  <ActivityIndicator size="small" color="#ffffff" />
                  <Text style={styles.generateButtonText}>Generating...</Text>
                </>
              ) : (
                <>
                  <FileText size={20} color="#ffffff" />
                  <Text style={styles.generateButtonText}>Generate Report</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  modal: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    width: '100%',
    maxWidth: 500,
    maxHeight: '90%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 20,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 4,
  },
  sectionDescription: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 16,
  },
  option: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
    borderRadius: 12,
    marginBottom: 12,
    backgroundColor: '#ffffff',
  },
  optionActive: {
    borderColor: '#1e3a8a',
    backgroundColor: '#eff6ff',
  },
  optionLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    flex: 1,
  },
  optionText: {
    flex: 1,
  },
  optionTitle: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 2,
  },
  optionDescription: {
    fontSize: 13,
    color: '#64748b',
  },
  optionDisabled: {
    color: '#cbd5e1',
  },
  emailInputContainer: {
    marginTop: 16,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 8,
    padding: 12,
    fontSize: 15,
    color: '#1e293b',
    backgroundColor: '#ffffff',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  cancelButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  cancelButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  generateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#1e3a8a',
  },
  generateButtonDisabled: {
    opacity: 0.5,
  },
  generateButtonText: {
    fontSize: 15,
    fontWeight: '600' as const,
    color: '#ffffff',
  },
});


--- END OF FILE: components/accounts/ReportGenerationModal.tsx ---


================================================================================
CATEGORY: Supporting Components
FILE: components/accounts/ExportJobsList.tsx
================================================================================

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
} from 'react-native';
import { FileDown, RefreshCw, X, Clock, CheckCircle, XCircle } from 'lucide-react-native';

export type ExportJobStatus = 'queued' | 'running' | 'complete' | 'failed';

export type ExportJob = {
  id: string;
  type: string;
  requestedBy: string;
  requestedAt: Date;
  status: ExportJobStatus;
  params: {
    format?: string;
    groupBy?: string;
    dateRange?: string;
  };
  fileUrl?: string;
  recordCount?: number;
  fileSize?: number;
  error?: string;
};

type Props = {
  jobs: ExportJob[];
  loading: boolean;
  onDownload: (jobId: string) => void;
  onRetry: (jobId: string) => void;
  onCancel: (jobId: string) => void;
  onRefresh: () => void;
};

export default function ExportJobsList({
  jobs,
  loading,
  onDownload,
  onRetry,
  onCancel,
  onRefresh,
}: Props) {
  const getStatusIcon = (status: ExportJobStatus) => {
    switch (status) {
      case 'queued':
        return <Clock size={20} color="#64748b" />;
      case 'running':
        return <ActivityIndicator size="small" color="#3b82f6" />;
      case 'complete':
        return <CheckCircle size={20} color="#10b981" />;
      case 'failed':
        return <XCircle size={20} color="#ef4444" />;
    }
  };

  const getStatusColor = (status: ExportJobStatus) => {
    switch (status) {
      case 'queued':
        return '#64748b';
      case 'running':
        return '#3b82f6';
      case 'complete':
        return '#10b981';
      case 'failed':
        return '#ef4444';
    }
  };

  const formatFileSize = (bytes?: number) => {
    if (!bytes) return 'N/A';
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const renderJob = ({ item }: { item: ExportJob }) => (
    <View style={styles.jobCard} testID={`job-${item.id}`}>
      <View style={styles.jobHeader}>
        <View style={styles.jobHeaderLeft}>
          {getStatusIcon(item.status)}
          <View style={styles.jobInfo}>
            <Text style={styles.jobType}>{item.type}</Text>
            <Text style={styles.jobMeta}>
              {item.requestedAt.toLocaleString()}
            </Text>
          </View>
        </View>
        <View
          style={[
            styles.statusBadge,
            { backgroundColor: `${getStatusColor(item.status)}15` },
          ]}
        >
          <Text style={[styles.statusText, { color: getStatusColor(item.status) }]}>
            {item.status.toUpperCase()}
          </Text>
        </View>
      </View>

      <View style={styles.jobDetails}>
        {item.params.format && (
          <Text style={styles.detail}>Format: {item.params.format.toUpperCase()}</Text>
        )}
        {item.params.groupBy && item.params.groupBy !== 'none' && (
          <Text style={styles.detail}>Grouped by: {item.params.groupBy}</Text>
        )}
        {item.params.dateRange && (
          <Text style={styles.detail}>{item.params.dateRange}</Text>
        )}
        {item.recordCount !== undefined && (
          <Text style={styles.detail}>Records: {item.recordCount.toLocaleString()}</Text>
        )}
        {item.fileSize !== undefined && (
          <Text style={styles.detail}>Size: {formatFileSize(item.fileSize)}</Text>
        )}
      </View>

      {item.error && (
        <View style={styles.errorBox}>
          <Text style={styles.errorText}>{item.error}</Text>
        </View>
      )}

      <View style={styles.actions}>
        {item.status === 'complete' && item.fileUrl && (
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => onDownload(item.id)}
            testID={`download-${item.id}`}
          >
            <FileDown size={18} color="#3b82f6" />
            <Text style={styles.actionButtonText}>Download</Text>
          </TouchableOpacity>
        )}

        {item.status === 'failed' && (
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => onRetry(item.id)}
            testID={`retry-${item.id}`}
          >
            <RefreshCw size={18} color="#f59e0b" />
            <Text style={styles.actionButtonText}>Retry</Text>
          </TouchableOpacity>
        )}

        {item.status === 'queued' && (
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => onCancel(item.id)}
            testID={`cancel-${item.id}`}
          >
            <X size={18} color="#ef4444" />
            <Text style={styles.actionButtonText}>Cancel</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Export Jobs</Text>
        <TouchableOpacity
          onPress={onRefresh}
          style={styles.refreshButton}
          disabled={loading}
          testID="refresh-jobs"
        >
          {loading ? (
            <ActivityIndicator size="small" color="#3b82f6" />
          ) : (
            <RefreshCw size={20} color="#3b82f6" />
          )}
        </TouchableOpacity>
      </View>

      {jobs.length === 0 ? (
        <View style={styles.emptyState}>
          <FileDown size={48} color="#cbd5e1" />
          <Text style={styles.emptyTitle}>No export jobs yet</Text>
          <Text style={styles.emptyText}>
            Create an export to see it tracked here
          </Text>
        </View>
      ) : (
        <FlatList
          data={jobs}
          keyExtractor={(item) => item.id}
          renderItem={renderJob}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  title: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#1e293b',
  },
  refreshButton: {
    padding: 8,
  },
  listContent: {
    padding: 16,
    gap: 12,
  },
  jobCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#e5e7eb',
  },
  jobHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  jobHeaderLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    flex: 1,
  },
  jobInfo: {
    flex: 1,
  },
  jobType: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginBottom: 2,
  },
  jobMeta: {
    fontSize: 12,
    color: '#64748b',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 11,
    fontWeight: '600' as const,
  },
  jobDetails: {
    gap: 4,
    marginBottom: 12,
  },
  detail: {
    fontSize: 13,
    color: '#64748b',
  },
  errorBox: {
    backgroundColor: '#fef2f2',
    borderWidth: 1,
    borderColor: '#fecaca',
    borderRadius: 6,
    padding: 8,
    marginBottom: 12,
  },
  errorText: {
    fontSize: 12,
    color: '#dc2626',
    lineHeight: 16,
  },
  actions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    backgroundColor: '#ffffff',
  },
  actionButtonText: {
    fontSize: 14,
    fontWeight: '500' as const,
    color: '#1e293b',
  },
  emptyState: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600' as const,
    color: '#1e293b',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
  },
});


--- END OF FILE: components/accounts/ExportJobsList.tsx ---


================================================================================
CATEGORY: Utility Files
FILE: utils/agreedTimesheetManager.ts
================================================================================

import { collection, doc, setDoc, getDoc, getDocs, query, where, Timestamp, updateDoc, deleteDoc } from 'firebase/firestore';
import { db } from '@/config/firebase';
import { AgreedTimesheet, OperatorTimesheet, PlantAssetTimesheet } from '@/types';
import { calculateBillableHours, BillingConfigForCalculation } from './billableHoursCalculator';

type CreateAgreedTimesheetParams = {
  originalTimesheetId: string;
  timesheetType: 'operator' | 'plant_asset';
  date: string;
  operatorId?: string;
  operatorName?: string;
  assetId?: string;
  assetType?: string;
  originalHours: number;
  agreedHours: number;
  billableHours?: number;
  billingRule?: string;
  originalNotes?: string;
  adminNotes?: string;
  siteId?: string;
  siteName?: string;
  masterAccountId: string;
  companyId?: string;
  subcontractorId?: string;
  subcontractorName?: string;
  agreedBy: string;
  agreedByRole?: 'Operator' | 'Plant Manager' | 'Admin';
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  originalNormalHours?: number;
  originalOvertimeHours?: number;
  originalSundayHours?: number;
  originalPublicHolidayHours?: number;
  originalOpenHours?: number;
  originalCloseHours?: number;
  isBreakdown?: boolean;
  isRainDay?: boolean;
  isInclementWeather?: boolean;
  isPublicHoliday?: boolean;
};

export async function createAgreedTimesheet(params: CreateAgreedTimesheetParams): Promise<string> {
  console.log('[agreedTimesheetManager] Creating agreed timesheet:', params);

  const agreedTimesheetRef = doc(collection(db, 'agreedTimesheets'));
  const agreedTimesheetId = agreedTimesheetRef.id;

  const hoursDifference = params.agreedHours - params.originalHours;

  const agreedTimesheet: AgreedTimesheet = {
    id: agreedTimesheetId,
    originalTimesheetId: params.originalTimesheetId,
    timesheetType: params.timesheetType,
    date: params.date,
    operatorId: params.operatorId,
    operatorName: params.operatorName,
    assetId: params.assetId,
    assetType: params.assetType,
    originalHours: params.originalHours,
    agreedHours: params.agreedHours,
    billableHours: params.billableHours,
    billingRule: params.billingRule,
    hoursDifference,
    originalNotes: params.originalNotes,
    adminNotes: params.adminNotes,
    siteId: params.siteId,
    siteName: params.siteName,
    masterAccountId: params.masterAccountId,
    companyId: params.companyId,
    subcontractorId: params.subcontractorId,
    subcontractorName: params.subcontractorName,
    originalOpenHours: params.originalOpenHours,
    originalCloseHours: params.originalCloseHours,
    isBreakdown: params.isBreakdown,
    isRainDay: params.isRainDay,
    isInclementWeather: params.isInclementWeather,
    isPublicHoliday: params.isPublicHoliday,
    status: 'approved_for_billing',
    agreedAt: Timestamp.now(),
    agreedBy: params.agreedBy,
    agreedByRole: params.agreedByRole,
    approvedForBillingAt: Timestamp.now(),
    approvedForBillingBy: params.agreedBy,
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };

  await setDoc(agreedTimesheetRef, agreedTimesheet);

  console.log('[agreedTimesheetManager] Agreed timesheet created:', agreedTimesheetId);
  return agreedTimesheetId;
}

export async function updateAgreedTimesheet(
  agreedTimesheetId: string,
  updates: Partial<AgreedTimesheet>
): Promise<void> {
  console.log('[agreedTimesheetManager] Updating agreed timesheet:', agreedTimesheetId);

  const agreedTimesheetRef = doc(db, 'agreedTimesheets', agreedTimesheetId);
  
  await updateDoc(agreedTimesheetRef, {
    ...updates,
    updatedAt: Timestamp.now(),
  });

  console.log('[agreedTimesheetManager] Agreed timesheet updated');
}

export async function getAgreedTimesheet(agreedTimesheetId: string): Promise<AgreedTimesheet | null> {
  const agreedTimesheetRef = doc(db, 'agreedTimesheets', agreedTimesheetId);
  const agreedTimesheetSnap = await getDoc(agreedTimesheetRef);

  if (!agreedTimesheetSnap.exists()) {
    return null;
  }

  return { id: agreedTimesheetSnap.id, ...agreedTimesheetSnap.data() } as AgreedTimesheet;
}

export async function getAgreedTimesheetsByDateRange(
  masterAccountId: string,
  startDate: string,
  endDate: string
): Promise<AgreedTimesheet[]> {
  console.log('[agreedTimesheetManager] Fetching agreed timesheets:', { masterAccountId, startDate, endDate });

  const agreedTimesheetsQuery = query(
    collection(db, 'agreedTimesheets'),
    where('masterAccountId', '==', masterAccountId),
    where('date', '>=', startDate),
    where('date', '<=', endDate),
    where('status', '==', 'approved_for_billing')
  );

  const querySnapshot = await getDocs(agreedTimesheetsQuery);
  const agreedTimesheets: AgreedTimesheet[] = [];

  querySnapshot.forEach((doc) => {
    agreedTimesheets.push({ id: doc.id, ...doc.data() } as AgreedTimesheet);
  });

  console.log('[agreedTimesheetManager] Found agreed timesheets:', agreedTimesheets.length);
  return agreedTimesheets;
}

export async function getAgreedTimesheetByOriginalId(originalTimesheetId: string): Promise<AgreedTimesheet | null> {
  console.log('[agreedTimesheetManager] Checking if agreed timesheet exists for:', originalTimesheetId);

  const agreedTimesheetsQuery = query(
    collection(db, 'agreedTimesheets'),
    where('originalTimesheetId', '==', originalTimesheetId)
  );

  const querySnapshot = await getDocs(agreedTimesheetsQuery);

  if (querySnapshot.empty) {
    return null;
  }

  const doc = querySnapshot.docs[0];
  return { id: doc.id, ...doc.data() } as AgreedTimesheet;
}

export async function deleteAgreedTimesheet(agreedTimesheetId: string): Promise<void> {
  console.log('[agreedTimesheetManager] Deleting agreed timesheet:', agreedTimesheetId);

  const agreedTimesheetRef = doc(db, 'agreedTimesheets', agreedTimesheetId);
  await deleteDoc(agreedTimesheetRef);

  console.log('[agreedTimesheetManager] Agreed timesheet deleted');
}

export async function agreeOperatorTimesheet(
  originalTimesheet: OperatorTimesheet,
  agreedData: {
    agreedNormalHours?: number;
    agreedOvertimeHours?: number;
    agreedSundayHours?: number;
    agreedPublicHolidayHours?: number;
    agreedNotes?: string;
  },
  agreedBy: string
): Promise<string> {
  console.log('[agreedTimesheetManager] Creating agreed operator timesheet:', originalTimesheet.id);

  const totalAgreedHours = 
    (agreedData.agreedNormalHours || 0) +
    (agreedData.agreedOvertimeHours || 0) +
    (agreedData.agreedSundayHours || 0) +
    (agreedData.agreedPublicHolidayHours || 0);

  const params: CreateAgreedTimesheetParams = {
    originalTimesheetId: originalTimesheet.id!,
    timesheetType: 'operator',
    date: originalTimesheet.date,
    operatorId: originalTimesheet.operatorId,
    operatorName: originalTimesheet.operatorName,
    originalHours: originalTimesheet.totalManHours || 0,
    agreedHours: totalAgreedHours,
    originalNotes: originalTimesheet.notes,
    adminNotes: agreedData.agreedNotes,
    siteId: originalTimesheet.siteId,
    siteName: originalTimesheet.siteName,
    masterAccountId: originalTimesheet.masterAccountId,
    companyId: originalTimesheet.companyId,
    agreedBy,
    agreedNormalHours: agreedData.agreedNormalHours,
    agreedOvertimeHours: agreedData.agreedOvertimeHours,
    agreedSundayHours: agreedData.agreedSundayHours,
    agreedPublicHolidayHours: agreedData.agreedPublicHolidayHours,
    originalNormalHours: originalTimesheet.normalHours,
    originalOvertimeHours: originalTimesheet.overtimeHours,
    originalSundayHours: originalTimesheet.sundayHours,
    originalPublicHolidayHours: originalTimesheet.publicHolidayHours,
  };

  const agreedTimesheetId = await createAgreedTimesheet(params);

  await updateDoc(doc(db, 'operatorTimesheets', originalTimesheet.id!), {
    agreedNormalHours: agreedData.agreedNormalHours,
    agreedOvertimeHours: agreedData.agreedOvertimeHours,
    agreedSundayHours: agreedData.agreedSundayHours,
    agreedPublicHolidayHours: agreedData.agreedPublicHolidayHours,
    agreedNotes: agreedData.agreedNotes,
    hasAgreedHours: true,
    agreedTimesheetId,
    updatedAt: Timestamp.now(),
  });

  console.log('[agreedTimesheetManager] Operator timesheet agreed:', agreedTimesheetId);
  return agreedTimesheetId;
}

export async function agreePlantAssetTimesheet(
  originalTimesheet: PlantAssetTimesheet,
  agreedData: {
    agreedHours?: number;
    agreedNotes?: string;
    isBreakdown?: boolean;
    isRainDay?: boolean;
    isInclementWeather?: boolean;
    isPublicHoliday?: boolean;
  },
  agreedBy: string,
  approvalType?: 'digital' | 'admin_direct',
  agreedByRole?: 'Operator' | 'Plant Manager' | 'Admin',
  billingConfig?: BillingConfigForCalculation
): Promise<string> {
  console.log('[agreedTimesheetManager] Creating agreed plant asset timesheet:', originalTimesheet.id, 'type:', approvalType || 'digital', 'role:', agreedByRole || 'Admin');
  console.log('[agreedTimesheetManager] Original meter readings - open:', originalTimesheet.openHours, 'close:', originalTimesheet.closeHours);
  console.log('[agreedTimesheetManager] Agreed hours:', agreedData.agreedHours);

  let billableHours: number | undefined;
  let billingRule: string | undefined;

  if (billingConfig && agreedData.agreedHours) {
    console.log('[agreedTimesheetManager] ===== CALCULATING BILLABLE HOURS AT APPROVAL TIME =====');
    const result = calculateBillableHours(
      {
        startTime: 0,
        endTime: agreedData.agreedHours,
        date: originalTimesheet.date,
        openHours: 0,
        closeHours: agreedData.agreedHours,
        totalHours: agreedData.agreedHours,
        isBreakdown: agreedData.isBreakdown || originalTimesheet.logBreakdown,
        isRainDay: agreedData.isRainDay || originalTimesheet.inclementWeather,
        isInclementWeather: agreedData.isInclementWeather || originalTimesheet.inclementWeather,
        isPublicHoliday: agreedData.isPublicHoliday,
      },
      billingConfig
    );
    billableHours = result.billableHours;
    billingRule = result.appliedRule;
    console.log('[agreedTimesheetManager] Calculated billable hours:', billableHours, 'rule:', billingRule);
    console.log('[agreedTimesheetManager] ===== BILLABLE HOURS WILL BE STORED IN AGREED TIMESHEET =====');
  } else {
    console.warn('[agreedTimesheetManager] No billing config provided - billable hours not calculated');
  }

  const params: CreateAgreedTimesheetParams = {
    originalTimesheetId: originalTimesheet.id!,
    timesheetType: 'plant_asset',
    date: originalTimesheet.date,
    assetId: originalTimesheet.assetId,
    assetType: 'Plant Asset',
    operatorId: originalTimesheet.operatorId,
    operatorName: originalTimesheet.operatorName,
    originalHours: originalTimesheet.totalHours || 0,
    agreedHours: agreedData.agreedHours!,
    billableHours,
    billingRule,
    originalNotes: originalTimesheet.notes,
    adminNotes: agreedData.agreedNotes,
    siteId: originalTimesheet.siteId,
    siteName: originalTimesheet.siteName,
    masterAccountId: originalTimesheet.masterAccountId,
    companyId: originalTimesheet.companyId,
    agreedBy,
    agreedByRole: agreedByRole || 'Admin',
    originalOpenHours: originalTimesheet.openHours,
    originalCloseHours: originalTimesheet.closeHours,
    isBreakdown: agreedData.isBreakdown || originalTimesheet.logBreakdown,
    isRainDay: agreedData.isRainDay || originalTimesheet.inclementWeather,
    isInclementWeather: agreedData.isInclementWeather || originalTimesheet.inclementWeather,
    isPublicHoliday: agreedData.isPublicHoliday,
  };

  const agreedTimesheetId = await createAgreedTimesheet(params);

  await updateDoc(doc(db, 'plantAssetTimesheets', originalTimesheet.id!), {
    agreedHours: agreedData.agreedHours,
    agreedNotes: agreedData.agreedNotes,
    hasAgreedHours: true,
    agreedTimesheetId,
    approvalType: approvalType || 'digital',
    updatedAt: Timestamp.now(),
  });

  console.log('[agreedTimesheetManager] Plant asset timesheet agreed:', agreedTimesheetId);
  return agreedTimesheetId;
}

export async function directApproveEPHTimesheets(
  timesheets: PlantAssetTimesheet[],
  agreedBy: string,
  adminNotes?: string,
  agreedByRole?: 'Operator' | 'Plant Manager' | 'Admin',
  billingConfig?: BillingConfigForCalculation
): Promise<string[]> {
  console.log('[agreedTimesheetManager] Direct approving', timesheets.length, 'timesheets', 'role:', agreedByRole || 'Admin');
  
  const agreedIds: string[] = [];
  
  for (const timesheet of timesheets) {
    const agreedId = await agreePlantAssetTimesheet(
      timesheet,
      {
        agreedHours: timesheet.totalHours,
        agreedNotes: adminNotes,
        isBreakdown: timesheet.logBreakdown,
        isRainDay: timesheet.inclementWeather,
        isInclementWeather: timesheet.inclementWeather,
      },
      agreedBy,
      'admin_direct',
      agreedByRole || 'Admin',
      billingConfig
    );
    agreedIds.push(agreedId);
  }
  
  console.log('[agreedTimesheetManager] Direct approved', agreedIds.length, 'timesheets');
  return agreedIds;
}


--- END OF FILE: utils/agreedTimesheetManager.ts ---


================================================================================
CATEGORY: Utility Files
FILE: utils/timesheetPdfGenerator.ts
================================================================================

import * as Print from 'expo-print';
import * as MailComposer from 'expo-mail-composer';
import { Platform, Alert } from 'react-native';
import * as Sharing from 'expo-sharing';

type VerifiedTimesheet = {
  id: string;
  date: string;
  operatorName: string;
  operatorId: string;
  verified: boolean;
  verifiedAt: string;
  verifiedBy: string;
  masterAccountId: string;
  siteId: string;
  type: 'plant_hours' | 'man_hours';
  
  openHours?: number;
  closeHours?: number;
  totalHours?: number;
  actualHours?: number;
  billableHours?: number;
  billingRule?: string;
  assetRate?: number;
  totalCost?: number;
  isBreakdown?: boolean;
  inclementWeather?: boolean;
  hasAttachment?: boolean;
  isRainDay?: boolean;
  isStrikeDay?: boolean;
  isPublicHoliday?: boolean;
  notes?: string;
  
  assetId?: string;
  assetType?: string;
  plantNumber?: string;
  location?: string;
  registrationNumber?: string;
  ownerId?: string;
  ownerType?: string;
  ownerName?: string;
  
  startTime?: string;
  stopTime?: string;
  totalManHours?: number;
  normalHours?: number;
  overtimeHours?: number;
  sundayHours?: number;
  publicHolidayHours?: number;
  noLunchBreak?: boolean;
  
  hasOriginalEntry?: boolean;
  originalEntryData?: any;
  isAdjustment?: boolean;
  originalEntryId?: string;
  adjustedBy?: string;
  adjustedAt?: string;
  agreedByRole?: 'Admin' | 'Plant Manager' | 'Operator' | 'Subcontractor';
  
  agreedHours?: number;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  agreedBy?: string;
  agreedAt?: string;
  agreedNotes?: string;
  hasAgreedEntry?: boolean;
};

type TimesheetGroup = {
  key: string;
  title: string;
  subtitle: string;
  entries: VerifiedTimesheet[];
  dateGroups: {
    date: string;
    operatorEntry?: VerifiedTimesheet;
    plantManagerEntry?: VerifiedTimesheet;
    adminEntry?: VerifiedTimesheet;
    subcontractorEntry?: VerifiedTimesheet;
  }[];
};

type ReportOptions = {
  groups: TimesheetGroup[];
  reportType: 'plant' | 'man';
  subcontractorName?: string;
  dateRange: {
    from: Date;
    to: Date;
  };
  selectedOnly?: boolean;
  selectedGroups?: Set<string>;
};

const formatDate = (date: string | Date): string => {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleDateString('en-GB', {
    day: '2-digit',
    month: 'short',
    year: 'numeric',
  });
};

const generatePlantHoursHTML = (groups: TimesheetGroup[], options: ReportOptions): string => {
  const filteredGroups = options.selectedOnly && options.selectedGroups
    ? groups.filter(g => options.selectedGroups!.has(g.key))
    : groups;

  const formatStatusIcons = (e: any) => {
    const icons = [];
    if (e.isBreakdown) icons.push('');
    if (e.isRainDay || e.inclementWeather) icons.push('');
    if (e.isStrikeDay) icons.push('');
    if (e.isPublicHoliday) icons.push('');
    return icons.length > 0 ? icons.join(' ') : '-';
  };

  const formatCurrency = (value?: number) => {
    if (value === undefined || value === null) return '-';
    return `R${value.toFixed(2)}`;
  };

  // Get actual hours - use pre-calculated values from billing logic
  // DO NOT recalculate from meters - this has already been done correctly
  const getActualHours = (entry: any): number => {
    const actualHours = entry?.actualHours ?? entry?.agreedHours ?? entry?.totalHours ?? 0;
    return actualHours;
  };

  const groupsByAssetType = new Map<string, TimesheetGroup[]>();
  filteredGroups.forEach(group => {
    const assetType = group.title || 'Unknown';
    if (!groupsByAssetType.has(assetType)) {
      groupsByAssetType.set(assetType, []);
    }
    groupsByAssetType.get(assetType)!.push(group);
  });

  const getHighestPriorityEntry = (dateGroup: any): any => {
    if (dateGroup.adminEntry) return dateGroup.adminEntry;
    if (dateGroup.plantManagerEntry) return dateGroup.plantManagerEntry;
    if (dateGroup.operatorEntry) return dateGroup.operatorEntry;
    return null;
  };

  const assetTypeSubtotals = new Map<string, { actual: number; billable: number; cost: number }>();
  groupsByAssetType.forEach((groups, assetType) => {
    const subtotalActual = groups.reduce((sum, group) => {
      return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
        const entry = getHighestPriorityEntry(dateGroup);
        if (!entry) return groupSum;
        return groupSum + getActualHours(entry);
      }, 0);
    }, 0);
    const subtotalBillable = groups.reduce((sum, group) => {
      return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
        const entry = getHighestPriorityEntry(dateGroup);
        if (!entry) return groupSum;
        return groupSum + (entry?.billableHours || 0);
      }, 0);
    }, 0);
    const subtotalCost = groups.reduce((sum, group) => {
      return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
        const entry = getHighestPriorityEntry(dateGroup);
        if (!entry) return groupSum;
        return groupSum + (entry?.totalCost || 0);
      }, 0);
    }, 0);
    assetTypeSubtotals.set(assetType, { actual: subtotalActual, billable: subtotalBillable, cost: subtotalCost });
  });

  const rows: string[] = [];
  
  groupsByAssetType.forEach((groups, assetType) => {
    groups.forEach(group => {
      const assetRows = group.dateGroups.map(dateGroup => {
        const entries = [];
        
        if (dateGroup.operatorEntry) {
          const e = dateGroup.operatorEntry;
          entries.push(`
            <tr style="background-color: #f8f9fa;">
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${formatDate(e.date)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.title}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.subtitle}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px; text-align: center;">${e.location || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6;">${e.operatorName}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.openHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.closeHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${getActualHours(e).toFixed(1)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #10b981;">${e.billableHours?.toFixed(1) || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${formatCurrency(e.assetRate)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #1e3a8a;">${formatCurrency(e.totalCost)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.isBreakdown ? '' : '-'}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.inclementWeather || e.isRainDay ? '' : '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${formatStatusIcons(e)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; font-size: 10px;">${e.notes || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
                <span style="background-color: #6c757d; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ORIG</span><br/>
                <span style="font-size: 9px; color: #6c757d;">${e.operatorName}</span>
              </td>
            </tr>
          `);
        }
        
        if (dateGroup.plantManagerEntry) {
          const e = dateGroup.plantManagerEntry;
          entries.push(`
            <tr style="background-color: #dbeafe;">
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${formatDate(e.date)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.title}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.subtitle}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px; text-align: center;">${e.location || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6;">${e.operatorName}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.openHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.closeHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${getActualHours(e).toFixed(1)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #10b981;">${e.billableHours?.toFixed(1) || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${formatCurrency(e.assetRate)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #1e3a8a;">${formatCurrency(e.totalCost)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.isBreakdown ? '' : '-'}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.inclementWeather || e.isRainDay ? '' : '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${formatStatusIcons(e)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; font-size: 10px;">${e.notes || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
                <span style="background-color: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">PM</span><br/>
                <span style="font-size: 9px; color: #1e40af;">${e.agreedBy || 'PM'}</span>
              </td>
            </tr>
          `);
        }
        
        if (dateGroup.adminEntry) {
          const e = dateGroup.adminEntry;
          entries.push(`
            <tr style="background-color: #fef3c7;">
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${formatDate(e.date)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.title}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.subtitle}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px; text-align: center;">${e.location || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6;">${e.operatorName}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.openHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.closeHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${getActualHours(e).toFixed(1)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #10b981;">${e.billableHours?.toFixed(1) || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${formatCurrency(e.assetRate)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #1e3a8a;">${formatCurrency(e.totalCost)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.isBreakdown ? '' : '-'}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px;">${e.inclementWeather || e.isRainDay ? '' : '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${formatStatusIcons(e)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; font-size: 10px;">${e.notes || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
                <span style="background-color: #f59e0b; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ADMIN</span><br/>
                <span style="font-size: 9px; color: #92400e;">${e.agreedBy || 'Admin'}</span>
              </td>
            </tr>
          `);
        }
        
        if (dateGroup.subcontractorEntry) {
          const e = dateGroup.subcontractorEntry;
          entries.push(`
            <tr style="background-color: #e0f2fe;">
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${formatDate(e.date)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.title}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px;">${group.subtitle}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; font-size: 9px; text-align: center;">${e.location || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6;">${e.operatorName}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.openHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.closeHours ?? '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; font-style: italic;">${getActualHours(e).toFixed(1)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #10b981; font-style: italic;">${e.billableHours?.toFixed(1) || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${formatCurrency(e.assetRate)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; color: #1e3a8a; font-style: italic;">${formatCurrency(e.totalCost)}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px; font-style: italic;">${e.isBreakdown ? '' : '-'}</td>
              <td style="padding: 6px 4px; border: 1px solid #dee2e6; text-align: center; font-size: 11px; font-style: italic;">${e.inclementWeather || e.isRainDay ? '' : '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">${formatStatusIcons(e)}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; font-size: 10px; font-style: italic;">${e.notes || '-'}</td>
              <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
                <span style="background-color: #0ea5e9; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">SUB</span><br/>
                <span style="font-size: 9px; color: #075985;">${e.agreedBy || 'Sub'}</span>
              </td>
            </tr>
          `);
        }
        
        return entries.join('');
      }).join('');

      rows.push(assetRows);
    });

    const subtotal = assetTypeSubtotals.get(assetType) || { actual: 0, billable: 0, cost: 0 };
    const assetCount = groups.length;
    rows.push(`
      <tr style="background-color: #e0f2fe; border-top: 2px solid #0ea5e9;">
        <td colspan="7" style="padding: 10px 8px; border: 1px solid #dee2e6; font-weight: 700; color: #0c4a6e; font-size: 12px;">
          ${assetType} Subtotal (${assetCount} asset${assetCount > 1 ? 's' : ''})
        </td>
        <td style="padding: 10px 8px; border: 1px solid #dee2e6; text-align: right; font-weight: 700; color: #0c4a6e; font-size: 13px;">
          ${subtotal.actual.toFixed(1)}h
        </td>
        <td style="padding: 10px 8px; border: 1px solid #dee2e6; text-align: right; font-weight: 700; color: #10b981; font-size: 13px;">
          ${subtotal.billable.toFixed(1)}h
        </td>
        <td style="padding: 10px 8px; border: 1px solid #dee2e6; text-align: right;"></td>
        <td style="padding: 10px 8px; border: 1px solid #dee2e6; text-align: right; font-weight: 700; color: #dc2626; font-size: 13px;">
          ${formatCurrency(subtotal.cost)}
        </td>
        <td colspan="5" style="padding: 10px 8px; border: 1px solid #dee2e6;"></td>
      </tr>
    `);
  });

  const totalHours = filteredGroups.reduce((sum, group) => {
    return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
      const entry = getHighestPriorityEntry(dateGroup);
      if (!entry) return groupSum;
      return groupSum + getActualHours(entry);
    }, 0);
  }, 0);

  const totalBillableHours = filteredGroups.reduce((sum, group) => {
    return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
      const entry = getHighestPriorityEntry(dateGroup);
      if (!entry) return groupSum;
      return groupSum + (entry?.billableHours || 0);
    }, 0);
  }, 0);

  const totalCost = filteredGroups.reduce((sum, group) => {
    return sum + group.dateGroups.reduce((groupSum, dateGroup) => {
      const entry = getHighestPriorityEntry(dateGroup);
      if (!entry) return groupSum;
      return groupSum + (entry?.totalCost || 0);
    }, 0);
  }, 0);

  return `
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.4;
            color: #212529;
            margin: 20px;
          }
          h1 {
            font-size: 22px;
            margin-bottom: 10px;
            color: #1e3a8a;
          }
          .meta {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 20px;
          }
          table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 10px;
          }
          th {
            background-color: #1e3a8a;
            color: white;
            padding: 8px 6px;
            text-align: left;
            border: 1px solid #dee2e6;
            font-weight: 600;
            font-size: 10px;
          }
          td {
            padding: 6px;
            border: 1px solid #dee2e6;
          }
          .summary {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
          }
          .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
          }
          .summary-label {
            font-weight: 600;
          }
          .footer {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 2px solid #dee2e6;
            font-size: 10px;
            color: #6c757d;
          }
        </style>
      </head>
      <body>
        <h1>Plant Hours Timesheet Report</h1>
        <div class="meta">
          ${options.subcontractorName ? `<p><strong>Subcontractor:</strong> ${options.subcontractorName}</p>` : ''}
          <p><strong>Date Range:</strong> ${formatDate(options.dateRange.from)} to ${formatDate(options.dateRange.to)}</p>
          <p><strong>Report Generated:</strong> ${formatDate(new Date())}</p>
          ${options.selectedOnly ? '<p><strong>Report Type:</strong> Selected Assets Only</p>' : '<p><strong>Report Type:</strong> All Assets</p>'}
        </div>
        
        <table>
          <thead>
            <tr>
              <th style="width: 45px; padding: 6px 4px; font-size: 9px;">Date</th>
              <th style="width: 55px; padding: 6px 4px; font-size: 9px;">Asset Type</th>
              <th style="width: 45px; padding: 6px 4px; font-size: 9px;">Asset Number</th>
              <th style="width: 40px; padding: 6px 4px; text-align: center; font-size: 9px;">Site ID</th>
              <th style="font-size: 9px;">Operator</th>
              <th style="text-align: right; width: 35px; padding: 6px 4px; font-size: 9px;">Open</th>
              <th style="text-align: right; width: 35px; padding: 6px 4px; font-size: 9px;">Close</th>
              <th style="text-align: right; width: 38px; padding: 6px 4px; font-size: 9px;">Actual</th>
              <th style="text-align: right; width: 38px; padding: 6px 4px; font-size: 9px;">Billable</th>
              <th style="text-align: right; width: 42px; padding: 6px 4px; font-size: 9px;">Rate</th>
              <th style="text-align: right; width: 48px; padding: 6px 4px; font-size: 9px;">Cost</th>
              <th style="text-align: center; width: 35px; padding: 6px 4px; font-size: 9px;">BrkDn</th>
              <th style="text-align: center; width: 35px; padding: 6px 4px; font-size: 9px;">Weather</th>
              <th style="text-align: center; font-size: 9px;">Status</th>
              <th style="font-size: 9px;">Notes</th>
              <th style="text-align: center; font-size: 9px;">Type</th>
            </tr>
          </thead>
          <tbody>
            ${rows.join('')}
          </tbody>
        </table>

        <div class="summary">
          <div class="summary-row">
            <span class="summary-label">Total Assets:</span>
            <span>${filteredGroups.length}</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Days:</span>
            <span>${filteredGroups.reduce((sum, g) => sum + g.dateGroups.length, 0)}</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Actual Hours:</span>
            <span><strong>${totalHours.toFixed(1)} hours</strong></span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Billable Hours:</span>
            <span style="color: #10b981;"><strong>${totalBillableHours.toFixed(1)} hours</strong></span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Cost:</span>
            <span><strong>R${totalCost.toFixed(2)}</strong></span>
          </div>
        </div>

        <div class="footer">
          <p>This report was automatically generated from the approved billing timesheets.</p>
          <p><strong>Legend:</strong></p>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li>ORIG = Operator Original Entry (gray background)</li>
            <li>PM = Plant Manager Edit (blue background)</li>
            <li>ADMIN = Admin Edit (yellow background)</li>
            <li>SUB = Subcontractor Review (light blue background, <em>italics</em>)</li>
          </ul>
          <p><strong>Hierarchy:</strong> When multiple entries exist for the same date, totals use: <strong>Admin &gt; Plant Manager &gt; Operator</strong>. Subcontractor entries are shown for reference only and never counted in totals.</p>
          <p><strong>Status Icons:</strong>  = Breakdown,  = Rain Day,  = Strike Day,  = Public Holiday</p>
          <p><strong>Billing Toggles:</strong> BrkDn = Breakdown (affects billing), Weather = Inclement Weather/Rain Day (affects billing)</p>
          <p><strong>Billing:</strong> Actual hours show recorded hours. Billable hours reflect minimum billing rules and rate multipliers based on day type and conditions. Cost = Billable hours  Rate.</p>
        </div>
      </body>
    </html>
  `;
};

const generateManHoursHTML = (groups: TimesheetGroup[], options: ReportOptions): string => {
  const filteredGroups = options.selectedOnly && options.selectedGroups
    ? groups.filter(g => options.selectedGroups!.has(g.key))
    : groups;

  const getHighestPriorityEntry = (dateGroup: any): any => {
    if (dateGroup.adminEntry) return dateGroup.adminEntry;
    if (dateGroup.plantManagerEntry) return dateGroup.plantManagerEntry;
    if (dateGroup.operatorEntry) return dateGroup.operatorEntry;
    return null;
  };

  const rows = filteredGroups.map(group => {
    const operatorRows = group.dateGroups.map(dateGroup => {
      const entries = [];
      
      if (dateGroup.operatorEntry) {
        const e = dateGroup.operatorEntry;
        entries.push(`
          <tr style="background-color: #f8f9fa;">
            <td style="padding: 8px; border: 1px solid #dee2e6;">${formatDate(e.date)}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${group.title}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.startTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.stopTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${e.totalManHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.normalHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.overtimeHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.sundayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.publicHolidayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
              <span style="background-color: #6c757d; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ORIG</span>
            </td>
          </tr>
        `);
      }
      
      if (dateGroup.plantManagerEntry) {
        const e = dateGroup.plantManagerEntry;
        entries.push(`
          <tr style="background-color: #dbeafe;">
            <td style="padding: 8px; border: 1px solid #dee2e6;">${formatDate(e.date)}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${group.title}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.startTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.stopTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${e.totalManHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.normalHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.overtimeHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.sundayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.publicHolidayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
              <span style="background-color: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">PM</span>
            </td>
          </tr>
        `);
      }
      
      if (dateGroup.adminEntry) {
        const e = dateGroup.adminEntry;
        entries.push(`
          <tr style="background-color: #fef3c7;">
            <td style="padding: 8px; border: 1px solid #dee2e6;">${formatDate(e.date)}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${group.title}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.startTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.stopTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold;">${e.totalManHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.normalHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.overtimeHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.sundayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right;">${e.publicHolidayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
              <span style="background-color: #f59e0b; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ADMIN</span>
            </td>
          </tr>
        `);
      }
      
      if (dateGroup.subcontractorEntry) {
        const e = dateGroup.subcontractorEntry;
        entries.push(`
          <tr style="background-color: #e0f2fe;">
            <td style="padding: 8px; border: 1px solid #dee2e6;">${formatDate(e.date)}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${group.title}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.startTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6;">${e.stopTime || '-'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-weight: bold; font-style: italic;">${e.totalManHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-style: italic;">${e.normalHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-style: italic;">${e.overtimeHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-style: italic;">${e.sundayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: right; font-style: italic;">${e.publicHolidayHours?.toFixed(1) || '0.0'}</td>
            <td style="padding: 8px; border: 1px solid #dee2e6; text-align: center;">
              <span style="background-color: #0ea5e9; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">SUB</span>
            </td>
          </tr>
        `);
      }
      
      return entries.join('');
    }).join('');

    return operatorRows;
  }).join('');

  const totals = filteredGroups.reduce((sum, group) => {
    const groupTotals = group.dateGroups.reduce((gSum, dateGroup) => {
      const entry = getHighestPriorityEntry(dateGroup);
      return {
        total: gSum.total + (entry?.totalManHours || 0),
        normal: gSum.normal + (entry?.normalHours || 0),
        overtime: gSum.overtime + (entry?.overtimeHours || 0),
        sunday: gSum.sunday + (entry?.sundayHours || 0),
        publicHoliday: gSum.publicHoliday + (entry?.publicHolidayHours || 0),
      };
    }, { total: 0, normal: 0, overtime: 0, sunday: 0, publicHoliday: 0 });
    
    return {
      total: sum.total + groupTotals.total,
      normal: sum.normal + groupTotals.normal,
      overtime: sum.overtime + groupTotals.overtime,
      sunday: sum.sunday + groupTotals.sunday,
      publicHoliday: sum.publicHoliday + groupTotals.publicHoliday,
    };
  }, { total: 0, normal: 0, overtime: 0, sunday: 0, publicHoliday: 0 });

  return `
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            line-height: 1.4;
            color: #212529;
            margin: 20px;
          }
          h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #1e3a8a;
          }
          .meta {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 20px;
          }
          table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
          }
          th {
            background-color: #1e3a8a;
            color: white;
            padding: 10px 8px;
            text-align: left;
            border: 1px solid #dee2e6;
            font-weight: 600;
          }
          td {
            padding: 8px;
            border: 1px solid #dee2e6;
          }
          .summary {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
          }
          .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
          }
          .summary-label {
            font-weight: 600;
          }
          .footer {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 2px solid #dee2e6;
            font-size: 10px;
            color: #6c757d;
          }
        </style>
      </head>
      <body>
        <h1>Man Hours Timesheet Report</h1>
        <div class="meta">
          ${options.subcontractorName ? `<p><strong>Subcontractor:</strong> ${options.subcontractorName}</p>` : ''}
          <p><strong>Date Range:</strong> ${formatDate(options.dateRange.from)} to ${formatDate(options.dateRange.to)}</p>
          <p><strong>Report Generated:</strong> ${formatDate(new Date())}</p>
          ${options.selectedOnly ? '<p><strong>Report Type:</strong> Selected Operators Only</p>' : '<p><strong>Report Type:</strong> All Operators</p>'}
        </div>
        
        <table>
          <thead>
            <tr>
              <th>Date</th>
              <th>Operator</th>
              <th>Start Time</th>
              <th>Stop Time</th>
              <th style="text-align: right;">Total</th>
              <th style="text-align: right;">Normal</th>
              <th style="text-align: right;">Overtime</th>
              <th style="text-align: right;">Sunday</th>
              <th style="text-align: right;">Public Holiday</th>
              <th style="text-align: center;">Type</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>

        <div class="summary">
          <div class="summary-row">
            <span class="summary-label">Total Operators:</span>
            <span>${filteredGroups.length}</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Days:</span>
            <span>${filteredGroups.reduce((sum, g) => sum + g.dateGroups.length, 0)}</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Total Hours:</span>
            <span><strong>${totals.total.toFixed(1)} hours</strong></span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Normal Hours:</span>
            <span>${totals.normal.toFixed(1)} hours</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Overtime Hours:</span>
            <span>${totals.overtime.toFixed(1)} hours</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Sunday Hours:</span>
            <span>${totals.sunday.toFixed(1)} hours</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Public Holiday Hours:</span>
            <span>${totals.publicHoliday.toFixed(1)} hours</span>
          </div>
        </div>

        <div class="footer">
          <p>This report was automatically generated from the approved billing timesheets.</p>
          <p><strong>Legend:</strong></p>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li>ORIG = Operator Original Entry (gray background)</li>
            <li>PM = Plant Manager Edit (blue background)</li>
            <li>ADMIN = Admin Edit (yellow background)</li>
            <li>SUB = Subcontractor Review (light blue background, <em>italics</em>)</li>
          </ul>
          <p><strong>Hierarchy:</strong> When multiple entries exist for the same date, totals use: <strong>Admin &gt; Plant Manager &gt; Operator</strong>. Subcontractor entries are shown for reference only and never counted in totals.</p>
        </div>
      </body>
    </html>
  `;
};

export async function generateTimesheetPDF(options: ReportOptions): Promise<{ uri: string; fileName: string }> {
  console.log('[timesheetPdfGenerator] Generating PDF report:', options.reportType);
  
  try {
    const html = options.reportType === 'plant' 
      ? generatePlantHoursHTML(options.groups, options)
      : generateManHoursHTML(options.groups, options);

    const fileName = `${options.reportType}_hours_report_${formatDate(new Date()).replace(/\s/g, '_')}.pdf`;

    if (Platform.OS === 'web') {
      console.log('[timesheetPdfGenerator] Web platform - creating data URI from HTML');
      const blob = new Blob([html], { type: 'text/html' });
      const uri = URL.createObjectURL(blob);
      console.log('[timesheetPdfGenerator] HTML blob created for web:', uri);
      return { uri, fileName: fileName.replace('.pdf', '.html') };
    }

    console.log('[timesheetPdfGenerator] Native platform - generating PDF');
    const result = await Print.printToFileAsync({
      html,
      base64: false,
    });

    if (!result || !result.uri) {
      console.error('[timesheetPdfGenerator] Print.printToFileAsync returned invalid result:', result);
      throw new Error('PDF generation failed - no URI returned');
    }

    console.log('[timesheetPdfGenerator] PDF generated successfully:', result.uri);

    return { uri: result.uri, fileName };
  } catch (error) {
    console.error('[timesheetPdfGenerator] Error generating PDF:', error);
    throw new Error('Failed to generate PDF report');
  }
}

export async function emailTimesheetPDF(
  pdfUri: string,
  fileName: string,
  options: {
    recipientEmail?: string;
    subject?: string;
    body?: string;
  } = {}
): Promise<void> {
  console.log('[timesheetPdfGenerator] Preparing email with PDF attachment');

  try {
    const isAvailable = await MailComposer.isAvailableAsync();
    
    if (!isAvailable) {
      Alert.alert(
        'Email Not Available',
        Platform.OS === 'web' 
          ? 'Email functionality is not available in web browsers. Please download the PDF and send it manually.'
          : 'Email is not configured on this device. Please download the PDF and send it manually.'
      );
      return;
    }

    const defaultSubject = `Timesheet Report - ${formatDate(new Date())}`;
    const defaultBody = `Please find attached the timesheet report.\n\nGenerated on: ${formatDate(new Date())}`;

    await MailComposer.composeAsync({
      recipients: options.recipientEmail ? [options.recipientEmail] : [],
      subject: options.subject || defaultSubject,
      body: options.body || defaultBody,
      attachments: [pdfUri],
    });

    console.log('[timesheetPdfGenerator] Email composer opened successfully');
  } catch (error) {
    console.error('[timesheetPdfGenerator] Error opening email composer:', error);
    Alert.alert('Error', 'Failed to open email composer. Please try downloading the PDF instead.');
  }
}

export async function downloadTimesheetPDF(pdfUri: string, fileName: string): Promise<void> {
  console.log('[timesheetPdfGenerator] Downloading/Sharing file:', fileName);
  console.log('[timesheetPdfGenerator] URI:', pdfUri);
  console.log('[timesheetPdfGenerator] Platform:', Platform.OS);

  try {
    if (Platform.OS === 'web') {
      console.log('[timesheetPdfGenerator] Opening file in new window for web');
      const newWindow = window.open(pdfUri, '_blank');
      if (newWindow) {
        newWindow.focus();
        Alert.alert(
          'Report Generated',
          'The timesheet report has been opened in a new window. You can print it to PDF using your browser\'s print function (Ctrl/Cmd + P).'
        );
      } else {
        Alert.alert(
          'Popup Blocked',
          'Please allow popups for this site to view the report, or check your downloads folder.'
        );
      }
    } else {
      console.log('[timesheetPdfGenerator] Sharing PDF on native platform');
      const isAvailable = await Sharing.isAvailableAsync();
      
      if (isAvailable) {
        await Sharing.shareAsync(pdfUri, {
          UTI: 'application/pdf',
          mimeType: 'application/pdf',
          dialogTitle: 'Save or Share PDF',
        });
        console.log('[timesheetPdfGenerator] PDF shared successfully');
      } else {
        Alert.alert('Error', 'Sharing is not available on this device');
      }
    }
  } catch (error) {
    console.error('[timesheetPdfGenerator] Error downloading/sharing:', error);
    Alert.alert('Error', 'Failed to open or share the report. Please try again.');
  }
}


--- END OF FILE: utils/timesheetPdfGenerator.ts ---


================================================================================
CATEGORY: Utility Files
FILE: utils/timesheetExport.ts
================================================================================

import { 
  collection, 
  query, 
  where, 
  getDocs, 
  orderBy,
  collectionGroup
} from 'firebase/firestore';
import { db } from '@/config/firebase';
// Import for web export only as mobile file system is not available in current setup
import { Platform } from 'react-native';

interface ExportFilters {
  startDate: string;
  endDate: string;
  operatorId?: string;
  assetId?: string;
  masterAccountId: string;
  siteId?: string;
}

interface OperatorManHours {
  operatorId: string;
  operatorName: string;
  date: string;
  startTime: string;
  stopTime: string;
  lunchBreak: boolean;
  totalManHours: number;
  siteId?: string;
  siteName?: string;
  notes?: string;
  status?: string;
}

interface PlantAssetHours {
  assetId: string;
  assetType?: string;
  date: string;
  openHours: number;
  closeHours: number;
  totalHours: number;
  operatorId: string;
  operatorName: string;
  logBreakdown: {
    productive?: boolean;
    maintenance?: boolean;
    idle?: boolean;
    breakdown?: boolean;
    refueling?: boolean;
  };
  inclementWeather?: boolean;
  weatherNotes?: string;
  pvArea?: string;
  blockNumber?: string;
  notes?: string;
  fuelAmount?: number;
  fuelMeterReading?: number;
  fuelMeterType?: 'HOUR_METER' | 'ODOMETER';
  fuelConsumption?: number;
}

/**
 * Export operator man hours to CSV
 */
export async function exportOperatorManHours(filters: ExportFilters): Promise<string | null> {
  try {
    console.log('[TimesheetExport] Exporting operator man hours with filters:', filters);

    // Query operator timesheets
    const timesheetsRef = collection(db, 'operatorTimesheets');
    const constraints = [
      where('masterAccountId', '==', filters.masterAccountId),
      where('date', '>=', filters.startDate),
      where('date', '<=', filters.endDate),
      orderBy('date', 'desc'),
      orderBy('operatorName')
    ];

    if (filters.operatorId) {
      constraints.push(where('operatorId', '==', filters.operatorId));
    }
    
    if (filters.siteId) {
      constraints.push(where('siteId', '==', filters.siteId));
    }

    const timesheetsQuery = query(timesheetsRef, ...constraints);
    const snapshot = await getDocs(timesheetsQuery);

    const manHours: OperatorManHours[] = [];
    snapshot.forEach((doc) => {
      const data = doc.data();
      manHours.push({
        operatorId: data.operatorId,
        operatorName: data.operatorName,
        date: data.date,
        startTime: data.startTime,
        stopTime: data.stopTime,
        lunchBreak: data.lunchBreak || false,
        totalManHours: data.totalManHours,
        siteId: data.siteId,
        siteName: data.siteName,
        notes: data.notes,
        status: data.status
      });
    });

    if (manHours.length === 0) {
      console.log('[TimesheetExport] No man hours data found');
      return null;
    }

    // Generate CSV
    const csvHeader = 'Date,Operator Name,Operator ID,Start Time,Stop Time,Lunch Break,Total Man Hours,Site,Status,Notes\n';
    const csvRows = manHours.map(row => {
      const fields = [
        row.date,
        `"${row.operatorName}"`,
        row.operatorId,
        row.startTime,
        row.stopTime,
        row.lunchBreak ? 'Yes' : 'No',
        row.totalManHours.toFixed(2),
        `"${row.siteName || ''}"`,
        row.status || 'DRAFT',
        `"${row.notes?.replace(/"/g, '""') || ''}"`
      ];
      return fields.join(',');
    }).join('\n');

    const csv = csvHeader + csvRows;
    
    // Save and share file
    const fileName = `operator_man_hours_${filters.startDate}_to_${filters.endDate}.csv`;
    const filePath = await saveAndShareFile(csv, fileName);
    
    return filePath;
  } catch (error) {
    console.error('[TimesheetExport] Error exporting man hours:', error);
    throw error;
  }
}

/**
 * Export plant asset hours to CSV
 */
export async function exportPlantAssetHours(filters: ExportFilters): Promise<string | null> {
  try {
    console.log('[TimesheetExport] Exporting plant asset hours with filters:', filters);

    // Query plant asset timesheets using collection group
    const timesheetsRef = collectionGroup(db, 'timesheets');
    const constraints = [
      where('masterAccountId', '==', filters.masterAccountId),
      where('date', '>=', filters.startDate),
      where('date', '<=', filters.endDate),
      orderBy('date', 'desc')
    ];

    if (filters.assetId) {
      constraints.push(where('assetId', '==', filters.assetId));
    }
    
    if (filters.operatorId) {
      constraints.push(where('operatorId', '==', filters.operatorId));
    }

    const timesheetsQuery = query(timesheetsRef, ...constraints);
    const snapshot = await getDocs(timesheetsQuery);

    const plantHours: PlantAssetHours[] = [];
    const assetDateKeys = new Set<string>();
    
    snapshot.forEach((doc) => {
      const data = doc.data();
      assetDateKeys.add(`${data.assetId}-${data.date}`);
      plantHours.push({
        assetId: data.assetId,
        assetType: data.assetType,
        date: data.date,
        openHours: data.openHours,
        closeHours: data.closeHours,
        totalHours: data.totalHours,
        operatorId: data.operatorId,
        operatorName: data.operatorName,
        logBreakdown: data.logBreakdown || {},
        inclementWeather: data.inclementWeather,
        weatherNotes: data.weatherNotes,
        pvArea: data.pvArea,
        blockNumber: data.blockNumber,
        notes: data.notes
      });
    });
    
    const fuelLogsMap = new Map<string, any>();
    if (assetDateKeys.size > 0) {
      const assetIds = [...new Set(plantHours.map(ph => ph.assetId))];
      if (assetIds.length > 0) {
        const fuelLogsRef = collection(db, 'fuelLogs');
        const fuelLogsQuery = query(
          fuelLogsRef,
          where('masterAccountId', '==', filters.masterAccountId),
          where('assetId', 'in', assetIds.slice(0, 10)),
          where('date', '>=', filters.startDate),
          where('date', '<=', filters.endDate)
        );
        const fuelSnapshot = await getDocs(fuelLogsQuery);
        
        fuelSnapshot.forEach(doc => {
          const data = doc.data();
          const key = `${data.assetId}-${data.date}`;
          if (!fuelLogsMap.has(key)) {
            fuelLogsMap.set(key, data);
          }
        });
      }
    }
    
    plantHours.forEach(ph => {
      const fuelLogKey = `${ph.assetId}-${ph.date}`;
      const fuelLog = fuelLogsMap.get(fuelLogKey);
      
      if (fuelLog) {
        ph.fuelAmount = fuelLog.fuelAmount;
        ph.fuelMeterReading = fuelLog.meterReading;
        ph.fuelMeterType = fuelLog.meterType;
        
        if (ph.totalHours > 0) {
          if (fuelLog.meterType === 'HOUR_METER') {
            ph.fuelConsumption = fuelLog.fuelAmount / ph.totalHours;
          } else {
            ph.fuelConsumption = fuelLog.fuelAmount / (fuelLog.meterReading || 1);
          }
        }
      }
    });

    if (plantHours.length === 0) {
      console.log('[TimesheetExport] No plant hours data found');
      return null;
    }

    // Generate CSV
    const csvHeader = 'Date,Asset ID,Opening Hours,Closing Hours,Total Hours,Operator Name,Productive,Maintenance,Idle,Breakdown,Refueling,Weather Impact,PV Area,Block,Fuel Amount (L),Meter Reading,Consumption (L/h or L/km),Notes\n';
    const csvRows = plantHours.map(row => {
      const fields = [
        row.date,
        row.assetId,
        row.openHours.toFixed(2),
        row.closeHours.toFixed(2),
        row.totalHours.toFixed(2),
        `"${row.operatorName}"`,
        row.logBreakdown.productive ? 'Yes' : 'No',
        row.logBreakdown.maintenance ? 'Yes' : 'No',
        row.logBreakdown.idle ? 'Yes' : 'No',
        row.logBreakdown.breakdown ? 'Yes' : 'No',
        row.logBreakdown.refueling ? 'Yes' : 'No',
        row.inclementWeather ? `"${row.weatherNotes || 'Yes'}"` : 'No',
        `"${row.pvArea || ''}"`,
        `"${row.blockNumber || ''}"`,
        row.fuelAmount ? row.fuelAmount.toFixed(1) : '-',
        row.fuelMeterReading ? `${row.fuelMeterReading.toFixed(0)}${row.fuelMeterType === 'HOUR_METER' ? 'h' : 'km'}` : '-',
        row.fuelConsumption ? row.fuelConsumption.toFixed(2) : '-',
        `"${row.notes?.replace(/"/g, '""') || ''}"`
      ];
      return fields.join(',');
    }).join('\n');

    const csv = csvHeader + csvRows;
    
    // Save and share file
    const fileName = `plant_asset_hours_${filters.startDate}_to_${filters.endDate}.csv`;
    const filePath = await saveAndShareFile(csv, fileName);
    
    return filePath;
  } catch (error) {
    console.error('[TimesheetExport] Error exporting plant hours:', error);
    throw error;
  }
}

/**
 * Export combined timesheet summary
 */
export async function exportCombinedTimesheetSummary(filters: ExportFilters): Promise<string | null> {
  try {
    console.log('[TimesheetExport] Exporting combined timesheet summary');

    // Get both man hours and plant hours (exports are saved separately)
    await Promise.all([
      exportOperatorManHours(filters),
      exportPlantAssetHours(filters)
    ]);

    // Create a summary report
    const summaryData = await generateSummaryReport(filters);
    
    const summaryHeader = 'TIMESHEET SUMMARY REPORT\n';
    const dateRange = `Period: ${filters.startDate} to ${filters.endDate}\n\n`;
    
    let summaryContent = summaryHeader + dateRange;
    
    // Add operator summary
    summaryContent += 'OPERATOR MAN HOURS SUMMARY\n';
    summaryContent += '==========================\n';
    for (const [operatorName, hours] of Object.entries(summaryData.operatorSummary)) {
      summaryContent += `${operatorName}: ${hours} hours\n`;
    }
    
    summaryContent += '\n';
    
    // Add plant asset summary
    summaryContent += 'PLANT ASSET HOURS SUMMARY\n';
    summaryContent += '=========================\n';
    for (const [assetId, hours] of Object.entries(summaryData.assetSummary)) {
      summaryContent += `${assetId}: ${hours} hours\n`;
    }
    
    summaryContent += '\n';
    
    // Add totals
    summaryContent += 'TOTALS\n';
    summaryContent += '======\n';
    summaryContent += `Total Man Hours: ${summaryData.totalManHours} hours\n`;
    summaryContent += `Total Plant Hours: ${summaryData.totalPlantHours} hours\n`;
    summaryContent += `Number of Operators: ${summaryData.uniqueOperators}\n`;
    summaryContent += `Number of Assets: ${summaryData.uniqueAssets}\n`;
    
    const fileName = `timesheet_summary_${filters.startDate}_to_${filters.endDate}.txt`;
    const filePath = await saveAndShareFile(summaryContent, fileName);
    
    return filePath;
  } catch (error) {
    console.error('[TimesheetExport] Error exporting combined summary:', error);
    throw error;
  }
}

/**
 * Generate summary statistics for the report
 */
async function generateSummaryReport(filters: ExportFilters) {
  const operatorSummary: Record<string, number> = {};
  const assetSummary: Record<string, number> = {};
  let totalManHours = 0;
  let totalPlantHours = 0;
  const uniqueOperators = new Set<string>();
  const uniqueAssets = new Set<string>();

  // Get operator man hours
  const manHoursRef = collection(db, 'operatorTimesheets');
  const manHoursQuery = query(
    manHoursRef,
    where('masterAccountId', '==', filters.masterAccountId),
    where('date', '>=', filters.startDate),
    where('date', '<=', filters.endDate)
  );
  const manHoursSnapshot = await getDocs(manHoursQuery);
  
  manHoursSnapshot.forEach((doc) => {
    const data = doc.data();
    const operatorName = data.operatorName;
    const hours = data.totalManHours || 0;
    
    operatorSummary[operatorName] = (operatorSummary[operatorName] || 0) + hours;
    totalManHours += hours;
    uniqueOperators.add(data.operatorId);
  });

  // Get plant asset hours
  const plantHoursRef = collectionGroup(db, 'timesheets');
  const plantHoursQuery = query(
    plantHoursRef,
    where('masterAccountId', '==', filters.masterAccountId),
    where('date', '>=', filters.startDate),
    where('date', '<=', filters.endDate)
  );
  const plantHoursSnapshot = await getDocs(plantHoursQuery);
  
  plantHoursSnapshot.forEach((doc) => {
    const data = doc.data();
    const assetId = data.assetId;
    const hours = data.totalHours || 0;
    
    assetSummary[assetId] = (assetSummary[assetId] || 0) + hours;
    totalPlantHours += hours;
    uniqueAssets.add(assetId);
  });

  return {
    operatorSummary,
    assetSummary,
    totalManHours: totalManHours.toFixed(2),
    totalPlantHours: totalPlantHours.toFixed(2),
    uniqueOperators: uniqueOperators.size,
    uniqueAssets: uniqueAssets.size
  };
}

/**
 * Save file and share it
 */
async function saveAndShareFile(content: string, fileName: string): Promise<string | null> {
  try {
    if (Platform.OS === 'web') {
      // For web, create a blob and download
      const blob = new Blob([content], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      return fileName;
    } else {
      // For mobile, use web download approach for now
      // (Full mobile file sharing would require expo-file-system and expo-sharing)
      const blob = new Blob([content], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      return fileName;
    }
  } catch (error) {
    console.error('[TimesheetExport] Error saving/sharing file:', error);
    throw error;
  }
}

--- END OF FILE: utils/timesheetExport.ts ---


================================================================================
CATEGORY: Utility Files
FILE: utils/billableHoursCalculator.ts
================================================================================

/**
 * Billable Hours Calculator
 * 
 * This utility calculates billable hours for plant assets based on:
 * - Operator's recorded start and end times (Raw Tacho Hours)
 * - Billing configuration (minimum hours for different day types)
 * - Special conditions (breakdowns, weather, etc.)
 * 
 * Billing Logic Hierarchy:
 * Priority 1: Breakdown (overrides everything)
 * Priority 2: Inclement Weather
 * Priority 3: Standard Billing (weekday/weekend minimums)
 */

export type BillingConfigForCalculation = {
  weekdays: {
    minHours: number;
  };
  saturday: {
    minHours: number;
  };
  sunday: {
    minHours: number;
  };
  publicHolidays: {
    minHours: number;
  };
  rainDays: {
    enabled: boolean;
    minHours: number;
  };
  breakdown: {
    enabled: boolean;
  };
};

export type TimesheetForBilling = {
  startTime: string | number;
  endTime: string | number;
  date: string;
  isBreakdown?: boolean;
  isRainDay?: boolean;
  isInclementWeather?: boolean;
  isPublicHoliday?: boolean;
  openHours?: string | number;
  closeHours?: string | number;
  totalHours?: number;
};

export type BillableHoursResult = {
  actualHours: number;
  billableHours: number;
  appliedRule: 'breakdown' | 'rain_day' | 'weekday' | 'saturday' | 'sunday' | 'public_holiday' | 'invalid';
  minimumApplied: number;
  notes: string;
};

/**
 * Parse time value to number of hours
 */
function parseTimeToHours(time: string | number | undefined): number {
  if (time === undefined || time === null) {
    return 0;
  }

  if (typeof time === 'number') {
    return time;
  }

  const trimmed = String(time).trim();
  if (!trimmed || trimmed === '00:00' || trimmed === '') {
    return 0;
  }

  const parsed = parseFloat(trimmed);
  if (!isNaN(parsed)) {
    return parsed;
  }

  const parts = trimmed.split(':');
  if (parts.length === 2) {
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    if (!isNaN(hours) && !isNaN(minutes)) {
      return hours + (minutes / 60);
    }
  }

  return 0;
}

/**
 * Calculate Raw Tacho Hours from start and end times
 */
function calculateRawHours(timesheet: TimesheetForBilling): number {
  if (timesheet.totalHours !== undefined && timesheet.totalHours > 0) {
    return timesheet.totalHours;
  }

  const startHours = parseTimeToHours(timesheet.startTime || timesheet.openHours);
  const endHours = parseTimeToHours(timesheet.endTime || timesheet.closeHours);

  if (startHours === 0 && endHours === 0) {
    return 0;
  }

  const raw = endHours - startHours;
  return raw >= 0 ? raw : 0;
}

/**
 * Get day of week from date string (0 = Sunday, 6 = Saturday)
 */
function getDayOfWeek(dateStr: string): number {
  const date = new Date(dateStr);
  return date.getDay();
}

/**
 * Get minimum hours for a specific day type
 */
function getMinimumHoursForDay(
  dayOfWeek: number,
  isPublicHoliday: boolean,
  config: BillingConfigForCalculation
): number {
  if (isPublicHoliday) {
    return config.publicHolidays.minHours;
  }

  if (dayOfWeek === 6) {
    return config.saturday.minHours;
  }

  if (dayOfWeek === 0) {
    return config.sunday.minHours;
  }

  return config.weekdays.minHours;
}

/**
 * Get day type name for logging/display
 */
function getDayTypeName(
  dayOfWeek: number,
  isPublicHoliday: boolean
): 'weekday' | 'saturday' | 'sunday' | 'public_holiday' {
  if (isPublicHoliday) {
    return 'public_holiday';
  }

  if (dayOfWeek === 6) {
    return 'saturday';
  }

  if (dayOfWeek === 0) {
    return 'sunday';
  }

  return 'weekday';
}

/**
 * Calculate billable hours based on billing configuration and conditions
 * 
 * @param timesheet - Timesheet entry with start/end times and flags
 * @param config - Billing configuration
 * @returns Calculation result with actual hours, billable hours, and applied rule
 */
export function calculateBillableHours(
  timesheet: TimesheetForBilling,
  config: BillingConfigForCalculation
): BillableHoursResult {
  console.log('[BillableHoursCalculator] ===== Starting Calculation =====');
  console.log('[BillableHoursCalculator] Timesheet:', JSON.stringify(timesheet, null, 2));
  console.log('[BillableHoursCalculator] Config:', JSON.stringify(config, null, 2));

  // Step 1: Validate base requirements
  const rawHours = calculateRawHours(timesheet);
  
  console.log('[BillableHoursCalculator] Raw Hours calculated:', rawHours);

  if (rawHours === 0) {
    console.log('[BillableHoursCalculator]  No valid time entry - returning 0 billable hours');
    return {
      actualHours: 0,
      billableHours: 0,
      appliedRule: 'invalid',
      minimumApplied: 0,
      notes: 'No valid start and end times provided',
    };
  }

  const dayOfWeek = getDayOfWeek(timesheet.date);
  const dayType = getDayTypeName(dayOfWeek, Boolean(timesheet.isPublicHoliday));
  
  console.log('[BillableHoursCalculator] Day of week:', dayOfWeek, '(' + ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek] + ')');
  console.log('[BillableHoursCalculator] Day type:', dayType);

  // Priority 1: Breakdown (overrides everything)
  // When breakdown is marked on a timesheet:
  // - If toggle is ENABLED: bill actual hours (end - start)
  // - If toggle is DISABLED: bill 0 (no charge)
  if (timesheet.isBreakdown) {
    console.log('[BillableHoursCalculator]  Priority 1: BREAKDOWN condition detected');
    console.log('[BillableHoursCalculator] Breakdown toggle is', config.breakdown.enabled ? 'ENABLED' : 'DISABLED');
    
    if (config.breakdown.enabled) {
      console.log('[BillableHoursCalculator] Billable Hours = Actual Hours (end - start) =', rawHours);
      console.log('[BillableHoursCalculator] No minimum billing or threshold rules applied');
      
      return {
        actualHours: rawHours,
        billableHours: rawHours,
        appliedRule: 'breakdown',
        minimumApplied: 0,
        notes: 'Breakdown (enabled) - billed at actual hours (end time - start time)',
      };
    } else {
      console.log('[BillableHoursCalculator] Billable Hours = 0 (breakdown toggle disabled)');
      
      return {
        actualHours: rawHours,
        billableHours: 0,
        appliedRule: 'breakdown',
        minimumApplied: 0,
        notes: 'Breakdown (disabled) - no charge (R0)',
      };
    }
  }

  // Priority 2: Inclement Weather
  const isWeather = timesheet.isRainDay || timesheet.isInclementWeather;
  if (isWeather && config.rainDays.enabled) {
    console.log('[BillableHoursCalculator]  Priority 2: INCLEMENT WEATHER condition detected');
    
    const rainMinimum = config.rainDays.minHours;
    const billableHours = Math.max(rawHours, rainMinimum);
    
    console.log('[BillableHoursCalculator] Rain day minimum hours:', rainMinimum);
    console.log('[BillableHoursCalculator] Raw Hours:', rawHours);
    console.log('[BillableHoursCalculator] Billable Hours = MAX(Raw Hours, Rain Day Minimum) =', billableHours);
    
    return {
      actualHours: rawHours,
      billableHours: billableHours,
      appliedRule: 'rain_day',
      minimumApplied: rainMinimum,
      notes: rawHours >= rainMinimum 
        ? `Rain day - raw hours (${rawHours}h) exceeds minimum (${rainMinimum}h)`
        : `Rain day - minimum hours (${rainMinimum}h) applied`,
    };
  }

  // Priority 3: Standard Billing (weekday/weekend minimums)
  console.log('[BillableHoursCalculator]  Priority 3: STANDARD BILLING');
  
  const dayMinimum = getMinimumHoursForDay(dayOfWeek, Boolean(timesheet.isPublicHoliday), config);
  const billableHours = Math.max(rawHours, dayMinimum);
  
  console.log('[BillableHoursCalculator] Day minimum hours (' + dayType + '):', dayMinimum);
  console.log('[BillableHoursCalculator] Raw Hours:', rawHours);
  console.log('[BillableHoursCalculator] Billable Hours = MAX(Raw Hours, Day Minimum) =', billableHours);
  
  return {
    actualHours: rawHours,
    billableHours: billableHours,
    appliedRule: dayType,
    minimumApplied: dayMinimum,
    notes: rawHours >= dayMinimum
      ? `${dayType} - raw hours (${rawHours}h) exceeds minimum (${dayMinimum}h)`
      : `${dayType} - minimum hours (${dayMinimum}h) applied`,
  };
}

/**
 * Calculate billable hours for multiple timesheets
 */
export function calculateBillableHoursForTimesheets(
  timesheets: TimesheetForBilling[],
  config: BillingConfigForCalculation
): BillableHoursResult[] {
  console.log('[BillableHoursCalculator] Calculating billable hours for', timesheets.length, 'timesheets');
  
  return timesheets.map((timesheet, index) => {
    console.log(`[BillableHoursCalculator] Processing timesheet ${index + 1}/${timesheets.length}`);
    return calculateBillableHours(timesheet, config);
  });
}

/**
 * Get total billable hours from multiple calculation results
 */
export function getTotalBillableHours(results: BillableHoursResult[]): {
  totalActualHours: number;
  totalBillableHours: number;
} {
  const totalActualHours = results.reduce((sum, result) => sum + result.actualHours, 0);
  const totalBillableHours = results.reduce((sum, result) => sum + result.billableHours, 0);

  return {
    totalActualHours,
    totalBillableHours,
  };
}


--- END OF FILE: utils/billableHoursCalculator.ts ---


================================================================================
CATEGORY: Utility Files
FILE: utils/accounts/exportHandler.ts
================================================================================

import { logExport } from '@/utils/exportLog';
import type { ExportRequest } from '@/components/accounts/ExportRequestModal';
import type { User } from '@/types';

const CLIENT_EXPORT_LIMIT = 5000;

export type ExportResult = {
  success: boolean;
  isLarge: boolean;
  jobId?: string;
  fileUrl?: string;
  recordCount?: number;
  error?: string;
};

export async function estimateExportSize(
  exportType: ExportRequest['type'],
  filters: ExportRequest['filters']
): Promise<number> {
  console.log('[ExportHandler] Estimating export size:', exportType, filters);

  return 0;
}

export async function handleExportRequest(
  request: ExportRequest,
  user: User
): Promise<ExportResult> {
  console.log('[ExportHandler] Processing export request:', request.type);
  
  try {
    const estimatedRows = await estimateExportSize(request.type, request.filters);
    
    const isLarge = estimatedRows > CLIENT_EXPORT_LIMIT;

    if (isLarge) {
      console.log(
        '[ExportHandler] Large export detected. Creating server job...',
        estimatedRows,
        'rows'
      );
      
      const jobId = await createServerExportJob(request, user);
      
      await logExport({
        type: request.type,
        format: request.format,
        groupBy: request.groupBy,
        userId: user.id || '',
        userName: user.name || 'Unknown',
        filters: request.filters as Record<string, unknown>,
        success: true,
        isServerJob: true,
        jobId,
      });

      return {
        success: true,
        isLarge: true,
        jobId,
        recordCount: estimatedRows,
      };
    }

    console.log('[ExportHandler] Small export. Processing client-side...');
    
    const result = await processClientExport(request);

    await logExport({
      type: request.type,
      format: request.format,
      groupBy: request.groupBy,
      userId: user.id || '',
      userName: user.name || 'Unknown',
      filters: request.filters as Record<string, unknown>,
      success: true,
      recordCount: result.recordCount,
      fileSize: result.fileSize,
    });

    return {
      success: true,
      isLarge: false,
      fileUrl: result.fileUrl,
      recordCount: result.recordCount,
    };
  } catch (error) {
    console.error('[ExportHandler] Export failed:', error);

    await logExport({
      type: request.type,
      format: request.format,
      groupBy: request.groupBy,
      userId: user.id || '',
      userName: user.name || 'Unknown',
      filters: request.filters as Record<string, unknown>,
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    return {
      success: false,
      isLarge: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

async function createServerExportJob(
  request: ExportRequest,
  user: User
): Promise<string> {
  console.log('[ExportHandler] Creating server export job for:', request.type);

  const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  console.log('[ExportHandler] Server job created:', jobId);

  return jobId;
}

async function processClientExport(request: ExportRequest): Promise<{
  fileUrl: string;
  recordCount: number;
  fileSize: number;
}> {
  console.log('[ExportHandler] Processing client export:', request.type);

  await new Promise((resolve) => setTimeout(resolve, 1000));

  return {
    fileUrl: 'data:text/csv;base64,..', 
    recordCount: 100,
    fileSize: 5000,
  };
}

export function downloadFile(fileUrl: string, filename: string): void {
  console.log('[ExportHandler] Downloading file:', filename);

  if (typeof window !== 'undefined' && window.document) {
    const link = document.createElement('a');
    link.href = fileUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}


--- END OF FILE: utils/accounts/exportHandler.ts ---


================================================================================
CATEGORY: Types
FILE: types/emhReport.ts
================================================================================

export type EMHReportStatus = 'draft' | 'sent' | 'reviewed' | 'agreed' | 'disputed';

export type EMHRecipientType = 'subcontractor' | 'free_user';

export type LineItemDispute = {
  employeeId: string;
  timesheetId: string;
  date: string;
  disputeNotes: string;
  originalHours: number;
  disputedHours?: number;
  createdAt: any;
  createdBy: string;
};

export type EMHReport = {
  id?: string;
  reportId: string;
  status: EMHReportStatus;
  
  recipientType: EMHRecipientType;
  recipientId: string;
  recipientName: string;
  recipientEmail?: string;
  recipientMasterAccountId?: string;
  
  senderMasterAccountId: string;
  senderCompanyName: string;
  siteId: string;
  siteName?: string;
  
  dateRangeFrom: string;
  dateRangeTo: string;
  employeeIds: string[];
  totalEmployees: number;
  totalHours: number;
  totalCost: number;
  message?: string;
  pdfUrl?: string;
  
  sentAt?: any;
  sentBy?: string;
  reviewedAt?: any;
  reviewedBy?: string;
  agreedAt?: any;
  agreedBy?: string;
  disputeNotes?: string;
  lineItemDisputes?: LineItemDispute[];
  
  createdAt: any;
  updatedAt?: any;
};


--- END OF FILE: types/emhReport.ts ---


================================================================================
CATEGORY: Types
FILE: types/index.ts
================================================================================

export type AccountType = 'enterprise' | 'free';

/**
 * VAS Subscription State
 * Manages the lifecycle of a VAS subscription
 */
export type VASSubscriptionState = 
  | 'INACTIVE'           // Not subscribed
  | 'TRIAL_ACTIVE'       // In trial period
  | 'PAYMENT_PENDING'    // Trial ended, awaiting payment
  | 'ACTIVE'             // Fully active with payment
  | 'SUSPENDED';         // Suspended due to non-payment or admin action

export type VASFeatureId =
  | 'analytics'
  | 'reporting'
  | 'data_exports'
  | 'advanced_integrations'
  | 'custom_branding'
  | 'priority_support'
  | 'marketplace_access'
  | 'plant_manager_access'
  | 'staff_manager_access'
  | 'logistics_access'
  | 'operations_bundle'
  | 'multiple_sites';

export type VASFeature = {
  id: VASFeatureId;
  name: string;
  description: string;
  price?: string;
  isActive: boolean;
};

/**
 * VAS Subscription
 * Tracks individual VAS feature subscription with trial and payment states
 */
export type VASSubscription = {
  id?: string;
  masterAccountId: string;
  featureId: VASFeatureId;
  featureName: string;
  state: VASSubscriptionState;
  trialStartDate?: any;           // When trial started
  trialEndDate?: any;             // When trial expires (typically 12 days)
  activationDate?: any;           // When fully activated with payment
  suspensionDate?: any;           // When suspended
  suspensionReason?: string;      // Why suspended
  lastPaymentDate?: any;          // Last payment received
  nextPaymentDue?: any;           // Next payment due date
  price?: number;                 // Monthly price
  currency?: string;              // Currency code (e.g., 'USD')
  autoRenew?: boolean;            // Auto-renewal enabled
  notes?: string;
  createdAt: any;
  updatedAt?: any;
  createdBy: string;              // MasterAccountId who created
};

/**
 * Admin Notification Type
 */
export type AdminNotificationType =
  | 'ACTIVATION_CODE_REDEEMED'    // Enterprise account activated
  | 'VAS_SUBSCRIPTION_STARTED'    // VAS subscription trial started
  | 'VAS_SUBSCRIPTION_ACTIVATED'  // VAS subscription fully activated
  | 'VAS_TRIAL_EXPIRING'          // VAS trial expiring soon
  | 'VAS_TRIAL_EXPIRED'           // VAS trial expired
  | 'VAS_PAYMENT_PENDING'         // Payment pending
  | 'VAS_SUSPENDED'               // Subscription suspended
  | 'GENERAL';                    // General admin notification

/**
 * Admin Notification
 * Notifications for system admins about subscription events
 */
export type AdminNotification = {
  id?: string;
  type: AdminNotificationType;
  title: string;
  message: string;
  masterAccountId?: string;       // Related master account
  masterAccountName?: string;     // Account name for display
  activationCodeId?: string;      // Related activation code
  vasSubscriptionId?: string;     // Related VAS subscription
  featureId?: VASFeatureId;       // Related feature
  isRead: boolean;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  metadata?: Record<string, any>; // Additional data
  createdAt: any;
  readAt?: any;
  readBy?: string;                // Admin who read it
};

export type FeatureFlags = {
  employee_management: boolean;
  asset_management: boolean;
  external_data_reception: boolean;
  analytics: boolean;
  reporting: boolean;
  data_exports: boolean;
  advanced_integrations: boolean;
  custom_branding: boolean;
  priority_support: boolean;
  task_management: boolean;
  time_tracking: boolean;
  progress_reporting: boolean;
  plant_manager_access: boolean;
  staff_manager_access: boolean;
  logistics_access: boolean;
  operations_bundle: boolean;
};

export type UserRole =
  | "Admin"
  | "Planner"
  | "Supervisor"
  | "QC"
  | "Operator"
  | "Plant Manager"
  | "Surveyor"
  | "Staff Manager"
  | "Logistics Manager"
  | "HSE"
  | "HR"
  | "Accounts"
  | "General Worker"
  | "Foreman"
  | "Engineer"
  | "Electrician"
  | "Plumber"
  | "Carpenter"
  | "Welder"
  | "Diesel Clerk"
  | "master";

export type CompanySettings = {
  legalEntityName: string;
  alias: string;
  address: string;
  contact: string;
  adminContact: string;
  adminEmail: string;
  companyRegistrationNr: string;
  vatNr: string;
  plantTypes?: string[];
};

export type Company = {
  id: string;
  legalEntityName: string;
  alias: string;
  address: string;
  contactNumber: string;
  adminContact: string;
  adminEmail: string;
  companyRegistrationNr: string;
  vatNumber: string;
  industrySector: string;
  status: 'Active' | 'Inactive' | 'Archived';
  accountType?: AccountType; // Company account type (free/enterprise)
  subscriptionTier?: 'free' | 'basic' | 'premium' | 'enterprise';
  vasFeatures?: VASFeatureId[]; // Active VAS features for this company
  billingEmail?: string;
  subscriptionStartDate?: any;
  subscriptionEndDate?: any;
  // Geographic availability settings for marketplace
  plantAvailabilityProvince?: string; // Province/County where assets are available
  plantAvailabilityRadiusKm?: number; // Radius in KM from company location
  plantAvailabilityGeoType?: 'province' | 'radius'; // Type of geographic filter
  // Multi-owner support
  totalOwnershipPercentage?: number; // Total ownership percentage allocated
  ownerCount?: number; // Number of active owners
  createdAt: any;
  updatedAt?: any;
  createdBy: string; // Primary creator (still supported for legacy)
};

export type CompanyUser = {
  userId: string;
  companyId: string;
  role: UserRole;
  siteIds?: string[];
  addedAt: any;
  addedBy: string;
};

export type SubContractorUser = {
  id: string;
  userId: string;
  pin?: string;
  subContractorName: string;
  legalEntityName: string;
  userName?: string;
  directPersonalContactNr: string;
  adminContact: string;
  adminEmail: string;
  companyRegistrationNr: string;
  vatNr: string;
  role: UserRole;
  siteId: string;
  createdAt: any;
  createdBy: string;
  disabledMenus?: string[];
  isLocked?: boolean;
};

/**
 * ID Verification Status
 */
export type IDVerificationStatus = 
  | 'unverified' 
  | 'pending_review' 
  | 'verified' 
  | 'rejected' 
  | 'expired';

/**
 * Duplicate ID Status
 */
export type DuplicateIDStatus = 
  | 'none' 
  | 'detected' 
  | 'under_investigation' 
  | 'resolved' 
  | 'blocked';

export type MasterAccount = {
  id: string;
  masterId: string;
  name: string;
  surname?: string; // Surname for credentials
  username?: string; // Username for credentials
  pin: string;
  nationalIdNumber?: string; // National ID number for verification
  idVerificationStatus?: IDVerificationStatus; // ID verification status
  idVerifiedAt?: any; // When ID was verified
  idVerifiedBy?: string; // Admin who verified ID
  idDocumentUrl?: string; // URL to uploaded ID document
  duplicateIdStatus?: DuplicateIDStatus; // Duplicate ID detection status
  canOwnCompanies?: boolean; // Can own companies (requires verified ID)
  canReceivePayouts?: boolean; // Can receive financial payouts
  canApproveOwnershipChanges?: boolean; // Can approve ownership changes
  restrictionReason?: string; // Reason for any restrictions
  companyIds: string[];
  currentCompanyId?: string;
  accountType?: AccountType;
  vasFeatures?: VASFeatureId[];
  createdAt: any;
  updatedAt?: any;
};

export type AccessScope = 'company-level' | 'all-sites' | 'selected-sites' | 'no-sites';

export type User = {
  id: string;
  userId: string;
  name: string;
  role: UserRole | 'master';
  companyIds: string[];
  currentCompanyId?: string;
  companyName?: string;
  companyContactMobile?: string;
  supervisorName?: string;
  supervisorMobile?: string;
  siteId?: string;
  siteName?: string;
  pin?: string;
  masterAccountId?: string;
  accountType?: AccountType;
  vasFeatures?: VASFeatureId[];
  canAccessMasterCompanyProfile?: boolean; // Flag for Master Company Profile access
  accessScope?: AccessScope; // Defines where user's actions apply
  createdAt: any;
  disabledMenus?: string[];
  isLocked?: boolean;
};

export type LatLon = {
  latitude: number;
  longitude: number;
};

export type FacePolicy = {
  minMatchScore: number;
  requireLiveness: boolean;
  allowOfflineMatch: boolean;
  maxGpsAccuracyMeters?: number;
};

export type Site = {
  id: string;
  name: string;
  companyId: string;
  masterAccountId: string;
  companySettings?: CompanySettings;
  description?: string;
  location?: string;
  status?: 'Active' | 'Inactive' | 'Archived' | 'Deleted';
  faceClockInEnabled?: boolean;
  faceGeoCenter?: LatLon;
  faceGeoRadiusKm?: number;
  facePolicy?: FacePolicy;
  createdAt: any;
  updatedAt?: any;
  deletedAt?: any;
};

export type RequestType =
  | 'TASK_REQUEST'
  | 'SCOPE_REQUEST'
  | 'ACTIVITY_SCOPE'
  | 'QC_REQUEST'
  | 'CABLING_REQUEST'
  | 'TERMINATION_REQUEST'
  | 'SURVEYOR_TASK'
  | 'HANDOVER_REQUEST'
  | 'CONCRETE_REQUEST'
  | 'LOGISTICS_REQUEST'
  | 'PLANT_REQUEST'
  | 'STAFF_REQUEST';

export type RequestStatus = 'PENDING' | 'APPROVED' | 'REJECTED' | 'CANCELLED' | 'scheduled';

export type ActivityStatus = 'LOCKED' | 'OPEN' | 'DONE' | 'HANDOFF_SENT';

export type ScopePolicy = 'NORMAL' | 'NONE';

export type CanonicalUnit = {
  canonical: string;
  setBy: string;
  setAt: any;
};

export type ScopeValue = {
  value: number;
  unit: string;
  setBy: string;
  setAt: any;
};

export type QCValue = {
  value?: number;
  unit?: string;
  completedAt?: any;
  completedBy?: string;
  status?: 'not_requested' | 'pending' | 'scheduled' | 'in_progress' | 'completed' | 'rejected';
  lastRequestId?: string;
  lastUpdatedAt?: any;
  scheduledAt?: any;
};

export type ProgressEntry = {
  id?: string;
  supervisorId: string;
  enteredAt: any;
  raw: {
    value: number;
    unit: string;
  };
  normalized: {
    value: number;
    unit: string;
  };
  note?: string;
  source?: 'manual' | 'import' | 'sync';
};

export type InitTaskActivityParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
  siteId: string;
  masterAccountId: string;
  createdBy: string;
};

export type SubmitProgressParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
  supervisorId: string;
  value: number;
  unit: string;
  canonicalUnit: string;
  note?: string;
};

export type QCRequestParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
  requestedBy: string;
  siteId: string;
  masterAccountId: string;
  activityName: string;
};

export type QCValidationParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
  qcValue: number;
  qcUnit: string;
  canonicalUnit: string;
  validatedBy: string;
};

export type ClearInputParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
};

export type ProgressCalcParams = {
  scopeValue?: number;
  cumulativeProgress: number;
};

export type StatusParams = {
  taskId: string;
  subMenuKey: string;
  activityId: string;
};

export type CompletedTodayLock = {
  isLocked: boolean;
  lockType?: 'QC_INTERACTION' | 'TIME_LOCK';
  lockedAt?: any;
  lockedValue?: number;
  lockedUnit?: string;
  lockDate?: string;
  qcApprovedValue?: number;
  qcApprovedUnit?: string;
};

export type ActivityDetail = {
  id: string;
  name: string;
  status: ActivityStatus;
  scopePolicy: ScopePolicy;
  scopeValue?: ScopeValue;
  canonicalUnit?: CanonicalUnit;
  supervisorInputValue?: number;
  supervisorInputUnit?: string;
  supervisorInputAt?: any;
  supervisorInputBy?: string;
  supervisorInputLocked?: boolean;
  completedTodayLock?: CompletedTodayLock;
  cumulativeProgress: number;
  progressPercentage: number;
  qc?: QCValue;
  qcValue?: number;
  createdAt?: any;
  updatedAt?: any;
};

export type SurveyorTaskStatus = 'PENDING_APPROVAL' | 'APPROVED' | 'REJECTED' | 'CANCELLED' | 'CLOSED';

export type SurveyorTask = {
  id?: string;
  taskId: string;
  siteId: string;
  createdByUserId: string;
  assignedSurveyorUserId?: string;
  status: SurveyorTaskStatus;
  pvArea: string;
  blockNumber: string;
  rowNr?: string;
  columnNr?: string;
  notes?: string;
  linkedImageIds?: string[];
  archived?: boolean;
  createdAt: any;
  updatedAt?: any;
};

export type SurveyorImageType = 'BASEMAP_OVERLAY' | 'DETAIL' | 'OTHER';

export type SurveyorImage = {
  id?: string;
  imageId: string;
  siteId: string;
  pvArea?: string;
  blockNumber?: string;
  rowNr?: string;
  columnNr?: string;
  sourceTaskId: string;
  imageUrl: string;
  storagePath: string;
  imageType: SurveyorImageType;
  description?: string;
  createdByUserId: string;
  createdAt: any;
  isActive: boolean;
  version?: number;
  replacesImageId?: string;
};

export type ImageShareStatus = 'PENDING' | 'VIEWED' | 'DOWNLOADED';

export type SharedImage = {
  id?: string;
  shareId: string;
  siteId: string;
  imageId: string;
  imageUrl: string;
  fileName: string;
  fileType: string;
  sharedByUserId: string;
  sharedByUserName: string;
  sharedToUserId: string;
  sharedToUserName: string;
  message?: string;
  status: ImageShareStatus;
  sharedAt: any;
  viewedAt?: any;
  downloadedAt?: any;
};

export type Attachment = {
  id: string;
  fileName: string;
  fileType: 'image' | 'document';
  mimeType: string;
  downloadUrl: string;
  storagePath: string;
  uploadedAt: any;
  uploadedBy: string;
  size?: number;
};

export type Subcontractor = {
  id?: string;
  name: string;
  legalEntityName?: string;
  contactPerson?: string;
  contactNumber?: string;
  adminEmail?: string;
  address?: string;
  companyRegistrationNr?: string;
  vatNumber?: string;
  linkedSites?: string[];
  linkedProjects?: string[];
  isCrossHire: boolean;
  crossHireName?: string;
  masterAccountId: string;
  siteId?: string;
  companyId?: string;
  status: 'Active' | 'Inactive' | 'Archived';
  notes?: string;
  createdAt: any;
  updatedAt?: any;
  createdBy: string;
};

export type Employee = {
  id?: string;
  name: string;
  role: string;
  contact: string;
  email?: string;
  employeeIdNumber?: string;
  citizenshipCountry?: string;
  companyId: string; // Company-level ownership (required)
  masterAccountId: string;
  siteId?: string; // DEPRECATED: Use EmployeeSiteLink instead
  type?: 'employee' | 'subcontractor';
  subcontractorCompany?: string;
  employerName?: string;
  employerId?: string;
  employerType: 'company' | 'subcontractor';
  isCrossHire?: boolean;
  crossHireName?: string;
  accessScope?: AccessScope; // Access scope for this employee
  canAccessMasterCompanyProfile?: boolean; // Can access Master Company Profile
  allocatedPvArea?: string;
  allocatedBlockNumber?: string;
  areaAllocationDate?: any;
  inductionStatus: boolean;
  inductionDate?: any;
  inductionNotes?: string;
  attachments?: Attachment[];
  medicalExpiryDate?: any;
  licenseExpiryDate?: any;
  competencyExpiryDate?: any;
  pdpExpiryDate?: any;
  createdAt: any;
  updatedAt?: any;
};

// New type for many-to-many employee-site relationships
export type EmployeeSiteLink = {
  id?: string;
  employeeId: string;
  employeeName?: string;
  siteId: string;
  siteName?: string;
  companyId: string;
  masterAccountId: string;
  isActive: boolean;
  assignedAt: any;
  assignedBy: string;
  removedAt?: any;
  removedBy?: string;
  notes?: string;
};

/**
 * EmployeeSite - Junction table for company-level employees and site assignments
 * Employees are created once at company level, then linked to sites via this table
 */
export type EmployeeSite = {
  id?: string;
  employeeId: string;
  employeeName: string;
  siteId: string;
  siteName: string;
  companyId: string;
  masterAccountId: string;
  role?: string; // Site-specific role (can override employee's default role)
  linkedAt: any;
  linkedBy: string;
  unlinkedAt?: any;
  unlinkedBy?: string;
  isActive: boolean;
  createdAt: any;
  updatedAt?: any;
};

/**
 * AssetSite - Junction table for company-level assets and site allocations
 * Assets are created once at company level, then linked to sites via this table
 */
export type AssetSite = {
  id?: string;
  assetId: string;
  assetName: string;
  assetType: string;
  siteId: string;
  siteName: string;
  companyId: string;
  masterAccountId: string;
  linkedAt: any;
  linkedBy: string;
  unlinkedAt?: any;
  unlinkedBy?: string;
  isActive: boolean;
  allocationNotes?: string;
  createdAt: any;
  updatedAt?: any;
};

export type ChecklistItem = {
  id: string;
  label: string;
  completed: boolean;
  completedAt?: any;
  completedBy?: string;
  order: number;
};

export type DailyChecklistEntry = {
  id?: string;
  assetId: string;
  assetType: string;
  date: string; // ISO date (YYYY-MM-DD)
  operatorId: string;
  operatorName: string;
  checklist: ChecklistItem[];
  completedCount: number;
  totalCount: number;
  isFullyCompleted: boolean;
  notes?: string;
  siteId?: string;
  siteName?: string;
  masterAccountId: string;
  companyId?: string;
  submittedAt: any;
  createdAt: any;
  updatedAt?: any;
};

export type AllocationStatus = 'UNALLOCATED' | 'ALLOCATED' | 'IN_TRANSIT';

export type CurrentAllocation = {
  siteId: string;
  siteName?: string;
  allocatedAt: any;
  allocatedBy: string;
  pvArea?: string;
  blockArea?: string;
  requestId?: string;
  notes?: string;
};

export type AllocationHistoryEntry = {
  siteId: string;
  siteName?: string;
  allocatedAt: any;
  allocatedBy: string;
  deallocatedAt?: any;
  deallocatedBy?: string;
  notes?: string;
};

export type OperatorHistory = {
  operatorId: string;
  operatorName: string;
  operatorContact?: string;
  assignedAt: any;
  removedAt?: any;
  assignedBy: string;
  removedBy?: string;
  reason?: string; // Reason for operator change
};

export type PlantAssetTimesheet = {
  id?: string;
  assetId: string;
  date: string; // ISO date (YYYY-MM-DD)
  meterType?: 'HOUR_METER' | 'ODOMETER'; // Type of meter reading
  openHours: number; // Opening hour meter reading
  closeHours: number; // Closing hour meter reading
  totalHours: number; // Calculated (close - open)
  operatorId: string; // Current operator who entered
  operatorName: string; // Operator name for display
  logBreakdown: boolean; // Log breakdown for the day
  scheduledMaintenance: boolean; // Scheduled maintenance performed
  rainDay?: boolean; // Rain day flag
  strikeDay?: boolean; // Strike day flag
  hasAttachment?: boolean; // Has attachment flag
  inclementWeather: boolean; // Weather-related downtime
  weatherNotes?: string; // Weather details if applicable
  siteId?: string; // Current work site
  siteName?: string; // Site display name
  location?: string; // Site ID (auto-generated number)
  pvArea?: string; // PV area if applicable
  blockNumber?: string; // Block number if applicable
  notes?: string; // General notes
  masterAccountId: string;
  companyId?: string;
  verified?: boolean;
  verifiedAt?: any;
  verifiedBy?: string;
  hasAdjustment?: boolean;
  adjustmentId?: string;
  isAdjustment?: boolean;
  originalEntryId?: string;
  createdAt: any;
  updatedAt: any;
};

export type OperatorTimesheet = {
  id?: string;
  operatorId: string; // Employee ID
  operatorName: string; // Employee name
  date: string; // ISO date (YYYY-MM-DD)
  startTime: string; // HH:MM format
  stopTime: string; // HH:MM format
  lunchBreak: boolean; // Lunch break taken
  noLunchBreak?: boolean;
  totalManHours: number; // Calculated hours
  normalHours?: number;
  overtimeHours?: number;
  sundayHours?: number;
  publicHolidayHours?: number;
  siteId?: string; // Work site
  siteName?: string; // Site display name
  notes?: string; // Optional notes
  masterAccountId: string;
  companyId?: string;
  status?: 'DRAFT' | 'SUBMITTED' | 'APPROVED' | 'REJECTED';
  submittedAt?: any; // Submission time
  approvedBy?: string; // Approver ID
  approvedAt?: any; // Approval time
  approvalNotes?: string; // Approval/rejection notes
  verified?: boolean;
  verifiedAt?: any;
  verifiedBy?: string;
  hasAdjustment?: boolean;
  adjustmentId?: string;
  isAdjustment?: boolean;
  originalEntryId?: string;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  agreedNotes?: string;
  hasAgreedHours?: boolean;
  agreedTimesheetId?: string;
  createdAt: any;
  updatedAt: any;
};

export type AgreedTimesheet = {
  id: string;
  originalTimesheetId: string;
  timesheetType: 'operator' | 'plant_asset';
  date: string;
  operatorId?: string;
  operatorName?: string;
  assetId?: string;
  assetType?: string;
  originalHours: number;
  agreedHours: number;
  billableHours?: number;
  billingRule?: string;
  agreedNormalHours?: number;
  agreedOvertimeHours?: number;
  agreedSundayHours?: number;
  agreedPublicHolidayHours?: number;
  originalNormalHours?: number;
  originalOvertimeHours?: number;
  originalSundayHours?: number;
  originalPublicHolidayHours?: number;
  originalOpenHours?: number;
  originalCloseHours?: number;
  isBreakdown?: boolean;
  isRainDay?: boolean;
  isInclementWeather?: boolean;
  isPublicHoliday?: boolean;
  hoursDifference: number;
  originalNotes?: string;
  adminNotes?: string;
  siteId?: string;
  siteName?: string;
  masterAccountId: string;
  companyId?: string;
  subcontractorId?: string;
  subcontractorName?: string;
  status: 'approved_for_billing' | 'disputed' | 'rejected';
  agreedAt: any;
  agreedBy: string;
  agreedByRole?: 'Operator' | 'Plant Manager' | 'Admin';
  approvedForBillingAt?: any;
  approvedForBillingBy?: string;
  createdAt: any;
  updatedAt: any;
};

export type PlantAssetOperatorHistory = {
  id?: string;
  assetId: string; // Plant asset ID
  assetType: string; // Asset type
  assetSiteId: string; // Asset site ID
  previousOperatorId?: string; // Previous operator ID
  previousOperatorName?: string; // Previous operator name
  newOperatorId: string; // New operator ID
  newOperatorName: string; // New operator name
  changeDate: any; // When change occurred
  changeReason: string; // Reason for change
  changedBy: string; // User who made change
  changedByName: string; // Name of user
  notes?: string; // Additional notes
  masterAccountId: string;
  companyId?: string;
  createdAt: any;
};

export type PlantAsset = {
  id?: string;
  assetId: string;
  type: string;
  typeId?: string;
  groupId?: string;
  location?: string;
  assignedJob?: string;
  assignedSite?: string;
  plantNumber?: string;
  registrationNumber?: string;
  subcontractor?: string;
  crossHire?: string;
  currentOperator?: string;
  currentOperatorId?: string;
  ownerName?: string;
  ownerId?: string;
  ownerType: 'company' | 'subcontractor';
  ownerMasterAccountId?: string;
  ownerEmail?: string;
  ownerContactName?: string;
  ownerProvince?: string;
  ownerAddress?: string;
  isCrossHire?: boolean;
  crossHireName?: string;
  salaryPayer?: string;
  operatorHistory?: OperatorHistory[];
  siteId?: string | null; // DEPRECATED: Use PlantAssetAllocation instead
  masterAccountId: string;
  companyId: string; // Company-level ownership (required)
  allocationStatus: AllocationStatus;
  currentAllocation?: CurrentAllocation;
  allocationHistory?: AllocationHistoryEntry[];
  allocatedPvArea?: string;
  allocatedBlockNumber?: string;
  allocationDate?: any;
  breakdownStatus?: boolean;
  breakdownStartDate?: string;
  breakdownEndDate?: string | null;
  breakdownTimestamp?: any;
  breakdownLoggedBy?: string;
  breakdownReactivatedBy?: string;
  breakdownReactivatedAt?: any;
  inductionStatus: boolean;
  inductionDate?: any;
  onboardingDate?: any;
  inductionNotes?: string;
  attachments?: Attachment[];
  checklist?: ChecklistItem[];
  offHireDate?: any;
  offHireTimestamp?: any;
  offHireSubmittedBy?: string;
  dryRate?: number;
  wetRate?: number;
  dailyRate?: number;
  billingMethod?: 'PER_HOUR' | 'MINIMUM_BILLING';
  ratesSetAt?: any;
  ratesSetBy?: string;
  meterType?: 'HOUR_METER' | 'ODOMETER';
  lastMeterReading?: number;
  lastMeterReadingDate?: string;
  archived?: boolean;
  archivedAt?: any;
  archivedBy?: string;
  // New marketplace fields
  internalAllocationEnabled?: boolean; // Can be allocated to own sites
  marketplaceVisibilityEnabled?: boolean; // Listed in marketplace (VAS-gated)
  isAvailableForVAS?: boolean; // Visible in VAS marketplace
  availability?: 'available' | 'allocated' | 'maintenance';
  createdAt: any;
  updatedAt?: any;
};

// New type for plant asset allocation tracking
export type PlantAssetAllocation = {
  id?: string;
  assetId: string;
  assetType?: string;
  companyId: string;
  siteId: string;
  siteName?: string;
  masterAccountId: string;
  isActive: boolean; // Current allocation or historical
  allocatedAt: any;
  allocatedBy: string;
  deallocatedAt?: any;
  deallocatedBy?: string;
  pvArea?: string;
  blockArea?: string;
  requestId?: string;
  notes?: string;
  createdAt: any;
  updatedAt?: any;
};

// New type for marketplace listings
export type MarketplaceListing = {
  id?: string;
  assetId: string;
  assetType: string;
  companyId: string; // Owner company
  companyName?: string;
  plantNumber?: string;
  registrationNumber?: string;
  description?: string;
  availability: 'available' | 'currently_allocated' | 'maintenance';
  currentAllocationSiteId?: string; // If currently allocated
  currentAllocationSiteName?: string;
  dryRate?: number;
  wetRate?: number;
  dailyRate?: number;
  billingMethod?: 'PER_HOUR' | 'MINIMUM_BILLING';
  location?: string;
  contactPerson?: string;
  contactNumber?: string;
  isActive: boolean; // Listing active or hidden
  listedAt: any;
  lastUpdatedAt?: any;
  viewCount?: number;
  inquiryCount?: number;
  createdAt: any;
  updatedAt?: any;
};

export type Asset = {
  id?: string;
  assetName: string;
  assetType: string;
  serialNumber?: string;
  location?: string;
  assignedJob?: string;
  siteId: string;
  masterAccountId: string;
  inductionStatus?: boolean;
  inductionDate?: any;
  inductionNotes?: string;
  attachments?: Attachment[];
  checklist?: ChecklistItem[];
  createdAt: any;
  updatedAt?: any;
};

export type OnboardingMessage = {
  id?: string;
  siteId: string;
  masterAccountId: string;
  fromUserId: string;
  fromUserName: string;
  toUserId: string;
  message: string;
  type: 'EXIT_MEDICAL' | 'GENERAL' | 'EXPIRY_WARNING';
  employeeName?: string;
  read: boolean;
  createdAt: any;
};

export type HandoverRequest = {
  id?: string;
  type: 'HANDOVER_REQUEST';
  requestType?: 'SURVEYOR_REQUEST' | 'CABLING_REQUEST' | 'TERMINATION_REQUEST' | 'HANDOVER_REQUEST' | 'QC_REQUEST' | 'PLANT_REQUEST' | 'LOGISTICS_REQUEST' | 'STAFF_REQUEST';
  fromSupervisorId: string;
  toSupervisorId?: string;
  fromTaskId?: string;
  toTaskId?: string;
  activityId: string;
  activityName: string;
  subMenuKey: string;
  subMenuName?: string;
  pvArea: string;
  blockNumber: string;
  rowNr?: string;
  columnNr?: string;
  siteId: string;
  masterAccountId?: string;
  status: RequestStatus | 'RESOLVED_BY_PLANNER';
  noteFromSender?: string;
  noteFromPlanner?: string;
  handoverMode: 'SUPERVISOR_TO_SUPERVISOR' | 'PLANNER_APPOINTMENT';
  appointedSupervisorId?: string;
  appointedTaskId?: string;
  targetUserRole?: UserRole;
  linkedImageIds?: string[];
  createdAt: any;
  updatedAt?: any;
};

export type OperatorAssetHours = {
  id?: string;
  operatorId: string;
  operatorName: string;
  assetId: string;
  assetType: string;
  assetSiteId: string;
  date: string;
  openHours: string;
  closingHours: string;
  totalHours: number;
  siteId?: string;
  siteName?: string;
  masterAccountId: string;
  notes?: string;
  status: 'SUBMITTED' | 'APPROVED' | 'REJECTED';
  submittedAt: any;
  approvedAt?: any;
  approvedBy?: string;
  rejectionReason?: string;
  isRainDay?: boolean;
  isStrikeDay?: boolean;
  isBreakdown?: boolean;
  createdAt: any;
  updatedAt?: any;
};

export type FaceTemplate = {
  id?: string;
  userId: string;
  userName: string;
  encryptedEmbedding: string;
  encryptionSalt: string;
  enrolledAt: any;
  enrolledBy: string;
  version: number;
  isActive: boolean;
  masterAccountId: string;
  companyId?: string;
  siteId?: string;
  createdAt: any;
  updatedAt?: any;
};

export type ActivityBaseBlockType = 'STANDARD_COMPLETED_TODAY' | 'GRID_TYPE_ROW_PROGRESS';

export type ActivityMicroModule = 
  | 'HANDOVER_CARDS'
  | 'QC_REQUEST'
  | 'CONCRETE_REQUEST'
  | 'CABLING_REQUEST'
  | 'TERMINATION_REQUEST'
  | 'SURVEYOR_REQUEST'
  | 'PLANT_REQUEST'
  | 'MATERIALS_REQUEST'
  | 'STAFF_REQUEST';

export type GridNamingConvention = 'ALPHA' | 'NUMERIC';

export type FlexibleColumnConfig = {
  column: string;
  rows: number;
};

export type GridConfiguration = {
  pvAreaId?: string;
  pvAreaName?: string;
  blockAreaId?: string;
  blockAreaName?: string;
  scopeValue?: number;
  scopeUnit?: string;
  totalRows: number;
  totalColumns: number;
  flexibleColumns?: FlexibleColumnConfig[];
  rowNamingConvention: GridNamingConvention;
  columnNamingConvention: GridNamingConvention;
  reverseRowOrder?: boolean;
  reverseColumnOrder?: boolean;
};

export type HandoverTarget = 
  | 'Surveyor'
  | 'Cabling'
  | 'Termination'
  | 'Inverters'
  | 'Mechanical'
  | 'Commissioning'
  | 'Drilling';

export type RequestCardsConfig = {
  plant?: { enabled: boolean };
  staff?: { enabled: boolean };
  materials?: { enabled: boolean };
};

export type ActivityModuleConfig = {
  baseBlockType: ActivityBaseBlockType;
  microModules: {
    [key in ActivityMicroModule]?: {
      enabled: boolean;
      placement: 'inside' | 'above' | 'between';
      handoverTarget?: HandoverTarget;
      requestCardsConfig?: RequestCardsConfig;
    };
  };
  gridConfig?: GridConfiguration;
  boqQuantity?: number;
  boqUnit?: string;
};

export type FaceClockAttempt = {
  id?: string;
  userId: string;
  userName: string;
  userRole: UserRole;
  siteId: string;
  siteName?: string;
  companyId?: string;
  masterAccountId: string;
  eventType: 'clock-in' | 'clock-out';
  method: 'face';
  timestampClient: string;
  timestampServer?: any;
  gps: {
    latitude: number;
    longitude: number;
    accuracy: number;
  };
  distanceFromSiteKm: number;
  matchScore: number | null;
  livenessPassed: boolean;
  verificationState: 'verified' | 'rejected' | 'pending';
  rejectionReason?: 'out_of_zone' | 'liveness_failed' | 'face_mismatch' | 'gps_accuracy_poor' | 'no_template' | 'other';
  deviceInfo: {
    deviceId: string;
    appVersion: string;
    platform: string;
  };
  offlineMode: boolean;
  syncedToServer: boolean;
  notes?: string;
  createdAt: any;
  updatedAt?: any;
};

export type GridCellProgress = {
  id?: string;
  activityId: string;
  activityName: string;
  taskId: string;
  siteId: string;
  masterAccountId: string;
  pvAreaId: string;
  pvAreaName: string;
  blockAreaId: string;
  blockAreaName: string;
  row: string;
  rowIndex: number;
  column: string;
  columnIndex: number;
  supervisorId: string;
  supervisorName: string;
  status: 'pending' | 'in-progress' | 'completed';
  completedValue?: number;
  targetValue?: number;
  unit?: string;
  progressPercentage: number;
  lastUpdatedAt?: any;
  completedAt?: any;
  notes?: string;
  isLocked?: boolean;
  lockType?: 'TIME_LOCK' | 'QC_INTERACTION';
  lockedAt?: any;
  lockDate?: string;
  createdAt: any;
  updatedAt?: any;
};

export type TimesheetWorkflowStatus = 'pending_eph' | 'in_negotiation' | 'approved_for_billing' | 'rejected';

export type EPHRecord = {
  assetId: string;
  assetType: string;
  plantNumber?: string;
  registrationNumber?: string;
  rate: number;
  rateType: 'wet' | 'dry';
  normalHours: number;
  saturdayHours: number;
  sundayHours: number;
  publicHolidayHours: number;
  breakdownHours: number;
  rainDayHours: number;
  strikeDayHours: number;
  totalRawHours: number;
  totalBillableHours: number;
  estimatedCost: number;
  rawTimesheets: TimesheetEntry[];
  status?: 'draft' | 'sent_to_subcontractor' | 'subcontractor_reviewed' | 'admin_finalized';
  subcontractorDisputedHours?: number;
  adminFinalizedHours?: number;
  disputeNotes?: string;
  disputedAt?: string;
  disputedBy?: string;
};

export type TimesheetEntry = {
  id: string;
  date: string;
  dayOfWeek: string;
  openHours: string;
  closeHours: string;
  closingHours?: string;
  totalHours: number;
  operatorName: string;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isBreakdown: boolean;
  isPublicHoliday: boolean;
  notes?: string;
  operatorNotes?: string;
  additionalNotes?: string;
  adminNotes?: string;
  billingNotes?: string;
  verifiedAt?: string;
  hasOriginalEntry?: boolean;
  originalEntryData?: Partial<TimesheetEntry>;
  originalEntryId?: string;
  adjustedBy?: string;
  adjustedAt?: string;
  isAdjustment?: boolean;
  agreedByRole?: 'Admin' | 'Plant Manager' | 'Operator';
};



// ============================================================================
// MASTER ACCOUNT & COMPANY OWNERSHIP SYSTEM
// ============================================================================

/**
 * Company Ownership - Defines ownership percentages for master accounts
 * Supports multi-owner companies with percentage-based ownership
 */
export type CompanyOwnership = {
  id: string;
  companyId: string;
  masterAccountId: string;
  masterAccountName: string; // Denormalized for performance
  ownershipPercentage: number; // Must be between 0-100
  status: 'active' | 'pending' | 'suspended' | 'revoked';
  votingRights: boolean; // Can vote on company decisions
  economicRights: boolean; // Receives financial benefits
  transferRestrictions?: string; // Any restrictions on transfer
  grantedAt: any;
  grantedBy: string; // Master Account ID who granted ownership
  approvedAt?: any;
  approvedBy?: string; // Required for ownership changes
  revokedAt?: any;
  revokedBy?: string;
  revocationReason?: string;
  notes?: string;
  createdAt: any;
  updatedAt?: any;
};

/**
 * Company Role - Defines functional roles separate from ownership
 * A master account can have both ownership and roles
 */
export type CompanyRole = {
  id: string;
  companyId: string;
  masterAccountId: string;
  masterAccountName: string; // Denormalized
  role: 'Director' | 'Admin' | 'Manager' | 'Viewer' | 'Custom';
  customRoleName?: string; // For custom roles
  permissions: string[]; // Array of permission strings
  status: 'active' | 'suspended' | 'revoked';
  assignedAt: any;
  assignedBy: string; // Master Account ID
  revokedAt?: any;
  revokedBy?: string;
  notes?: string;
  createdAt: any;
  updatedAt?: any;
};

/**
 * Master ID Verification - Tracks ID document verification process
 */
export type MasterIDVerification = {
  id: string;
  masterAccountId: string;
  nationalIdNumber: string;
  documentType: 'national_id' | 'passport' | 'drivers_license' | 'other';
  documentUrl: string; // Storage URL for uploaded document
  storagePath: string; // Firebase storage path
  status: IDVerificationStatus;
  submittedAt: any;
  reviewedAt?: any;
  reviewedBy?: string; // Admin ID who reviewed
  reviewNotes?: string;
  rejectionReason?: string;
  verifiedAt?: any;
  expiryDate?: any; // If document has expiry
  metadata?: {
    fileName?: string;
    fileSize?: number;
    mimeType?: string;
  };
  createdAt: any;
  updatedAt?: any;
};

/**
 * Fraud Dispute - Handles duplicate national ID conflicts
 */
export type FraudDispute = {
  id: string;
  nationalIdNumber: string; // The disputed ID number
  reportedBy: string; // Master Account ID reporting fraud
  reportedByName: string;
  reportedByEmail?: string;
  existingAccountId?: string; // The existing account with this ID
  existingAccountName?: string;
  newAccountId: string; // The new account attempting to use same ID
  newAccountName: string;
  status: 'pending' | 'under_investigation' | 'resolved' | 'dismissed';
  priority: 'low' | 'medium' | 'high' | 'critical';
  disputeType: 'duplicate_id' | 'identity_theft' | 'data_error' | 'other';
  explanation: string; // Explanation from reporter
  supportingDocuments?: {
    url: string;
    storagePath: string;
    fileName: string;
    uploadedAt: any;
  }[];
  investigationNotes?: string;
  resolution?: 'verified_original' | 'verified_new' | 'both_legitimate' | 'both_blocked' | 'data_corrected';
  resolvedAt?: any;
  resolvedBy?: string; // Admin ID
  resolutionDetails?: string;
  actionTaken?: string; // What action was taken (merge, block, etc.)
  reportedAt: any;
  createdAt: any;
  updatedAt?: any;
};

/**
 * Ownership Change Request - Multi-owner approval workflow
 */
export type OwnershipChangeRequest = {
  id: string;
  companyId: string;
  companyName: string;
  requestType: 'add_owner' | 'remove_owner' | 'change_percentage' | 'transfer_ownership';
  requestedBy: string; // Master Account ID
  requestedByName: string;
  status: 'pending' | 'approved' | 'rejected' | 'cancelled';
  // Change details
  targetMasterAccountId: string; // Account being added/removed/changed
  targetMasterAccountName: string;
  currentOwnershipPercentage?: number;
  proposedOwnershipPercentage?: number;
  transferToMasterAccountId?: string; // For transfers
  transferToMasterAccountName?: string;
  // Approval workflow
  requiredApprovals: number; // How many approvals needed
  currentApprovals: number; // How many received
  approvers: {
    masterAccountId: string;
    masterAccountName: string;
    approvedAt?: any;
    rejectedAt?: any;
    reason?: string;
  }[];
  // Metadata
  reason: string;
  notes?: string;
  createdAt: any;
  approvedAt?: any;
  rejectedAt?: any;
  processedAt?: any;
  processedBy?: string;
};

/**
 * Enhanced Audit Log for Master Account Operations
 */
/**
 * User Type for Permissions
 * Represents different user roles that can have permissions assigned
 */
export type UserTypeForPermissions = 
  | 'Master'
  | 'Planner'
  | 'HR'
  | 'HSE'
  | 'Plant Manager'
  | 'Supervisor'
  | 'Employee'
  | 'Operator'
  | 'Staff Manager'
  | 'Logistics Manager'
  | 'Onboarding & Inductions'
  | 'General Worker'
  | 'QC'
  | 'Surveyor'
  | 'Accounts'
  | 'Admin';

/**
 * Permission ID
 * Represents different permissions that can be granted
 */
export type PermissionId =
  | 'face_enrolment'
  | 'face_removal'
  | 'face_update';

/**
 * User Type Permissions
 * Maps a user type to its permissions
 */
export type UserTypePermissions = {
  id?: string;
  masterAccountId: string;
  userType: UserTypeForPermissions;
  permissions: {
    face_enrolment: boolean;
    face_removal: boolean;
    face_update: boolean;
  };
  updatedAt?: any;
  updatedBy?: string;
  createdAt: any;
};

export type MasterAccountAuditLog = {
  id: string;
  masterAccountId: string;
  masterAccountName: string;
  companyId?: string; // If action is company-specific
  companyName?: string;
  siteId?: string; // If action is site-specific
  siteName?: string;
  actionType: 
    | 'master_account_created'
    | 'master_account_verified'
    | 'id_document_uploaded'
    | 'id_verification_approved'
    | 'id_verification_rejected'
    | 'duplicate_id_detected'
    | 'fraud_dispute_created'
    | 'company_created'
    | 'company_ownership_added'
    | 'company_ownership_removed'
    | 'company_ownership_changed'
    | 'company_role_assigned'
    | 'company_role_revoked'
    | 'ownership_change_requested'
    | 'ownership_change_approved'
    | 'ownership_change_rejected'
    | 'payout_processed'
    | 'asset_edit'
    | 'timesheet_approval'
    | 'user_role_change'
    | 'restriction_applied'
    | 'restriction_lifted'
    | 'other';
  actionDescription: string;
  performedBy: string; // Master Account ID or system
  performedByName: string;
  targetEntity?: string; // ID of entity being acted upon
  targetEntityType?: 'master_account' | 'company' | 'ownership' | 'role' | 'site' | 'asset' | 'user' | 'timesheet';
  previousValue?: string; // JSON string of previous state
  newValue?: string; // JSON string of new state
  ipAddress?: string;
  userAgent?: string;
  metadata?: Record<string, any>; // Additional context
  timestamp: any;
  createdAt: any;
};



--- END OF FILE: types/index.ts ---


================================================================================
CATEGORY: Documentation
FILE: docs/EPH-AGREEMENT-WORKFLOW-COMPLETE.md
================================================================================

# EPH Agreement Workflow - Complete Implementation Guide

## Overview
This document describes the complete workflow for the EPH (Equipment/Plant Hours) agreement process between Admin and Subcontractors, including all UI components and backend integrations needed.

## Workflow States

### State 1: Initial EPH Generation (Current Implementation)
**Location**: `app/billing-config.tsx` - EPH Tab

**Status**:  Already Implemented

**Features**:
- Admin selects subcontractor and date range
- System generates EPH report from verified timesheets
- Shows asset cards with hours breakdown
- Can view individual timesheets
- Can generate PDF reports

### State 2: Admin Edits Hours (NEW)
**Status**:  Needs Integration

**Components Created**:
-  `EditEPHHoursModal.tsx` - Modal for admin to edit timesheet hours

**Implementation Needed**:
1. Add "Edit Hours" button to each EPH asset card (next to "Agree Hours")
2. When clicked, opens EditEPHHoursModal with current timesheet data
3. Admin can edit:
   - Total hours
   - Open/close times
   - Day conditions (breakdown, rain, strike, holiday)
   - Admin notes
4. On save:
   - Create/update a pending admin edit record (not yet agreed)
   - Mark EPH as "Edited - Pending Subcontractor Review"
   - Show visual indicator that admin has edited this timesheet

**Database Structure**:
```typescript
// Collection: ephPendingEdits
{
  id: string;
  originalTimesheetId: string;
  assetId: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedAt: Timestamp;
  
  // Edited values
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  
  // Status
  status: 'pending_review' | 'reviewed' | 'superseded';
  reviewedBy?: string;
  reviewedAt?: Timestamp;
  
  // Original values for comparison
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
}
```

### State 3: Send to Subcontractor (NEW)
**Status**:  Needs Integration

**Components Created**:
-  `SendConfirmationModal.tsx` - Modal to send EPH to subcontractor

**Implementation Needed**:
1. Add "Send to Subcontractor" button in EPH tab
2. When clicked, opens SendConfirmationModal
3. Admin enters subcontractor email and optional message
4. On send:
   - Generate PDF with admin edits (if any)
   - Send email to subcontractor with:
     - PDF attachment
     - Link to subcontractor portal (future)
     - Instructions for review
   - Update EPH status to "Sent to Subcontractor - Awaiting Response"
   
**Email Template**:
```
Subject: EPH Report for Review - [Period] - [Subcontractor Name]

Dear [Subcontractor Name],

Please find attached the Equipment/Plant Hours (EPH) report for the period [From Date] to [To Date].

Assets Included: [Count]
Total Hours: [Sum]

[Admin Message if provided]

Please review the hours and respond with any corrections or approval.

To submit your response, please reply to this email or access your portal at: [Portal Link]

Thank you,
[Company Name]
```

### State 4: Subcontractor Reviews and Edits (FUTURE)
**Status**:  Future Implementation

**Features Needed**:
- Subcontractor portal/app to view EPH
- Ability for subcontractor to:
  - View admin's version
  - Edit hours if they disagree
  - Add their own notes
  - Submit their version back

**Components to Create**:
- SubcontractorEPHView.tsx
- SubcontractorEditModal.tsx
- SubcontractorSubmitConfirmation.tsx

### State 5: Comparison View (NEW)
**Status**:  Needs Integration

**Components Created**:
-  `TimesheetComparisonModal.tsx` - Side-by-side comparison of versions

**Implementation Needed**:
1. Add "Compare Versions" button when multiple versions exist
2. Shows three columns:
   - Plant Manager (original)
   - Admin Edited (if exists)
   - Subcontractor Edited (if exists)
3. Highlights differences between versions
4. Admin uses this to make final decision

### State 6: Final Agreement (ENHANCED)
**Status**:  Needs Enhancement

**Current**: AgreedHoursModal exists but needs status tracking

**Implementation Needed**:
1. After comparison, admin clicks "Agree Hours"
2. Opens enhanced AgreedHoursModal with:
   - Comparison summary
   - Final agreed values (can still be edited)
   - Status indicator (who agreed, when)
3. On agreement:
   - Creates agreed timesheet record
   - Marks all pending edits as "superseded"
   - Moves to "Process Payments" tab
   - Sends confirmation email to subcontractor

### State 7: Process Payments Tab (ENHANCED)
**Status**:  Needs Enhancement

**Current**: PlantAssetsTimesheetsTab shows agreed timesheets

**Enhancements Needed**:
1. Group by agreement status:
   - "Fully Agreed" - Both parties agreed
   - "Admin Override" - Admin finalized despite subcontractor edit
   - "Auto-Agreed" - No edits, auto-approved
2. Add filters:
   - By subcontractor
   - By agreement date
   - By status
3. Show agreement metadata:
   - Who agreed (admin name)
   - When agreed
   - If there were edits
   - Final vs original hours difference

## UI Component Details

### 1. EditEPHHoursModal
**Purpose**: Admin edits timesheet hours before sending to subcontractor

**Props**:
```typescript
{
  visible: boolean;
  onClose: () => void;
  onSave: (editedValues: EditedValues) => Promise<void>;
  timesheet: TimesheetEntry | null;
}
```

**Features**:
- Shows current timesheet data
- Warning banner about requiring re-approval
- Edit all hour fields
- Edit day conditions (checkboxes)
- Admin notes field
- Validation before save

### 2. TimesheetComparisonModal
**Purpose**: Side-by-side comparison of Plant Manager, Admin, and Subcontractor versions

**Props**:
```typescript
{
  visible: boolean;
  onClose: () => void;
  comparison: {
    plantManager: TimesheetEntry;
    adminEdited?: TimesheetEntry;
    subcontractorEdited?: TimesheetEntry;
  } | null;
}
```

**Features**:
- Three-column layout with arrows showing changes
- Highlights differences with colored backgrounds
- Shows all fields: hours, times, conditions, notes
- Legend explaining color coding
- Read-only comparison view

### 3. SendConfirmationModal
**Purpose**: Send EPH report to subcontractor for review

**Props**:
```typescript
{
  visible: boolean;
  onClose: () => void;
  onSend: (recipientEmail: string, message: string) => Promise<void>;
  subcontractorName: string;
  assetCount: number;
  dateRange: { from: Date; to: Date };
}
```

**Features**:
- Shows EPH summary
- Recipient email field (required)
- Optional message field
- Informational notes about the process
- Validation before sending

## Integration Steps

### Step 1: Update billing-config.tsx

Add state for pending edits:
```typescript
const [pendingEdits, setPendingEdits] = useState<Map<string, any>>(new Map());
const [editModalVisible, setEditModalVisible] = useState(false);
const [comparisonModalVisible, setComparisonModalVisible] = useState(false);
const [sendModalVisible, setSendModalVisible] = useState(false);
const [selectedTimesheetForEdit, setSelectedTimesheetForEdit] = useState<any>(null);
const [selectedComparison, setSelectedComparison] = useState<any>(null);
```

Add buttons to EPH card actions:
```typescript
<View style={styles.ephActions}>
  <TouchableOpacity
    style={styles.editHoursButton}
    onPress={() => handleEditHours(item.assetId)}
  >
    <Edit3 size={18} color="#1e3a8a" />
    <Text style={styles.editHoursButtonText}>Edit Hours</Text>
  </TouchableOpacity>
  
  {hasPendingEdits && (
    <TouchableOpacity
      style={styles.compareButton}
      onPress={() => handleCompareVersions(item.assetId)}
    >
      <GitCompare size={18} color="#3b82f6" />
      <Text style={styles.compareButtonText}>Compare Versions</Text>
    </TouchableOpacity>
  )}
  
  <TouchableOpacity
    style={styles.viewTimesheetsButton}
    onPress={() => handleViewTimesheets(item.assetId)}
  >
    <ClipboardList size={18} color="#1e3a8a" />
    <Text style={styles.viewTimesheetsButtonText}>View Timesheets</Text>
  </TouchableOpacity>
  
  <TouchableOpacity
    style={styles.agreeHoursButton}
    onPress={() => handleOpenAgreedHoursModal(item.assetId)}
  >
    <Check size={18} color="#ffffff" />
    <Text style={styles.agreeHoursButtonText}>Agree Hours</Text>
  </TouchableOpacity>
</View>
```

Add "Send to Subcontractor" button at top level:
```typescript
<TouchableOpacity
  style={styles.sendToSubButton}
  onPress={() => setSendModalVisible(true)}
  disabled={selectedAssetIds.size === 0}
>
  <Send size={18} color="#ffffff" />
  <Text style={styles.sendToSubButtonText}>Send to Subcontractor</Text>
</TouchableOpacity>
```

Add modals:
```typescript
<EditEPHHoursModal
  visible={editModalVisible}
  onClose={() => {
    setEditModalVisible(false);
    setSelectedTimesheetForEdit(null);
  }}
  onSave={handleSaveEdit}
  timesheet={selectedTimesheetForEdit}
/>

<TimesheetComparisonModal
  visible={comparisonModalVisible}
  onClose={() => {
    setComparisonModalVisible(false);
    setSelectedComparison(null);
  }}
  comparison={selectedComparison}
/>

<SendConfirmationModal
  visible={sendModalVisible}
  onClose={() => setSendModalVisible(false)}
  onSend={handleSendToSubcontractor}
  subcontractorName={subcontractors.find(s => s.id === selectedSubcontractor)?.name || ''}
  assetCount={selectedAssetIds.size}
  dateRange={{ from: startDate, to: endDate }}
/>
```

### Step 2: Create Pending Edits Manager

Create `utils/ephPendingEditsManager.ts`:
```typescript
import { collection, doc, setDoc, getDocs, query, where, updateDoc, Timestamp } from 'firebase/firestore';
import { db } from '@/config/firebase';

export async function createPendingEdit(params: {
  originalTimesheetId: string;
  assetId: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
}): Promise<string> {
  const editRef = doc(collection(db, 'ephPendingEdits'));
  const editId = editRef.id;
  
  await setDoc(editRef, {
    ...params,
    id: editId,
    status: 'pending_review',
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  });
  
  return editId;
}

export async function getPendingEditsByAsset(
  assetId: string,
  masterAccountId: string
): Promise<any[]> {
  const q = query(
    collection(db, 'ephPendingEdits'),
    where('assetId', '==', assetId),
    where('masterAccountId', '==', masterAccountId),
    where('status', '==', 'pending_review')
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

export async function supersedePendingEdit(editId: string): Promise<void> {
  await updateDoc(doc(db, 'ephPendingEdits', editId), {
    status: 'superseded',
    updatedAt: Timestamp.now(),
  });
}
```

### Step 3: Create Email Service

Create `utils/ephEmailService.ts`:
```typescript
import * as MailComposer from 'expo-mail-composer';
import { Platform, Alert } from 'react-native';

export async function sendEPHToSubcontractor(params: {
  recipientEmail: string;
  message: string;
  pdfUri: string;
  pdfFileName: string;
  subcontractorName: string;
  dateRange: { from: Date; to: Date };
  assetCount: number;
  totalHours: number;
  companyName: string;
}): Promise<void> {
  const { recipientEmail, message, pdfUri, pdfFileName, subcontractorName, dateRange, assetCount, totalHours, companyName } = params;
  
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };
  
  const subject = `EPH Report for Review - ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)} - ${subcontractorName}`;
  
  const body = `Dear ${subcontractorName},

Please find attached the Equipment/Plant Hours (EPH) report for the period ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)}.

Assets Included: ${assetCount}
Total Hours: ${totalHours.toFixed(1)}h

${message ? `\n${message}\n` : ''}
Please review the hours and respond with any corrections or approval.

Thank you,
${companyName}`;
  
  if (Platform.OS === 'web') {
    console.log('[EPH Email] Web platform - opening email composer simulation');
    Alert.alert(
      'Email Composer',
      `Would open email to:\n${recipientEmail}\n\nSubject: ${subject}\n\nWith PDF attachment: ${pdfFileName}`,
      [{ text: 'OK' }]
    );
    return;
  }
  
  const isAvailable = await MailComposer.isAvailableAsync();
  if (!isAvailable) {
    throw new Error('Email composer not available on this device');
  }
  
  await MailComposer.composeAsync({
    recipients: [recipientEmail],
    subject,
    body,
    attachments: [pdfUri],
  });
}
```

### Step 4: Update Process Payments Tab

Enhance `PlantAssetsTimesheetsTab.tsx`:

Add status badges to groups:
```typescript
const getAgreementStatus = (group: TimesheetGroup): 'fully_agreed' | 'admin_override' | 'auto_agreed' => {
  // Logic to determine agreement status based on metadata
  return 'fully_agreed';
};

// In renderGroup, add status badge:
<View style={styles.statusBadge}>
  <Text style={styles.statusBadgeText}>
    {status === 'fully_agreed' && ' Fully Agreed'}
    {status === 'admin_override' && ' Admin Override'}
    {status === 'auto_agreed' && ' Auto-Agreed'}
  </Text>
</View>
```

Add agreement metadata section:
```typescript
<View style={styles.agreementMeta}>
  <Text style={styles.metaLabel}>Agreed By:</Text>
  <Text style={styles.metaValue}>{group.agreedBy || 'N/A'}</Text>
  <Text style={styles.metaLabel}>Agreed At:</Text>
  <Text style={styles.metaValue}>
    {group.agreedAt ? new Date(group.agreedAt).toLocaleDateString('en-GB') : 'N/A'}
  </Text>
  {group.hoursDifference && (
    <>
      <Text style={styles.metaLabel}>Hours Difference:</Text>
      <Text style={[styles.metaValue, group.hoursDifference > 0 ? styles.metaPositive : styles.metaNegative]}>
        {group.hoursDifference > 0 ? '+' : ''}{group.hoursDifference.toFixed(1)}h
      </Text>
    </>
  )}
</View>
```

## Required Firebase Indexes

Add to `firestore.indexes.json`:
```json
{
  "indexes": [
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    }
  ]
}
```

## Testing Checklist

### EPH Generation
- [ ] Select subcontractor and date range
- [ ] Generate EPH report
- [ ] View individual timesheets
- [ ] Generate PDF report

### Admin Edits
- [ ] Click "Edit Hours" on asset card
- [ ] Modal opens with current data
- [ ] Edit total hours
- [ ] Edit open/close times
- [ ] Toggle day conditions
- [ ] Add admin notes
- [ ] Save successfully
- [ ] Pending edit badge appears on card

### Comparison
- [ ] Click "Compare Versions" when edits exist
- [ ] See Plant Manager original
- [ ] See Admin edited version
- [ ] Differences highlighted correctly
- [ ] All fields compared (hours, conditions, notes)

### Send to Subcontractor
- [ ] Click "Send to Subcontractor"
- [ ] Enter valid email
- [ ] Add optional message
- [ ] Send successfully
- [ ] Email received with PDF attachment

### Agreement
- [ ] Click "Agree Hours" after edits
- [ ] Review comparison
- [ ] Enter final agreed values
- [ ] Save agreement
- [ ] Timesheet moves to Process Payments tab
- [ ] Pending edits marked as superseded

### Process Payments
- [ ] See agreed timesheets
- [ ] Status badges correct
- [ ] Agreement metadata visible
- [ ] Can filter by status
- [ ] Can generate final reports

## Production Deployment Notes

### Email Service Setup
1. Configure email service (SendGrid, AWS SES, etc.)
2. Set up email templates in Firebase Functions
3. Add environment variables for email credentials
4. Test email delivery in staging

### Subcontractor Portal
1. Create subcontractor authentication system
2. Build subcontractor dashboard
3. Implement edit and submission workflow
4. Add notifications for new EPH reports

### Security Rules
Update Firestore security rules:
```javascript
match /ephPendingEdits/{editId} {
  allow read: if isAdmin() || isSubcontractor(resource.data.subcontractorId);
  allow create: if isAdmin() || isSubcontractor(request.resource.data.subcontractorId);
  allow update: if isAdmin() && request.resource.data.status == 'reviewed';
  allow delete: if isAdmin();
}
```

## Future Enhancements

1. **Automated Reminders**: Send reminder emails if subcontractor hasn't responded
2. **Approval Deadlines**: Set deadlines for subcontractor response
3. **Bulk Operations**: Edit/send multiple assets at once
4. **Audit Trail**: Complete history of all edits and agreements
5. **Dispute Resolution**: Workflow for disagreements
6. **Integration**: Connect with accounting software for payments
7. **Mobile App**: Subcontractor mobile app for easier access
8. **Push Notifications**: Real-time notifications for status changes

## Support

For questions or issues, contact the development team or refer to:
- `docs/BILLING-TIMESHEET-WORKFLOW-CLARIFICATION.md`
- `docs/TIMESHEET-PDF-EMAIL-SYSTEM.md`
- `docs/EPH-AGREEMENT-IMPLEMENTATION-STATUS.md`


--- END OF FILE: docs/EPH-AGREEMENT-WORKFLOW-COMPLETE.md ---


================================================================================
CATEGORY: Documentation
FILE: docs/EPH-AGREEMENT-IMPLEMENTATION-STATUS.md
================================================================================

# EPH/Timesheet Agreement System - Implementation Summary

##  Recently Completed (2025-12-22)

### PDF Billing Calculation Fix
- **Issue**: PDF was recalculating hours from meter readings instead of using pre-calculated agreed hours from the actual timesheet
- **Root Cause**: `billing-config.tsx` was not passing `actualHours` and `billableHours` to the PDF generator, causing it to fall back to recalculating from `openHours` and `closeHours`
- **Fix Applied**:
  - Added `billingResultsByDate` Map to store pre-calculated billable hours during EPH generation
  - Updated PDF data preparation in `handleGeneratePDFReport` to populate `actualHours` and `billableHours` fields
  - Updated "Send to Subcontractor" PDF generation to use the same fix
  - PDF now correctly uses agreed hours without recalculation from meter readings
- **Files Changed**:
  - `app/billing-config.tsx`: Added billing results mapping and updated PDF data structure
  - `docs/BILLING-TIMESHEET-WORKFLOW-CLARIFICATION.md`: Updated with fix details

##  Completed

### 1. Documentation
- **EPH-SUBCONTRACTOR-AGREEMENT-WORKFLOW.md**: Comprehensive workflow documentation outlining the entire process from EPH generation to final payment processing
- Defines database structure for `pendingAgreements` and `agreedTimesheets` collections
- Specifies workflow states and transitions
- Security considerations and audit requirements

### 2. Core Utilities
- **utils/pendingAgreementManager.ts**: Complete manager for handling agreement negotiations between admin and subcontractors
  - Create pending agreements
  - Update subcontractor responses
  - Accept/reject agreements
  - Query functions for both parties
  - Full TypeScript types and interfaces

### 3. Existing System
- **utils/agreedTimesheetManager.ts**: Already exists and handles final agreed timesheets
- **utils/timesheetPdfGenerator.ts**: PDF generation for reports (needs updates for new workflow)
- **components/accounts/AgreedHoursModal.tsx**: Modal for agreeing hours (needs enhancements)
- **app/billing-config.tsx**: Main admin interface with three tabs (Config, EPH, Process Payments)

##  Required Changes

### Phase 1: Admin Interface Updates (billing-config.tsx)

#### 1.1 Tab Rename 
- Tab is already renamed to "Process Payments"
- Shows properly in the UI

#### 1.2 Add "Edit Hours" Button to EPH
Currently, EPH shows:
- "View Timesheets" button
- "Agree Hours" button (goes directly to final agreement)

**Need to add:**
```typescript
- "Edit Hours" button  Opens modal to edit individual timesheet hours
  - Input fields for each hour type (normal, saturday, sunday, etc.)
  - Notes field for admin comments
  - Save as admin version (not yet sent to subcontractor)
  - Visual indicator if hours have been edited by admin
```

#### 1.3 Add "Send to Subcontractor" Button
After admin edits (or decides not to edit), they should:
```typescript
- Click "Send to Subcontractor"
- Creates pendingAgreement record
- Sets status: 'pending_subcontractor_review'
- Sends notification (email/in-app)
- Button changes to "Awaiting Response" (disabled, shows status)
```

#### 1.4 Display Subcontractor Response
When subcontractor responds:
```typescript
- Badge appears: "Subcontractor Responded"
- "View Response" button  Opens comparison modal
- Shows three columns:
  - Original (operator + plant manager)
  - Admin's version (if edited)
  - Subcontractor's suggested changes
- Highlights differences in red/green
```

#### 1.5 Update "Agree Hours" Button Logic
Current: Directly creates agreed timesheet
**New:** 
```typescript
- Only enabled after reviewing subcontractor response (if any)
- Or if sent directly without admin edits
- Final confirmation modal:
  "You are about to finalize this timesheet. 
   Admin version will be used as source of truth.
   This action cannot be undone."
- On confirm:
  1. Create agreedTimesheet (existing function)
  2. Update pendingAgreement.status = 'agreed'
  3. Move to Process Payments tab
```

### Phase 2: New Components Needed

#### 2.1 Edit Hours Modal (`components/accounts/EditEPHHoursModal.tsx`)
```typescript
- Similar to AgreedHoursModal but for admin editing
- Shows current hours from EPH
- Allows editing all hour types:
  - normalHours
  - saturdayHours
  - sundayHours
  - publicHolidayHours
  - breakdownHours
  - rainDayHours
  - strikeDayHours
- Admin notes field
- Save button  Saves to local state (not yet sent)
- Visual feedback: "Edited by you"
```

#### 2.2 Comparison Modal (`components/accounts/TimesheetComparisonModal.tsx`)
```typescript
- Three-column layout (responsive)
- Column 1: Original
- Column 2: Admin's version
- Column 3: Subcontractor's version
- Diff highlighting
- Notes from both parties
- "Accept Subcontractor Changes" button
- "Keep My Version" button
- "Edit Again" button
```

#### 2.3 Send to Subcontractor Confirmation Modal
```typescript
- Confirms action
- Shows what will be sent
- Option to add a message
- "Send" button  creates pendingAgreement
```

### Phase 3: Process Payments Tab Enhancement

Current state: Shows individual timesheets
**Needs:**
```typescript
- Group by agreement
- Show summary:
  - Subcontractor name
  - Date range
  - Total hours
  - Agreement date
  - Status badge
- Expandable to show individual days
- "Generate Invoice PDF" button
- "Mark as Paid" button
- Filter by status: All | Pending Payment | Paid
```

### Phase 4: Subcontractor Portal (Separate App/Module)

**New standalone app or module** for subcontractors to access:

#### 4.1 Authentication
- Separate login (email + password or magic link)
- Tied to subcontractor record
- Can only see their own data

#### 4.2 Dashboard
```typescript
- Shows pending reviews count
- Recent agreements
- Quick stats (total hours this month, etc.)
```

#### 4.3 Pending Reviews Page
```typescript
- List all EPH reports awaiting review
- Each card shows:
  - Asset type & number
  - Date range
  - Proposed hours by admin
  - "Review" button
```

#### 4.4 Review & Edit Page
```typescript
- Shows admin's proposed version
- Editable fields to suggest changes
- Notes field to explain changes
- Two buttons:
  - "Accept"  No changes, admin version is good
  - "Suggest Changes"  Submit edited version
```

#### 4.5 Agreement History
```typescript
- Past agreed timesheets
- Download PDFs
- View details
```

##  Implementation Checklist

### Immediate Next Steps (Start Here)

- [ ] **Create EditEPHHoursModal component**
  - Copy AgreedHoursModal as template
  - Modify for admin editing (not final agreement)
  - Add validation
  - Connect to billing-config state

- [ ] **Update EPH card in billing-config.tsx**
  - Add "Edit Hours" button
  - Track edited state per asset
  - Show visual indicator if edited
  - Update ephData state to include editedVersion

- [ ] **Create Send to Subcontractor flow**
  - Button in EPH card
  - Confirmation modal
  - Call createPendingAgreement utility
  - Update UI to show "Awaiting Response" state

- [ ] **Add pending agreement status checks**
  - On EPH load, check for existing pendingAgreement
  - Show current status
  - Update button states based on status

- [ ] **Create TimesheetComparisonModal**
  - Side-by-side comparison
  - Diff highlighting
  - Action buttons

- [ ] **Update Process Payments tab**
  - Query agreedTimesheets collection
  - Group by agreement
  - Add filters and actions

### Database Setup

- [ ] **Create Firestore indexes**
```
Collection: pendingAgreements
- masterAccountId, status (ascending)
- subcontractorId, status (ascending)
- masterAccountId, subcontractorId, status (ascending)
- masterAccountId, createdAt (descending)
- subcontractorId, createdAt (descending)

Collection: agreedTimesheets
- masterAccountId, status, agreedAt (descending)
- subcontractorId, status, agreedAt (descending)
- masterAccountId, date (ascending)
- masterAccountId, date (descending)
```

- [ ] **Set up Firebase security rules**
```javascript
match /pendingAgreements/{agreementId} {
  // Admin can read/write their master account's agreements
  allow read, write: if request.auth != null && 
    request.auth.token.masterAccountId == resource.data.masterAccountId;
  
  // Subcontractor can read their own agreements
  allow read: if request.auth != null && 
    request.auth.token.subcontractorId == resource.data.subcontractorId;
  
  // Subcontractor can update their response
  allow update: if request.auth != null && 
    request.auth.token.subcontractorId == resource.data.subcontractorId &&
    resource.data.status == 'pending_subcontractor_review';
}

match /agreedTimesheets/{timesheetId} {
  // Admin can read/write
  allow read, write: if request.auth != null && 
    request.auth.token.masterAccountId == resource.data.masterAccountId;
  
  // Subcontractor can read their agreed timesheets
  allow read: if request.auth != null && 
    request.auth.token.subcontractorId == resource.data.subcontractorId;
}
```

### Future Enhancements

- [ ] Email notifications
  - Admin  Subcontractor: "New EPH for review"
  - Subcontractor  Admin: "Response submitted"
  - Admin  Subcontractor: "Agreement finalized"

- [ ] Push notifications (if mobile app)

- [ ] Real-time updates using Firestore listeners

- [ ] Audit log for all changes

- [ ] PDF enhancements to show all versions

- [ ] Bulk operations (agree multiple assets at once)

- [ ] Dispute resolution workflow

##  Current State vs Target State

### Current (As-Is)
```
1. EPH generated
2. Admin clicks "Agree Hours" immediately
3. Goes directly to agreedTimesheets
4. No subcontractor involvement
5. Admin is source of truth by default
```

### Target (To-Be)
```
1. EPH generated
2. Admin reviews and optionally edits
3. Admin sends to subcontractor
4. Subcontractor reviews and can suggest changes
5. Admin makes final decision (with or without subcontractor input)
6. Final agreement  agreedTimesheets  Process Payments
7. Both parties have visibility and input
8. Clear audit trail
```

##  Questions for User

1. **Subcontractor Portal**: Do you want this as:
   - A. Separate mobile/web app?
   - B. Part of the same app with different role/login?
   - C. Web-only portal?

2. **Notifications**: Priority for:
   - A. Email notifications?
   - B. Push notifications?
   - C. In-app only?

3. **Edit Scope**: When admin edits, should they edit:
   - A. Individual timesheet entries (per day)?
   - B. Totals only (aggregate hours)?
   - C. Both options available?

4. **Subcontractor Response Time**: Should there be:
   - A. Deadline for subcontractor to respond?
   - B. Auto-approve if no response after X days?
   - C. Manual follow-up only?

5. **Process Payments Tab**: Should it also show:
   - A. Invoicing functionality?
   - B. Payment tracking?
   - C. Integration with accounting software?

##  Quick Start for Next Development Session

**To continue implementing this workflow:**

1. Read `docs/EPH-SUBCONTRACTOR-AGREEMENT-WORKFLOW.md` for full context
2. Start with creating `components/accounts/EditEPHHoursModal.tsx`
3. Update `app/billing-config.tsx` to add "Edit Hours" button
4. Use `utils/pendingAgreementManager.ts` for all agreement operations
5. Test the flow: EPH  Edit  Send  (Manual subcontractor response simulation)  Review  Agree  Process Payments

##  Notes

- Admin version is ALWAYS the source of truth (as per requirements)
- Subcontractor can only suggest changes, not override
- All changes are audited with timestamps and user IDs
- Agreed timesheets are immutable once created
- System supports the workflow even if subcontractor doesn't respond (admin can proceed)

---

**Last Updated:** 2025-12-11
**Status:** Documentation and core utilities complete, UI implementation pending


--- END OF FILE: docs/EPH-AGREEMENT-IMPLEMENTATION-STATUS.md ---


================================================================================
CATEGORY: Documentation
FILE: docs/EPH-FREE-USER-WORKFLOW.md
================================================================================

# EPH System & Free User Workflow

## Overview

This document describes the complete EPH (Equipment Per Hour) workflow, including how free users interact with the system. Both free and enterprise users share the same core workflowthe only difference is feature access restrictions for free users.

---

## User Types & Access

### Enterprise Users
- Full access to all features
- Can create sites, manage employees, generate reports
- Can hire plant assets from subcontractors or free users
- Generate and send EPH reports

### Free Users
- Same workflow and UI as enterprise users
- Most features are locked with explanatory popups
- Can list plant assets in the marketplace
- Receive EPH reports from enterprise clients via EPH Inbox
- Can review and approve/dispute hours

**Important:** Free users land on the same HOME screen as enterprise users. Locked modules display a popup explaining the feature with options to unlock.

---

## EPH Workflow Overview

### Enterprise  Asset Owner Flow

```

                                                                 
  Enterprise User                    Asset Owner                 
  (Hires assets)                     (Subcontractor or Free User)
                                                                 
                                  
   Record                           EPH Inbox               
   Timesheets                                               
                                  
                                                               
                                                               
      Send Report                 
   Billing        EPH Report              
   Config                           Created                 
                                  
                                                                
                                                                
                                                 
                                      Review &                
                                      Approve                 
                                                 
                                                                 

```

---

## Data Structures

### PlantAsset Type (Extended)

```typescript
export type PlantAsset = {
  // Existing fields...
  assetId: string;
  assetName: string;
  assetType: string;
  
  // Owner identification
  ownerType: 'company' | 'subcontractor';
  ownerId?: string;                    // For subcontractors (existing)
  ownerMasterAccountId?: string;       // Free user's master account ID
  ownerEmail?: string;                 // Contact email for EPH reports
  ownerContactName?: string;           // Contact name
  ownerName?: string;                  // Company/business name
}
```

**Logic:**
- `ownerType === 'subcontractor'`  Use existing subcontractor workflow with `ownerId`
- `ownerType === 'company'` AND `ownerMasterAccountId`  Free user owner

### EPHReport Type

```typescript
export type EPHReport = {
  id: string;
  reportId: string;
  status: 'draft' | 'sent' | 'reviewed' | 'agreed' | 'disputed';
  
  // Recipient info
  recipientType: 'subcontractor' | 'free_user';
  recipientId: string;
  recipientName: string;
  recipientEmail?: string;
  recipientMasterAccountId?: string;
  
  // Sender info
  senderMasterAccountId: string;
  senderCompanyName: string;
  siteId: string;
  siteName?: string;
  
  // Report data
  dateRangeFrom: string;
  dateRangeTo: string;
  assetIds: string[];
  totalAssets: number;
  totalHours: number;
  totalCost: number;
  message?: string;
  pdfUrl?: string;
  
  // Timeline
  sentAt?: Timestamp;
  sentBy?: string;
  reviewedAt?: Timestamp;
  reviewedBy?: string;
  agreedAt?: Timestamp;
  agreedBy?: string;
  disputeNotes?: string;
  
  createdAt: Timestamp;
  updatedAt?: Timestamp;
}
```

---

## Workflow Steps

### Step 1: Enterprise Generates EPH Report

Location: `app/billing-config.tsx`  EPH Tab

```typescript
const determineAssetOwner = (asset: PlantAsset) => {
  if (asset.ownerType === 'subcontractor' && asset.ownerId) {
    return {
      recipientType: 'subcontractor',
      recipientId: asset.ownerId,
      recipientName: asset.ownerName || 'Unknown Subcontractor',
    };
  }
  
  if (asset.ownerType === 'company' && asset.ownerMasterAccountId) {
    return {
      recipientType: 'free_user',
      recipientId: asset.ownerMasterAccountId,
      recipientName: asset.ownerName || asset.ownerContactName || 'Free User',
      recipientMasterAccountId: asset.ownerMasterAccountId,
    };
  }
  
  throw new Error('Cannot determine asset owner');
};
```

When "Send to Owner" is clicked:
1. Generate PDF report
2. Identify owner type (subcontractor vs free user)
3. Create EPH report record in Firestore
4. Send email notification

### Step 2: Free User Receives Notification

Email notification sent to owner:
```
Subject: EPH Report for Review - [Company Name]

Dear [Owner Name],

[Company Name] has sent you an Equipment/Plant Hours (EPH) 
report for the period [Start Date] to [End Date].

Your Assets: [Count]
Total Hours: [Hours]h
Estimated Cost: R[Amount]

Please login to review and approve the hours.

[View EPH Report]
```

### Step 3: Free User Reviews in EPH Inbox

Location: `app/eph-inbox.tsx`

UI Layout:
```

 EPH Inbox                           
   
                                     
  ABC Construction Ltd             
    Date: 1 Dec - 15 Dec 2025        
    Assets: 3                        
    Hours: 285h                      
    Cost: R128,250                   
    Status:  Awaiting Review       
    [View Details]                   
                                     
  XYZ Builders                     
    Date: 1 Dec - 7 Dec 2025         
    Assets: 1                        
    Hours: 48h                       
    Cost: R21,600                    
    Status:  Agreed                
    [View Details]                   
                                     

```

### Step 4: Free User Takes Action

**Approve Hours:**
```typescript
const approveEPH = async (reportId: string) => {
  await updateDoc(doc(db, 'ephReports', reportId), {
    status: 'agreed',
    reviewedAt: Timestamp.now(),
    reviewedBy: currentUser.userId,
    agreedAt: Timestamp.now(),
    agreedBy: currentUser.userId,
    updatedAt: Timestamp.now(),
  });
};
```

**Dispute Hours:**
```typescript
const disputeEPH = async (reportId: string, notes: string) => {
  await updateDoc(doc(db, 'ephReports', reportId), {
    status: 'disputed',
    reviewedAt: Timestamp.now(),
    reviewedBy: currentUser.userId,
    disputeNotes: notes,
    updatedAt: Timestamp.now(),
  });
};
```

### Step 5: Enterprise Receives Response

Status updates visible in billing-config EPH tab:
-  **Agreed**  Can proceed to payment
-  **Disputed**  View notes, edit hours, resend

---

## Firebase Configuration

### Security Rules

```javascript
match /ephReports/{reportId} {
  allow read: if request.auth != null;
  
  allow create: if request.auth != null;
  
  allow update: if request.auth != null && (
    resource.data.senderMasterAccountId == request.auth.token.masterAccountId ||
    resource.data.recipientMasterAccountId == request.auth.token.masterAccountId
  );
  
  allow delete: if request.auth != null && 
    resource.data.senderMasterAccountId == request.auth.token.masterAccountId;
}
```

### Required Indexes

```json
{
  "indexes": [
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "recipientMasterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "recipientMasterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "senderMasterAccountId", "order": "ASCENDING" },
        { "fieldPath": "sentAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "senderMasterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "sentAt", "order": "DESCENDING" }
      ]
    }
  ]
}
```

---

## Implementation Status

### Completed
- [x] Extended PlantAsset type with owner fields
- [x] Created EPHReport type (`types/ephReport.ts`)
- [x] Created EPH report manager (`utils/ephReportManager.ts`)
- [x] Created EPH inbox screen (`app/eph-inbox.tsx`)
- [x] Free user routing aligned with enterprise workflow

### Pending
- [ ] Update billing-config.tsx to use EPH report system
- [ ] Add EPH inbox navigation for free users in settings
- [ ] Deploy Firebase indexes
- [ ] Deploy Firebase security rules
- [ ] End-to-end testing

---

## Testing Checklist

### Scenario 1: Enterprise  Free User EPH Flow
1. Enterprise has a site with allocated plant assets from free user
2. Enterprise goes to Billing Config  EPH tab
3. Selects date range and free user's assets
4. Clicks "Send to Owner"
5. **Expected:** EPH report created, email sent, free user sees report in inbox

### Scenario 2: Free User Approves EPH
1. Free user logs in
2. Opens EPH Inbox
3. Reviews pending report
4. Clicks "Approve"
5. **Expected:** Status changes to "agreed", enterprise notified

### Scenario 3: Free User Disputes EPH
1. Free user opens report
2. Clicks "Dispute"
3. Enters notes
4. **Expected:** Status changes to "disputed", notes saved

### Scenario 4: Mixed Owners
1. Site has assets from both subcontractor and free user
2. Enterprise generates EPH for all
3. **Expected:** Separate reports created for each owner

---

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Email not sent | Check `ownerEmail` is set on PlantAsset |
| EPH Inbox empty | Verify `ownerMasterAccountId` matches user's master account |
| Assets not showing | Ensure assets have timesheets and are verified |
| Cannot group by owner | Check all assets have proper owner info |

---

## Key Files

| File | Purpose |
|------|---------|
| `app/billing-config.tsx` | Enterprise generates/sends EPH |
| `app/eph-inbox.tsx` | Free user receives/reviews EPH |
| `types/ephReport.ts` | EPH report type definitions |
| `utils/ephReportManager.ts` | EPH report CRUD operations |
| `types/index.ts` | PlantAsset type with owner fields |

---

## Future Enhancements

1. **Auto-approval** - If no response in X days
2. **Partial approval** - Approve some assets, dispute others
3. **Payment tracking** - Link to payment confirmation
4. **Analytics dashboard** - Free user income by client
5. **Contract terms** - Store agreed rates
6. **Multi-currency** - Support different currencies
7. **Tax documents** - Auto-generate invoices


--- END OF FILE: docs/EPH-FREE-USER-WORKFLOW.md ---


================================================================================
CATEGORY: Documentation
FILE: docs/EPH-SUBCONTRACTOR-AGREEMENT-WORKFLOW.md
================================================================================

# EPH/Timesheet Subcontractor Agreement Workflow

## Overview
This document outlines the comprehensive workflow for Equipment/Plant Hours (EPH) reporting and timesheet agreement between administrators and subcontractors.

## System Architecture

### Key Components
1. **Admin Interface** - Billing Management (billing-config.tsx)
2. **Subcontractor Interface** - To be implemented (separate portal/app)
3. **Agreement System** - Manages negotiation and finalization
4. **Process Payments Tab** - Final approved timesheets ready for billing

## Workflow States

### 1. Initial State: EPH Generation
- Admin selects subcontractor and date range
- System generates EPH report from verified timesheets
- Shows all assets with hours breakdown
- **State:** `draft`

### 2. Admin Review & Edit
- Admin reviews the EPH report
- Can edit hours using "Edit Hours" button
- Edits are saved as `adminEditedVersion`
- **State:** `admin_edited`

### 3. Send to Subcontractor
- Admin clicks "Send to Subcontractor" after editing (or directly if no edits)
- Creates a `pendingAgreement` record in Firestore
- Subcontractor receives notification
- **State:** `pending_subcontractor_review`

### 4. Subcontractor Review & Edit
- Subcontractor views the admin's version in their portal
- Can suggest changes by editing their version
- Edits are saved as `subcontractorSuggestedVersion`
- Can either:
  - Accept admin's version (no edits)
  - Propose changes and submit
- **State:** `subcontractor_responded`

### 5. Admin Final Review
- Admin sees subcontractor's suggested changes (if any)
- Can view side-by-side comparison:
  - Original verified timesheet
  - Admin's edited version
  - Subcontractor's suggested version
- Admin makes final decision (admin version is source of truth)
- Can accept subcontractor's suggestions or keep their own version
- **State:** `admin_final_review`

### 6. Agreement Finalization
- Admin clicks "Agree Hours" button
- This finalizes the timesheet:
  - Creates record in `agreedTimesheets` collection
  - Marks as `approved_for_billing`
  - Moves to "Process Payments" tab
- **State:** `agreed`

### 7. Process Payments
- All agreed timesheets appear in this tab
- Can generate final PDF reports for invoicing
- Can send to accounting/billing systems
- **State:** `ready_for_payment`

## Database Structure

### Collection: `pendingAgreements`
```typescript
{
  id: string;
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
  assetId: string;
  assetType: string;
  plantNumber?: string;
  dateRange: {
    from: string;
    to: string;
  };
  
  // Versions
  originalTimesheetIds: string[];
  adminEditedVersion?: {
    hours: number;
    notes?: string;
    editedBy: string;
    editedAt: Timestamp;
  };
  subcontractorSuggestedVersion?: {
    hours: number;
    notes?: string;
    editedBy: string;
    editedAt: Timestamp;
  };
  
  // State
  status: 'pending_subcontractor_review' | 'subcontractor_responded' | 'admin_final_review' | 'agreed' | 'rejected';
  
  // Audit trail
  createdAt: Timestamp;
  updatedAt: Timestamp;
  sentToSubcontractorAt?: Timestamp;
  subcontractorRespondedAt?: Timestamp;
  agreedAt?: Timestamp;
  agreedBy?: string;
}
```

### Collection: `agreedTimesheets`
```typescript
{
  id: string;
  originalTimesheetId: string;
  pendingAgreementId?: string;
  timesheetType: 'operator' | 'plant_asset';
  
  // Final agreed data
  date: string;
  assetId?: string;
  assetType?: string;
  operatorId?: string;
  operatorName?: string;
  
  originalHours: number;
  agreedHours: number;
  hoursDifference: number;
  
  originalNotes?: string;
  adminNotes?: string;
  
  // Metadata
  siteId: string;
  masterAccountId: string;
  subcontractorId?: string;
  subcontractorName?: string;
  
  status: 'approved_for_billing' | 'processed' | 'paid';
  
  agreedAt: Timestamp;
  agreedBy: string;
  approvedForBillingAt: Timestamp;
  approvedForBillingBy: string;
  
  createdAt: Timestamp;
  updatedAt: Timestamp;
}
```

## UI Changes Required

### Admin Interface (billing-config.tsx)

#### EPH Tab
1. **Edit Hours Button**
   - Opens modal to edit individual timesheet hours
   - Saves as draft/admin version
   - Shows visual indicator if edited

2. **Send to Subcontractor Button**
   - Appears after editing (or directly)
   - Creates pending agreement
   - Sends notification to subcontractor

3. **View Subcontractor Response**
   - Shows when subcontractor has responded
   - Side-by-side comparison view
   - Highlights differences

4. **Agree Hours Button** (renamed from current "Agree Hours")
   - Final step after both parties reviewed
   - Only enabled when ready to finalize
   - Creates agreed timesheet

#### Process Payments Tab (renamed from "Timesheets")
- Lists all agreed timesheets
- Grouped by subcontractor
- Shows:
  - Date range
  - Total hours
  - Agreement date
  - Status (pending payment, paid, etc.)
- Generate invoice PDFs
- Mark as paid

### Subcontractor Interface (New - Separate App/Portal)
1. **Pending Reviews Dashboard**
   - Lists all EPH reports awaiting their review
   - Shows admin's proposed hours
   - Date ranges
   - Assets

2. **Review & Edit Screen**
   - View admin's version
   - Edit fields to suggest changes
   - Add notes explaining changes
   - Submit or Accept buttons

3. **Agreement History**
   - Past agreed timesheets
   - Audit trail
   - Download PDFs

## Implementation Steps

### Phase 1: Admin Interface Enhancement
1.  Rename "Timesheets" tab to "Process Payments"
2. Add "Edit Hours" functionality to EPH
3. Create `pendingAgreements` manager utility
4. Add "Send to Subcontractor" button
5. Implement comparison view for admin

### Phase 2: Subcontractor Portal
1. Create new app/portal for subcontractors
2. Authentication (separate from main app)
3. Pending reviews dashboard
4. Edit and response functionality
5. Agreement history

### Phase 3: Integration & Testing
1. Notification system (email/push)
2. Real-time updates
3. Audit logging
4. End-to-end testing
5. Security & permissions

## Security Considerations
- Subcontractors can only see their own timesheets
- Admin edits are clearly marked
- Subcontractor suggestions don't automatically override admin
- Admin has final authority (source of truth)
- All changes are logged with timestamps and user IDs
- Agreed timesheets are immutable

## Email Notifications
- Admin  Subcontractor: "New EPH report for review"
- Subcontractor  Admin: "EPH response submitted"
- Admin  Subcontractor: "EPH agreed and finalized"

## PDF Report Features
- Shows all three versions (original, admin, subcontractor)
- Highlights differences
- Agreement signatures/timestamps
- Suitable for accounting/auditing

## Firestore Indexes Required
```
Collection: pendingAgreements
- masterAccountId, status
- subcontractorId, status
- masterAccountId, subcontractorId, status

Collection: agreedTimesheets
- masterAccountId, status, agreedAt (desc)
- subcontractorId, status, agreedAt (desc)
- masterAccountId, date (asc/desc)
```

## Next Steps
1. Review and approve this workflow document
2. Implement Phase 1 admin interface changes
3. Design subcontractor portal UI/UX
4. Set up Firebase rules for new collections
5. Create pending agreement manager utility
6. Implement edit hours modal for admin
7. Add comparison view
8. Update PDF generator to support agreed timesheets


--- END OF FILE: docs/EPH-SUBCONTRACTOR-AGREEMENT-WORKFLOW.md ---


================================================================================
CATEGORY: Documentation
FILE: docs/EPH-FIREBASE-INDEXES-REQUIRED.md
================================================================================

# EPH Agreement System - Required Firebase Indexes

## Overview
This document lists all Firebase indexes required for the EPH (Equipment/Plant Hours) agreement workflow between Admin and Subcontractors.

## Collection: `ephPendingEdits`
This collection stores pending edits made by admin or subcontractor before final agreement.

### Index 1: Query by Asset and Status
**Purpose**: Find pending edits for a specific asset
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

### Index 2: Query by Asset, Date and Master Account
**Purpose**: Find pending edits for a specific asset and date
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

### Index 3: Query by Asset with Ordering
**Purpose**: Get all pending edits for an asset ordered by date
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "DESCENDING" }
  ]
}
```

### Index 4: Query by Asset with Creation Order
**Purpose**: Get all pending edits for an asset ordered by creation time
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Index 5: Query by Subcontractor
**Purpose**: Find all pending edits for a subcontractor
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "subcontractorId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "ASCENDING" }
  ]
}
```

## Collection: `pendingAgreements`
This collection stores the overall agreement status for asset timesheets.

### Index 1: Query by Subcontractor with Status
**Purpose**: Find agreements for a specific subcontractor
```json
{
  "collectionGroup": "pendingAgreements",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "subcontractorId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Index 2: Query by Subcontractor without Status Filter
**Purpose**: Get all agreements for a subcontractor
```json
{
  "collectionGroup": "pendingAgreements",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "subcontractorId", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Index 3: Query by Master Account with Status
**Purpose**: Find agreements for a master account
```json
{
  "collectionGroup": "pendingAgreements",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Index 4: Query by Master Account without Status Filter
**Purpose**: Get all agreements for a master account
```json
{
  "collectionGroup": "pendingAgreements",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Index 5: Query by Asset and Date Range
**Purpose**: Find existing pending agreement for an asset
```json
{
  "collectionGroup": "pendingAgreements",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "dateRange.from", "order": "ASCENDING" },
    { "fieldPath": "dateRange.to", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

## Collection: `agreedTimesheets`
This collection stores finalized agreed timesheets ready for billing.

### Index 1: Query by Master Account and Date Range
**Purpose**: Get agreed timesheets for billing period
```json
{
  "collectionGroup": "agreedTimesheets",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" }
  ]
}
```

### Index 2: Query by Original Timesheet ID
**Purpose**: Check if a timesheet has already been agreed
```json
{
  "collectionGroup": "agreedTimesheets",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "originalTimesheetId", "order": "ASCENDING" }
  ]
}
```

### Index 3: Query by Subcontractor
**Purpose**: Get all agreed timesheets for a subcontractor
```json
{
  "collectionGroup": "agreedTimesheets",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "subcontractorId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "ASCENDING" }
  ]
}
```

### Index 4: Query by Asset
**Purpose**: Get agreed timesheets for a specific asset
```json
{
  "collectionGroup": "agreedTimesheets",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "DESCENDING" }
  ]
}
```

## Complete `firestore.indexes.json` File

Add these to your existing `firestore.indexes.json`:

```json
{
  "indexes": [
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "dateRange.from", "order": "ASCENDING" },
        { "fieldPath": "dateRange.to", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "originalTimesheetId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    }
  ]
}
```

## How to Add These Indexes

### Method 1: Firebase Console (Recommended)
1. Go to Firebase Console  Firestore Database
2. Click on "Indexes" tab
3. Click "Add Index"  
4. For each index above:
   - Select the collection (e.g., "ephPendingEdits")
   - Add the fields with their sort orders (ASCENDING/DESCENDING)
   - Click "Create"

### Method 2: Firebase CLI
1. Copy the indexes above to your `firestore.indexes.json` file
2. Run: `firebase deploy --only firestore:indexes`

### Method 3: Automatic Creation
When you run queries that need these indexes, Firestore will show error messages with links to create them automatically.

## Testing the Indexes

After creating the indexes:

1. **Wait for index creation** (can take a few minutes for large collections)
2. **Test each query**:
   - Load EPH reports
   - Edit hours
   - Compare versions
   - Send to subcontractor
   - View agreed timesheets

3. **Monitor Console** for any missing index errors

## Index Status

You can check index build status in:
- Firebase Console  Firestore  Indexes tab
- Look for "Building" or "Enabled" status

## Troubleshooting

If queries still fail:
1. Check Firebase Console  Firestore  Indexes
2. Look for "Error" status on any indexes
3. Delete and recreate failed indexes
4. Ensure field names match exactly (case-sensitive)
5. Check query constraints match index field order

## Performance Notes

- These indexes enable efficient queries even with large datasets
- Each index adds storage overhead (~1% of collection size)
- Composite indexes are required for queries with multiple filters
- Single-field indexes are automatically created by Firestore

## Security Considerations

Update your Firestore security rules to protect these collections:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // EPH Pending Edits
    match /ephPendingEdits/{editId} {
      allow read: if request.auth != null && 
        (resource.data.masterAccountId == request.auth.token.masterAccountId ||
         resource.data.subcontractorId == request.auth.uid);
      allow create: if request.auth != null &&
        request.resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow update: if request.auth != null &&
        resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow delete: if request.auth != null &&
        resource.data.masterAccountId == request.auth.token.masterAccountId;
    }
    
    // Pending Agreements
    match /pendingAgreements/{agreementId} {
      allow read: if request.auth != null && 
        (resource.data.masterAccountId == request.auth.token.masterAccountId ||
         resource.data.subcontractorId == request.auth.uid);
      allow create: if request.auth != null &&
        request.resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow update: if request.auth != null &&
        (resource.data.masterAccountId == request.auth.token.masterAccountId ||
         resource.data.subcontractorId == request.auth.uid);
      allow delete: if request.auth != null &&
        resource.data.masterAccountId == request.auth.token.masterAccountId;
    }
    
    // Agreed Timesheets
    match /agreedTimesheets/{timesheetId} {
      allow read: if request.auth != null &&
        resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow create: if request.auth != null &&
        request.resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow update: if request.auth != null &&
        resource.data.masterAccountId == request.auth.token.masterAccountId;
      allow delete: if false; // Never allow deletion of agreed timesheets
    }
  }
}
```

## Summary

 Created utility files:
- `utils/ephPendingEditsManager.ts` - Manages admin/subcontractor edits
- `utils/ephEmailService.ts` - Sends EPH reports via email

 Created modal components:
- `EditEPHHoursModal.tsx` - Admin edits hours
- `TimesheetComparisonModal.tsx` - Compare versions
- `SendConfirmationModal.tsx` - Send to subcontractor

 Added integration handlers in `billing-config.tsx`:
- `handleEditHours` - Opens edit modal
- `handleSaveEdit` - Saves pending edits
- `handleCompareVersions` - Opens comparison modal
- `handleSendToSubcontractor` - Generates and sends PDF

 **Next Steps** (Not done yet - you mentioned these are needed):
1. Add UI buttons to EPH cards for "Edit Hours" and "Compare Versions"
2. Add "Send to Subcontractor" button at top level
3. Render the modals in the return statement
4. Add visual indicators for assets with pending edits
5. Enhance Process Payments tab with status badges and metadata

**The indexes above must be added to Firebase before using these features!**


--- END OF FILE: docs/EPH-FIREBASE-INDEXES-REQUIRED.md ---


================================================================================
CATEGORY: Documentation
FILE: docs/BILLING-TIMESHEET-WORKFLOW-CLARIFICATION.md
================================================================================

# EPH & Billing System Implementation Guide

> Complete implementation guide for replicating the EPH (Equipment/Plant Hours) and billing system with admin direct approval workflow.

---

##  OVERVIEW

This guide covers the implementation of:
- **EPH Report Generation** with raw vs billable hours
- **Admin Direct Approval** (skip subcontractor digital workflow)
- **Subcontractor Digital Review Portal** 
- **Admin Edit Workflow** with pending edits
- **Version Comparison** (Operator  PM  Admin  Subcontractor)
- **Finalized Hours** for billing (source of truth)

---

##  BATCH 1: Database Collections & Firestore Indexes

### New Collections to Create

#### 1. `ephPendingEdits` Collection
Stores admin/subcontractor edits that require review before finalization.

**Document Structure:**
```typescript
{
  id: string;                          // Auto-generated
  originalTimesheetId: string;         // Reference to verifiedTimesheet
  assetId: string;
  assetType: string;
  plantNumber?: string;
  date: string;                        // ISO date "YYYY-MM-DD"
  
  // Editor info
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedByName: string;
  
  // Edited values
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  
  // Original values (for comparison)
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  
  // Status tracking
  status: 'pending_review' | 'reviewed' | 'superseded';
  reviewedBy?: string;
  reviewedAt?: Timestamp;
  
  // Isolation
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
  
  createdAt: Timestamp;
  updatedAt: Timestamp;
}
```

**Required Indexes:**
```json
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "DESCENDING" }
  ]
},
{
  "collectionGroup": "ephPendingEdits",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "assetId", "order": "ASCENDING" },
    { "fieldPath": "date", "order": "ASCENDING" },
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

#### 2. `ephReports` Collection
Tracks EPH report lifecycle from draft  sent  reviewed  finalized.

**Document Structure:**
```typescript
{
  id: string;                          // Auto-generated
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
  
  // Date range
  startDate: string;                   // ISO date "YYYY-MM-DD"
  endDate: string;                     // ISO date "YYYY-MM-DD"
  
  // Status
  status: 'draft' | 'sent_to_subcontractor' | 'subcontractor_reviewed' | 'admin_finalized';
  
  // Asset records (array of EPHRecord)
  assetRecords: [{
    assetId: string;
    assetType: string;
    plantNumber?: string;
    registrationNumber?: string;
    rate: number;
    rateType: 'wet' | 'dry';
    normalHours: number;
    saturdayHours: number;
    sundayHours: number;
    publicHolidayHours: number;
    breakdownHours: number;
    rainDayHours: number;
    strikeDayHours: number;
    totalRawHours: number;
    totalBillableHours: number;
    estimatedCost: number;
    subcontractorDisputedHours?: number;
    adminFinalizedHours?: number;
    disputeNotes?: string;
    disputedAt?: string;
    disputedBy?: string;
  }];
  
  // Tracking
  createdAt: Timestamp;
  createdBy: string;
  sentAt?: Timestamp;
  reviewedAt?: Timestamp;
  reviewedBy?: string;
  finalizedAt?: Timestamp;
  finalizedBy?: string;
  hasDisputes?: boolean;
}
```

**Required Indexes:**
```json
{
  "collectionGroup": "ephReports",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "masterAccountId", "order": "ASCENDING" },
    { "fieldPath": "subcontractorId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

#### 3. `agreedTimesheets` Collection (Enhancement)
Add new field for approval type tracking.

**Add to existing structure:**
```typescript
{
  // ... existing fields ...
  approvalType?: 'digital' | 'admin_direct';  // NEW FIELD
}
```

**Note:** This collection should already exist. Just add the `approvalType` field to track whether the admin directly approved or if it went through subcontractor digital workflow.

---

##  BATCH 2: Utility Managers

### File 1: `utils/ephPendingEditsManager.ts`

**Purpose:** Manages pending edits from admin/subcontractor that require review.

**Key Functions:**
- `createPendingEdit()` - Creates new pending edit, supersedes old ones
- `getPendingEditsByAsset()` - Gets pending edits for specific asset/date
- `getAllPendingEditsByAssetId()` - Gets all pending edits for asset
- `supersedePendingEdit()` - Marks edit as superseded
- `reviewPendingEdit()` - Marks edit as reviewed

**Complete File Content:**
```typescript
import { collection, doc, setDoc, getDocs, query, where, updateDoc, Timestamp, orderBy } from 'firebase/firestore';
import { db } from '@/config/firebase';

export type EPHPendingEdit = {
  id: string;
  originalTimesheetId: string;
  assetId: string;
  assetType: string;
  plantNumber?: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedByName: string;
  
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  
  status: 'pending_review' | 'reviewed' | 'superseded';
  reviewedBy?: string;
  reviewedAt?: Timestamp;
  
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
  
  createdAt: Timestamp;
  updatedAt: Timestamp;
};

export async function createPendingEdit(params: {
  originalTimesheetId: string;
  assetId: string;
  assetType: string;
  plantNumber?: string;
  date: string;
  editedBy: 'admin' | 'subcontractor';
  editedByUserId: string;
  editedByName: string;
  totalHours: number;
  openHours: string;
  closeHours: string;
  isBreakdown: boolean;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isPublicHoliday: boolean;
  notes: string;
  originalTotalHours: number;
  originalOpenHours: string;
  originalCloseHours: string;
  masterAccountId: string;
  siteId: string;
  subcontractorId: string;
  subcontractorName: string;
}): Promise<string> {
  console.log('[ephPendingEditsManager] Creating pending edit for asset:', params.assetId);
  
  const existingEdits = await getPendingEditsByAsset(params.assetId, params.date, params.masterAccountId);
  for (const edit of existingEdits) {
    await supersedePendingEdit(edit.id);
  }
  
  const editRef = doc(collection(db, 'ephPendingEdits'));
  const editId = editRef.id;
  
  const editData: EPHPendingEdit = {
    ...params,
    id: editId,
    status: 'pending_review',
    createdAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  };
  
  await setDoc(editRef, editData);
  
  console.log('[ephPendingEditsManager] Pending edit created:', editId);
  return editId;
}

export async function getPendingEditsByAsset(
  assetId: string,
  date: string,
  masterAccountId: string
): Promise<EPHPendingEdit[]> {
  console.log('[ephPendingEditsManager] Fetching pending edits for asset:', assetId, 'date:', date);
  
  const q = query(
    collection(db, 'ephPendingEdits'),
    where('assetId', '==', assetId),
    where('date', '==', date),
    where('masterAccountId', '==', masterAccountId),
    where('status', '==', 'pending_review'),
    orderBy('createdAt', 'desc')
  );
  
  const snapshot = await getDocs(q);
  const edits = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as EPHPendingEdit);
  
  console.log('[ephPendingEditsManager] Found pending edits:', edits.length);
  return edits;
}

export async function getAllPendingEditsByAssetId(
  assetId: string,
  masterAccountId: string
): Promise<EPHPendingEdit[]> {
  console.log('[ephPendingEditsManager] Fetching all pending edits for asset:', assetId);
  
  const q = query(
    collection(db, 'ephPendingEdits'),
    where('assetId', '==', assetId),
    where('masterAccountId', '==', masterAccountId),
    where('status', '==', 'pending_review'),
    orderBy('date', 'desc')
  );
  
  const snapshot = await getDocs(q);
  const edits = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as EPHPendingEdit);
  
  console.log('[ephPendingEditsManager] Found pending edits:', edits.length);
  return edits;
}

export async function supersedePendingEdit(editId: string): Promise<void> {
  console.log('[ephPendingEditsManager] Superseding pending edit:', editId);
  
  await updateDoc(doc(db, 'ephPendingEdits', editId), {
    status: 'superseded',
    updatedAt: Timestamp.now(),
  });
  
  console.log('[ephPendingEditsManager] Pending edit superseded');
}

export async function reviewPendingEdit(editId: string, reviewedBy: string): Promise<void> {
  console.log('[ephPendingEditsManager] Reviewing pending edit:', editId);
  
  await updateDoc(doc(db, 'ephPendingEdits', editId), {
    status: 'reviewed',
    reviewedBy,
    reviewedAt: Timestamp.now(),
    updatedAt: Timestamp.now(),
  });
  
  console.log('[ephPendingEditsManager] Pending edit reviewed');
}
```

---

### File 2: `utils/ephEmailService.ts`

**Purpose:** Handles email sending for EPH reports to subcontractors.

**Key Functions:**
- `sendEPHToSubcontractor()` - Sends EPH report via email with PDF attachment
- `sendAgreementConfirmationToSubcontractor()` - Sends confirmation email

**Complete File Content:**
```typescript
import * as MailComposer from 'expo-mail-composer';
import { Platform, Alert } from 'react-native';

export async function sendEPHToSubcontractor(params: {
  recipientEmail: string;
  message: string;
  pdfUri: string;
  pdfFileName: string;
  subcontractorName: string;
  dateRange: { from: Date; to: Date };
  assetCount: number;
  totalHours: number;
  companyName: string;
}): Promise<void> {
  console.log('[ephEmailService] Sending EPH to subcontractor:', params.recipientEmail);
  
  const { recipientEmail, message, pdfUri, pdfFileName, subcontractorName, dateRange, assetCount, totalHours, companyName } = params;
  
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };
  
  const subject = `EPH Report for Review - ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)} - ${subcontractorName}`;
  
  const body = `Dear ${subcontractorName},

Please find attached the Equipment/Plant Hours (EPH) report for the period ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)}.

Assets Included: ${assetCount}
Total Hours: ${totalHours.toFixed(1)}h

${message ? `\n${message}\n\n` : ''}Please review the hours and respond with any corrections or approval.

Thank you,
${companyName}`;
  
  if (Platform.OS === 'web') {
    console.log('[ephEmailService] Web platform - opening email composer simulation');
    Alert.alert(
      'Email Composer',
      `Would open email to:\n${recipientEmail}\n\nSubject: ${subject}\n\nWith PDF attachment: ${pdfFileName}\n\nThis is a simulation on web. On mobile, this would open your email client.`,
      [{ text: 'OK' }]
    );
    return;
  }
  
  const isAvailable = await MailComposer.isAvailableAsync();
  if (!isAvailable) {
    throw new Error('Email composer not available on this device');
  }
  
  await MailComposer.composeAsync({
    recipients: [recipientEmail],
    subject,
    body,
    attachments: [pdfUri],
  });
  
  console.log('[ephEmailService] Email composer opened successfully');
}

export async function sendAgreementConfirmationToSubcontractor(params: {
  recipientEmail: string;
  subcontractorName: string;
  dateRange: { from: Date; to: Date };
  assetCount: number;
  totalHours: number;
  agreedBy: string;
  companyName: string;
}): Promise<void> {
  console.log('[ephEmailService] Sending agreement confirmation:', params.recipientEmail);
  
  const { recipientEmail, subcontractorName, dateRange, assetCount, totalHours, agreedBy, companyName } = params;
  
  const formatDate = (date: Date) => {
    return date.toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };
  
  const subject = `EPH Agreement Confirmed - ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)}`;
  
  const body = `Dear ${subcontractorName},

This confirms that the Equipment/Plant Hours (EPH) report for the period ${formatDate(dateRange.from)} to ${formatDate(dateRange.to)} has been finalized and agreed.

Assets: ${assetCount}
Total Hours: ${totalHours.toFixed(1)}h
Agreed By: ${agreedBy}
Date: ${formatDate(new Date())}

The agreed timesheets are now ready for payment processing.

Thank you,
${companyName}`;
  
  if (Platform.OS === 'web') {
    console.log('[ephEmailService] Web platform - showing confirmation');
    Alert.alert(
      'Agreement Confirmation',
      `Would send confirmation email to:\n${recipientEmail}\n\nSubject: ${subject}`,
      [{ text: 'OK' }]
    );
    return;
  }
  
  const isAvailable = await MailComposer.isAvailableAsync();
  if (!isAvailable) {
    console.log('[ephEmailService] Email not available, skipping confirmation email');
    return;
  }
  
  await MailComposer.composeAsync({
    recipients: [recipientEmail],
    subject,
    body,
  });
  
  console.log('[ephEmailService] Confirmation email opened successfully');
}
```

---

### File 3: `utils/agreedTimesheetManager.ts` (Enhancement)

**Purpose:** Add `directApproveEPHTimesheets()` function for admin direct approval.

**New Function to Add:**
```typescript
export async function directApproveEPHTimesheets(
  timesheets: PlantAssetTimesheet[],
  agreedBy: string,
  adminNotes?: string
): Promise<string[]> {
  console.log('[agreedTimesheetManager] Direct approving', timesheets.length, 'timesheets');
  
  const agreedIds: string[] = [];
  
  for (const timesheet of timesheets) {
    const agreedId = await agreePlantAssetTimesheet(
      timesheet,
      {
        agreedHours: timesheet.totalHours,
        agreedNotes: adminNotes,
      },
      agreedBy,
      'admin_direct'  // This marks it as direct approval
    );
    agreedIds.push(agreedId);
  }
  
  console.log('[agreedTimesheetManager] Direct approved', agreedIds.length, 'timesheets');
  return agreedIds;
}
```

**Enhancement to existing `agreePlantAssetTimesheet()` function:**
```typescript
export async function agreePlantAssetTimesheet(
  originalTimesheet: PlantAssetTimesheet,
  agreedData: {
    agreedHours?: number;
    agreedNotes?: string;
  },
  agreedBy: string,
  approvalType?: 'digital' | 'admin_direct'  // ADD THIS PARAMETER
): Promise<string> {
  console.log('[agreedTimesheetManager] Creating agreed plant asset timesheet:', originalTimesheet.id, 'type:', approvalType || 'digital');

  // ... existing params creation ...

  const agreedTimesheetId = await createAgreedTimesheet(params);

  await updateDoc(doc(db, 'plantAssetTimesheets', originalTimesheet.id!), {
    agreedHours: agreedData.agreedHours,
    agreedNotes: agreedData.agreedNotes,
    hasAgreedHours: true,
    agreedTimesheetId,
    approvalType: approvalType || 'digital',  // ADD THIS LINE
    updatedAt: Timestamp.now(),
  });

  console.log('[agreedTimesheetManager] Plant asset timesheet agreed:', agreedTimesheetId);
  return agreedTimesheetId;
}
```

---

##  BATCH 3: UI Components

### Component 1: `components/accounts/EditEPHHoursModal.tsx`

**Purpose:** Modal for admin to edit hours (creates pending edit for subcontractor review).

**Features:**
- Edit total hours, open/close times
- Toggle day conditions (breakdown, rain, strike, holiday)
- Add admin notes
- Shows plant manager's original values

**Key Props:**
```typescript
type Props = {
  visible: boolean;
  onClose: () => void;
  onSave: (editedValues: EditedValues) => Promise<void>;
  timesheet: TimesheetEntry | null;
};
```

**See file content in:** `components/accounts/EditEPHHoursModal.tsx` (from files read earlier)

---

### Component 2: `components/accounts/TimesheetComparisonModal.tsx`

**Purpose:** Modal to compare Plant Manager, Admin, and Subcontractor versions side-by-side.

**Features:**
- Shows all three versions with visual diff
- Highlights changed values
- Color-coded (PM = blue, Admin = yellow, Sub = light blue)
- Comparison arrows showing progression

**Key Props:**
```typescript
type Props = {
  visible: boolean;
  onClose: () => void;
  comparison: ComparisonData | null;
};
```

**See file content in:** `components/accounts/TimesheetComparisonModal.tsx` (from files read earlier)

---

### Component 3: `components/accounts/SendConfirmationModal.tsx` (Enhancement)

**Purpose:** Modal with TWO options: Send to subcontractor OR Direct approve (skip workflow).

**Features:**
- Option 1: Send for digital approval (email with PDF)
- Option 2: Direct approval button (admin finalizes immediately)
- Shows EPH summary (period, asset count)
- Email validation

**Key Props:**
```typescript
type Props = {
  visible: boolean;
  onClose: () => void;
  onSend: (recipientEmail: string, message: string) => Promise<void>;
  onDirectApprove?: () => Promise<void>;  // NEW: Direct approval handler
  subcontractorName: string;
  assetCount: number;
  dateRange: { from: Date; to: Date };
};
```

**Key Enhancement (Direct Approval Section):**
```tsx
<View style={styles.directApprovalBox}>
  <Text style={styles.directApprovalTitle}>Direct Approval (No Digital Workflow)</Text>
  <Text style={styles.directApprovalDescription}>
    If subcontractor does not have app access, you can approve directly and send PDF manually via email/WhatsApp.
  </Text>
  <TouchableOpacity
    style={styles.directApproveButton}
    onPress={handleDirectApprove}
    disabled={approving || sending}
  >
    <Text style={styles.directApproveButtonText}>Approve & Finalize</Text>
  </TouchableOpacity>
</View>
```

**See full file content in:** `components/accounts/SendConfirmationModal.tsx` (from files read earlier)

---

##  BATCH 4: Main Billing Screen Enhancements

### File: `app/billing-config.tsx` (EPH Tab Section)

**Purpose:** Main billing screen with EPH report generation and management.

**Key Enhancements to EPH Tab:**

#### 1. EPH Card with Status Badges & Hours Display
```tsx
<View style={styles.ephCard}>
  {/* Status Badge */}
  {item.status && (
    <View style={[
      styles.statusBadge,
      item.status === 'draft' && styles.statusBadgeDraft,
      item.status === 'sent_to_subcontractor' && styles.statusBadgeSent,
      item.status === 'subcontractor_reviewed' && styles.statusBadgeReviewed,
      item.status === 'admin_finalized' && styles.statusBadgeFinalized,
    ]}>
      <Text style={styles.statusBadgeText}>
        {item.status === 'draft' ? 'Draft' :
         item.status === 'sent_to_subcontractor' ? 'Sent to Sub' :
         item.status === 'subcontractor_reviewed' ? 'Sub Reviewed' :
         'Finalized'}
      </Text>
    </View>
  )}
  
  {/* Pending Edits Badge */}
  {hasPendingEdits && (
    <View style={styles.pendingEditBadge}>
      <Text style={styles.pendingEditBadgeText}>Edits Pending</Text>
    </View>
  )}
  
  {/* Raw Hours vs Billable Hours */}
  <View style={styles.ephInfoRow}>
    <Text style={styles.ephTotalLabel}>Raw Hours (Operator/PM):</Text>
    <Text style={styles.ephTotalValue}>{item.totalRawHours.toFixed(2)}h</Text>
  </View>
  <View style={styles.ephInfoRow}>
    <Text style={styles.ephTotalLabel}>Billable Hours (Config):</Text>
    <Text style={styles.ephTotalValue}>{item.totalBillableHours.toFixed(2)}h</Text>
  </View>
  
  {/* Disputed/Finalized Hours */}
  {item.subcontractorDisputedHours !== undefined && (
    <View style={styles.ephInfoRow}>
      <Text style={styles.ephDisputedLabel}>Sub Disputed Hours:</Text>
      <Text style={styles.ephDisputedValue}>{item.subcontractorDisputedHours.toFixed(2)}h</Text>
    </View>
  )}
  {item.adminFinalizedHours !== undefined && (
    <View style={styles.ephInfoRow}>
      <Text style={styles.ephFinalizedLabel}>Admin Finalized Hours:</Text>
      <Text style={styles.ephFinalizedValue}>{item.adminFinalizedHours.toFixed(2)}h</Text>
    </View>
  )}
</View>
```

#### 2. Generate Buttons with Direct Approve
```tsx
<View style={styles.generateButtonsContainer}>
  {/* Generate All Button */}
  <TouchableOpacity
    style={[styles.generateButton, styles.generateButtonPrimary]}
    onPress={handleGenerateAllReport}
  >
    <FileText size={18} color="#ffffff" />
    <Text style={styles.generateButtonText}>Generate All</Text>
  </TouchableOpacity>
  
  {/* Generate Selected Button */}
  <TouchableOpacity
    style={[
      styles.generateButton,
      styles.generateButtonSecondary,
      selectedAssetIds.size === 0 && styles.generateButtonDisabled,
    ]}
    onPress={handleGenerateSelectedReport}
    disabled={selectedAssetIds.size === 0}
  >
    <CheckSquare size={18} color={selectedAssetIds.size === 0 ? "#94a3b8" : "#1e3a8a"} />
    <Text>Generate Selected ({selectedAssetIds.size})</Text>
  </TouchableOpacity>
  
  {/* Send to Subcontractor Button */}
  <TouchableOpacity
    style={[
      styles.generateButton,
      styles.sendToSubButton,
      selectedAssetIds.size === 0 && styles.generateButtonDisabled,
    ]}
    onPress={() => setSendModalVisible(true)}
    disabled={selectedAssetIds.size === 0}
  >
    <Send size={18} color={selectedAssetIds.size === 0 ? "#94a3b8" : "#10b981"} />
    <Text>Send to Subcontractor</Text>
  </TouchableOpacity>
</View>
```

#### 3. Edit Hours Handler (Creates Pending Edit)
```tsx
const handleEditHours = async (assetId: string) => {
  console.log('[EPH] Edit hours clicked for asset:', assetId);
  const timesheets = ephTimesheets.get(assetId);
  
  if (!timesheets || timesheets.length === 0) {
    Alert.alert('No Timesheets', 'No timesheets found for this asset.');
    return;
  }
  
  const asset = plantAssets.find(a => a.assetId === assetId);
  setSelectedTimesheetForEdit({
    ...timesheets[0],
    assetType: asset?.type,
    plantNumber: asset?.plantNumber || asset?.registrationNumber,
  });
  setEditModalVisible(true);
};

const handleSaveEdit = async (editedValues: any) => {
  if (!selectedTimesheetForEdit || !user) {
    console.error('[EPH] Missing timesheet or user');
    return;
  }
  
  try {
    const asset = plantAssets.find(a => a.assetId === selectedTimesheetForEdit.assetId);
    const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
    
    // Creates pending edit (not finalized)
    await createPendingEdit({
      originalTimesheetId: selectedTimesheetForEdit.id,
      assetId: selectedTimesheetForEdit.assetId,
      assetType: asset?.type || 'Unknown',
      plantNumber: asset?.plantNumber || asset?.registrationNumber,
      date: selectedTimesheetForEdit.date,
      editedBy: 'admin',
      editedByUserId: user.userId || user.id || 'unknown',
      editedByName: user.name || 'Admin',
      totalHours: editedValues.totalHours,
      openHours: editedValues.openHours,
      closeHours: editedValues.closeHours,
      isBreakdown: editedValues.isBreakdown,
      isRainDay: editedValues.isRainDay,
      isStrikeDay: editedValues.isStrikeDay,
      isPublicHoliday: editedValues.isPublicHoliday,
      notes: editedValues.adminNotes,
      originalTotalHours: selectedTimesheetForEdit.totalHours || 0,
      originalOpenHours: selectedTimesheetForEdit.openHours || '00:00',
      originalCloseHours: selectedTimesheetForEdit.closeHours || '00:00',
      masterAccountId: user.masterAccountId || '',
      siteId: user.siteId || '',
      subcontractorId: selectedSubcontractor || '',
      subcontractorName: subcontractor?.name || 'Unknown',
    });
    
    Alert.alert('Success', 'Hours edited successfully. Changes are pending subcontractor review.');
    await loadPendingEdits();
  } catch (error) {
    console.error('[EPH] Error saving edit:', error);
    throw error;
  }
};
```

#### 4. Direct Approve Handler
```tsx
const handleDirectApproveEPH = async () => {
  if (!selectedSubcontractor || !user) {
    Alert.alert('Error', 'Missing subcontractor or user information');
    return;
  }
  
  console.log('[EPH] Direct approving EPH for selected assets');
  
  try {
    const selectedAssets = Array.from(selectedAssetIds).map(id => 
      ephData.find(record => record.assetId === id)
    ).filter(Boolean) as typeof ephData;
    
    if (selectedAssets.length === 0) {
      Alert.alert('Error', 'No assets selected');
      return;
    }
    
    const allTimesheets: any[] = [];
    for (const asset of selectedAssets) {
      const timesheets = ephTimesheets.get(asset.assetId) || [];
      const dedupedTimesheets = deduplicateTimesheetEntries(timesheets);
      allTimesheets.push(...dedupedTimesheets);
    }
    
    const agreedByIdentifier = user.userId || user.id || 'Admin';
    
    // Direct approve without subcontractor workflow
    await directApproveEPHTimesheets(
      allTimesheets,
      agreedByIdentifier,
      `Direct approval by admin - ${new Date().toLocaleDateString('en-GB')}`
    );
    
    Alert.alert(
      'Success', 
      `${selectedAssets.length} asset(s) approved and finalized. You can now generate PDF reports manually.`,
      [
        {
          text: 'OK',
          onPress: () => {
            if (selectedSubcontractor) {
              loadPlantAssets(selectedSubcontractor);
            }
          },
        },
      ]
    );
  } catch (error) {
    console.error('[EPH] Error direct approving:', error);
    throw error;
  }
};
```

#### 5. Send to Subcontractor Handler
```tsx
const handleSendToSubcontractor = async (recipientEmail: string, message: string) => {
  if (!selectedSubcontractor || !user) {
    Alert.alert('Error', 'Missing subcontractor or user information');
    return;
  }
  
  try {
    const selectedAssets = Array.from(selectedAssetIds).map(id => 
      ephData.find(record => record.assetId === id)
    ).filter(Boolean) as typeof ephData;
    
    const totalHours = selectedAssets.reduce((sum, asset) => sum + asset.totalBillableHours, 0);
    const subcontractor = subcontractors.find(s => s.id === selectedSubcontractor);
    
    // Generate groups for PDF
    const groups = selectedAssets.map(record => {
      const timesheets = ephTimesheets.get(record.assetId) || [];
      const dedupedTimesheets = deduplicateTimesheetEntries(timesheets);
      
      return {
        key: record.assetId,
        title: record.assetType,
        subtitle: record.plantNumber || record.registrationNumber || record.assetId,
        entries: dedupedTimesheets.map(ts => ({
          // ... map timesheet data ...
        })),
        dateGroups: dedupedTimesheets.map(ts => ({
          // ... map date groups ...
        })),
      };
    });
    
    // Generate PDF
    const { uri, fileName } = await generateTimesheetPDF({
      groups,
      reportType: 'plant',
      subcontractorName: subcontractor?.name,
      dateRange: { from: startDate, to: endDate },
      selectedOnly: true,
      selectedGroups: new Set(selectedAssets.map(r => r.assetId)),
    });
    
    // Send via email
    await sendEPHToSubcontractor({
      recipientEmail,
      message,
      pdfUri: uri,
      pdfFileName: fileName,
      subcontractorName: subcontractor?.name || 'Unknown',
      dateRange: { from: startDate, to: endDate },
      assetCount: selectedAssets.length,
      totalHours,
      companyName: user.companyName || 'Your Company',
    });
    
    Alert.alert('Success', 'EPH report sent to subcontractor');
  } catch (error) {
    console.error('[EPH] Error sending to subcontractor:', error);
    throw error;
  }
};
```

#### 6. Wire Up Modal
```tsx
<SendConfirmationModal
  visible={sendModalVisible}
  onClose={() => setSendModalVisible(false)}
  onSend={handleSendToSubcontractor}
  onDirectApprove={handleDirectApproveEPH}  // Wire up direct approve
  subcontractorName={subcontractors.find(s => s.id === selectedSubcontractor)?.name || 'Unknown'}
  assetCount={selectedAssetIds.size}
  dateRange={{ from: startDate, to: endDate }}
/>
```

---

##  BATCH 5: Subcontractor Review Screen

### File: `app/subcontractor-eph-review.tsx`

**Purpose:** Screen for subcontractor to review EPH and dispute hours.

**Features:**
- Shows raw vs billable hours for each asset
- Inline editing to dispute hours
- Add dispute reason/notes
- Submit disputed values back to admin
- Visual warnings for disputed items

**Key Functions:**
```tsx
const handleDisputeChange = (assetId: string, value: string) => {
  const numValue = parseFloat(value);
  if (!isNaN(numValue) && numValue >= 0) {
    setDisputedValues(prev => ({ ...prev, [assetId]: numValue }));
  }
};

const handleSubmitDispute = async () => {
  // Submits disputed values to ephReports collection
  const updatedRecords = ephRecords.map(record => {
    const disputedHours = disputedValues[record.assetId];
    const notes = disputeNotes[record.assetId];
    
    if (disputedHours !== undefined) {
      return {
        ...record,
        subcontractorDisputedHours: disputedHours,
        disputeNotes: notes || '',
        disputedAt: new Date().toISOString(),
        disputedBy: user?.userId || user?.id || 'unknown',
      };
    }
    return record;
  });

  await updateDoc(ephDocRef, {
    status: 'subcontractor_reviewed',
    assetRecords: updatedRecords,
    reviewedAt: new Date().toISOString(),
    reviewedBy: user?.userId || user?.id || 'unknown',
    hasDisputes: Object.keys(disputedValues).length > 0,
  });
};
```

**See full file content in:** `app/subcontractor-eph-review.tsx` (from files read earlier)

---

##  BATCH 6: Types Enhancement

### File: `types/index.ts` (Add EPH Types)

**Add these types:**
```typescript
export type EPHRecord = {
  assetId: string;
  assetType: string;
  plantNumber?: string;
  registrationNumber?: string;
  rate: number;
  rateType: 'wet' | 'dry';
  normalHours: number;
  saturdayHours: number;
  sundayHours: number;
  publicHolidayHours: number;
  breakdownHours: number;
  rainDayHours: number;
  strikeDayHours: number;
  totalRawHours: number;
  totalBillableHours: number;
  estimatedCost: number;
  rawTimesheets: TimesheetEntry[];
  status?: 'draft' | 'sent_to_subcontractor' | 'subcontractor_reviewed' | 'admin_finalized';
  subcontractorDisputedHours?: number;
  adminFinalizedHours?: number;
};

export type TimesheetEntry = {
  id: string;
  date: string;
  dayOfWeek: string;
  openHours: string;
  closeHours: string;
  closingHours?: string;
  totalHours: number;
  operatorName: string;
  isRainDay: boolean;
  isStrikeDay: boolean;
  isBreakdown: boolean;
  isPublicHoliday: boolean;
  notes?: string;
  operatorNotes?: string;
  additionalNotes?: string;
  adminNotes?: string;
  billingNotes?: string;
  verifiedAt?: string;
  hasOriginalEntry?: boolean;
  originalEntryData?: Partial<TimesheetEntry>;
  originalEntryId?: string;
  adjustedBy?: string;
  adjustedAt?: string;
  isAdjustment?: boolean;
  agreedByRole?: 'Admin' | 'Plant Manager' | 'Operator';
};
```

---

##  BATCH 7: Testing & Verification

### Testing Checklist

#### Test 1: Direct Approval Flow (Skip Subcontractor)
1.  Go to Billing Config  EPH Report tab
2.  Select subcontractor and date range
3.  Select assets using checkboxes
4.  Click "Send to Subcontractor"
5.  In modal, click "Approve & Finalize" button (direct approval)
6.  Verify success message
7.  Verify `agreedTimesheets` created with `approvalType: 'admin_direct'`
8.  Verify asset status changed to finalized
9.  Generate PDF and verify it includes finalized hours

#### Test 2: Digital Approval Flow (With Subcontractor)
1.  Select assets and click "Send to Subcontractor"
2.  Enter email and message
3.  Click "Send for Approval"
4.  Verify email composer opens with PDF attachment
5.  (Subcontractor) Open EPH review screen
6.  (Subcontractor) Review hours and dispute some
7.  (Subcontractor) Add dispute notes and submit
8.  (Admin) See "Edits Pending" badge on EPH cards
9.  (Admin) Click "Compare" to see versions
10.  (Admin) Finalize hours (creates agreedTimesheets with `approvalType: 'digital'`)

#### Test 3: Admin Edit Flow
1.  Open EPH card details
2.  Click "Edit Hours"
3.  Change total hours and add admin notes
4.  Click "Save Edits"
5.  Verify pending edit created in `ephPendingEdits` collection
6.  Verify "Edits Pending" badge appears
7.  Click "Compare" to see PM vs Admin versions
8.  Verify edit marked as `editedBy: 'admin'`

#### Test 4: Deduplication Logic
1.  Create operator entry (5 hours)
2.  Plant manager edits to 6 hours
3.  Admin edits to 7 hours
4.  Verify EPH shows 7 hours (highest priority)
5.  Verify only one agreed timesheet created
6.  Verify hierarchy: Admin > PM > Operator

#### Test 5: Raw vs Billable Hours Display
1.  Verify "Raw Hours (Operator/PM)" shows actual worked hours
2.  Verify "Billable Hours (Config)" shows calculated hours with config applied
3.  Test rain day minimum billing
4.  Test weekend minimum billing
5.  Test breakdown hours calculation

---

##  SUMMARY OF KEY CHANGES

### What This System Does:

1. **EPH Generation** - Creates Equipment/Plant Hours reports showing:
   - Raw hours (what operators/PM recorded)
   - Billable hours (after applying billing config)
   - Breakdown by day type (normal, saturday, sunday, holiday, rain, breakdown)

2. **Two Approval Paths:**
   - **Digital Path**: Send EPH to subcontractor  They review  Admin finalizes
   - **Direct Path**: Admin directly approves  Skip subcontractor workflow  Generate PDF manually

3. **Edit & Dispute Workflow:**
   - Admin can edit hours (creates pending edit)
   - Subcontractor can dispute hours (adds disputed values)
   - Comparison modal shows all versions side-by-side
   - Final admin approval creates `agreedTimesheets` (source of truth for billing)

4. **Status Tracking:**
   - Draft  Sent to Subcontractor  Subcontractor Reviewed  Admin Finalized
   - Visual badges show current status
   - "Edits Pending" badge when there are unresolved disputes

5. **Deduplication & Hierarchy:**
   - Admin edits > Plant Manager edits > Operator entries
   - Only highest priority entry used for billing
   - All versions visible in comparison modal

---

##  IMPLEMENTATION ORDER

1. **Start with Batch 1** - Set up database collections and indexes
2. **Then Batch 2** - Create utility managers
3. **Then Batch 3** - Build UI components
4. **Then Batch 4** - Enhance main billing screen
5. **Then Batch 5** - Create subcontractor review screen
6. **Then Batch 6** - Add TypeScript types
7. **Finally Batch 7** - Test everything

---

##  IMPORTANT NOTES

- **Exclude subcontractor filtering** - You mentioned this works fine, so use existing plant asset query logic
- **Indexes are critical** - Must create Firestore indexes or queries will fail
- **Direct approval is optional** - The `onDirectApprove` prop in `SendConfirmationModal` is optional
- **Pending edits are NOT finalized** - They're for tracking disputes only
- **agreedTimesheets is source of truth** - Only use this for billing calculations
- **Role hierarchy matters** - Admin > PM > Operator for deduplication

---

##  ADDITIONAL RESOURCES

- **Deduplication Function**: See `deduplicateTimesheetEntries()` in `billing-config.tsx` lines 386-436
- **PDF Generation**: See `handleGeneratePDFReport()` in `billing-config.tsx` lines 1046-1222
- **Comparison Logic**: See `TimesheetComparisonModal.tsx` for version comparison UI
- **Email Service**: See `ephEmailService.ts` for email templates and sending logic

---

##  COMPLETION CHECKLIST

- [ ] Batch 1: Database collections created
- [ ] Batch 1: Firestore indexes created
- [ ] Batch 2: `ephPendingEditsManager.ts` created
- [ ] Batch 2: `ephEmailService.ts` created
- [ ] Batch 2: `agreedTimesheetManager.ts` enhanced with `directApproveEPHTimesheets()`
- [ ] Batch 3: `EditEPHHoursModal.tsx` created
- [ ] Batch 3: `TimesheetComparisonModal.tsx` created
- [ ] Batch 3: `SendConfirmationModal.tsx` enhanced with direct approve
- [ ] Batch 4: `billing-config.tsx` EPH tab enhanced
- [ ] Batch 4: Status badges added to EPH cards
- [ ] Batch 4: Raw vs Billable hours display added
- [ ] Batch 4: Edit hours handler wired up
- [ ] Batch 4: Direct approve handler wired up
- [ ] Batch 4: Send to subcontractor handler wired up
- [ ] Batch 5: `subcontractor-eph-review.tsx` created
- [ ] Batch 6: Types added to `types/index.ts`
- [ ] Batch 7: All tests passed

---

**END OF IMPLEMENTATION GUIDE**


--- END OF FILE: docs/BILLING-TIMESHEET-WORKFLOW-CLARIFICATION.md ---


================================================================================
CATEGORY: Config
FILE: firestore.indexes.json
================================================================================

{
  "indexes": [
    {
      "collectionGroup": "sites",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "sites",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "sites",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "sites",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "name", "order": "ASCENDING" },
        { "fieldPath": "companyId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "supervisorId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "activity", "order": "ASCENDING" },
        { "fieldPath": "subActivity", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "supervisorId", "order": "ASCENDING" },
        { "fieldPath": "subActivity", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "employee_id_number", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "employeeIdNumber", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "employeeIdNumber", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "employerType", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "isCrossHire", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "employerId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocatedPvArea", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employees",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocatedPvArea", "order": "ASCENDING" },
        { "fieldPath": "allocatedBlockNumber", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "location", "order": "DESCENDING" },
        { "fieldPath": "__name__", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "location", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "location", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "allocationStatus", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocationStatus", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "allocationStatus", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "industrySector", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "ownerType", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "isCrossHire", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "ownerType", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocatedPvArea", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocatedPvArea", "order": "ASCENDING" },
        { "fieldPath": "allocatedBlockNumber", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "allocationStatus", "order": "ASCENDING" },
        { "fieldPath": "allocatedPvArea", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "assets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetName", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "assets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetName", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "plantAssetHours",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetHours",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetHours",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetHours",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetOperatorHistory",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "changeDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetOperatorHistory",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "changeDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetOperatorHistory",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "newOperatorId", "order": "ASCENDING" },
        { "fieldPath": "changeDate", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "subMenuId", "order": "ASCENDING" },
        { "fieldPath": "activityId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "level", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "level", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "subMenuId", "order": "ASCENDING" },
        { "fieldPath": "level", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "boq",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "requests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "requests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "updatedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "requests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "requests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "activityId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "activityId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "scopeRequested", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "qcRequested", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "cablingRequested", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "terminationRequested", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "toUserId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "fromUserId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "toUserId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "fromUserId", "order": "ASCENDING" },
        { "fieldPath": "toUserId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "fromUserId", "order": "ASCENDING" },
        { "fieldPath": "toUserId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "employeeIdNumber", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "currentCompanyId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "history",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "history",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "lockType", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "history",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "qcStatus", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "progressEntries",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "supervisorId", "order": "ASCENDING" },
        { "fieldPath": "enteredAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "progressEntries",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "enteredAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "progressEntries",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "enteredAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "progressEntries",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "activityId", "order": "ASCENDING" },
        { "fieldPath": "enteredAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "onboardingMessages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "toUserId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "handoverRequests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "requestType", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "activation_codes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "code", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activation_codes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "activationCodeId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companies",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companies",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "industrySector", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companies",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "industrySector", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companies",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "createdBy", "order": "ASCENDING" },
        { "fieldPath": "industrySector", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companies",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "subcontractors",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "subcontractors",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "subcontractors",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "subcontractors",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "plantAssetTypes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetTypes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "groupId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetGroups",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isAvailableForVAS", "order": "ASCENDING" },
        { "fieldPath": "groupId", "order": "ASCENDING" },
        { "fieldPath": "typeId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isAvailableForVAS", "order": "ASCENDING" },
        { "fieldPath": "ownerProvince", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "timesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "timesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "timesheets",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "faceTemplates",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "faceClockAttempts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "faceClockAttempts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "verificationState", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "faceClockAttempts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "offlineMode", "order": "ASCENDING" },
        { "fieldPath": "syncedToServer", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "faceClockAttempts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "verificationState", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "faceClockAttempts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "mainMenu",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "order", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "mainMenu",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "order", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "subMenus",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "order", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "menuActivities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "mainMenuId", "order": "ASCENDING" },
        { "fieldPath": "subMenuId", "order": "ASCENDING" },
        { "fieldPath": "order", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "activities",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "blockId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "activityId", "order": "ASCENDING" },
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockAreaId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockAreaId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "pvAreaId", "order": "ASCENDING" },
        { "fieldPath": "blockAreaId", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "lastUpdatedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "gridCellProgress",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "taskId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "row", "order": "ASCENDING" },
        { "fieldPath": "column", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "dailyChecklists",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyChecklists",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyChecklists",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyChecklists",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyChecklists",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "verifiedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "ownerType", "order": "ASCENDING" },
        { "fieldPath": "verifiedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "verifiedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "__name__", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "verifiedAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "dateRange.from", "order": "ASCENDING" },
        { "fieldPath": "dateRange.to", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "originalTimesheetId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "verified", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "operatorTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "originalTimesheetId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "pendingAgreements",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "employeeSiteLinks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "employeeId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employeeSiteLinks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employeeSiteLinks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "employeeId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "employeeSiteLinks",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "assignedAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "plantAssetAllocations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetAllocations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetAllocations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetAllocations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "allocatedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssetAllocations",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "allocatedAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "marketplaceListings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" },
        { "fieldPath": "listedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "marketplaceListings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "availability", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" },
        { "fieldPath": "listedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "marketplaceListings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetType", "order": "ASCENDING" },
        { "fieldPath": "availability", "order": "ASCENDING" },
        { "fieldPath": "listedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "marketplaceListings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "timesheetType", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "agreedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "timesheetType", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "nationalIdNumber", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "idVerificationStatus", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "duplicateIdStatus", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "companyOwnership",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "grantedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companyOwnership",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "grantedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companyOwnership",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "companyOwnership",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "ownershipPercentage", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "companyRoles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "assignedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companyRoles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "assignedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "companyRoles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "masterIDVerification",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterIDVerification",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "nationalIdNumber", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "masterIDVerification",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "submittedAt", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "fraudDisputes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "nationalIdNumber", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "fraudDisputes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "priority", "order": "DESCENDING" },
        { "fieldPath": "reportedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "fraudDisputes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "reportedBy", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "reportedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "fraudDisputes",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "existingAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "ownershipChangeRequests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ownershipChangeRequests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "requestedBy", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ownershipChangeRequests",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "targetMasterAccountId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "actionType", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "actionType", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "companyId", "order": "ASCENDING" },
        { "fieldPath": "actionType", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "masterAccountAuditLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "performedBy", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" },
        { "fieldPath": "timesheetType", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "timesheetType", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "verifiedTimesheets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "operatorId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "marketplaceListings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "assetId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "emhPendingEdits",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ephReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "subcontractorId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "plantAssets",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "siteId", "order": "ASCENDING" }
      ]
    },

    {
      "collectionGroup": "vasSubscriptions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "state", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "vasSubscriptions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "featureId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "vasSubscriptions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "state", "order": "ASCENDING" },
        { "fieldPath": "trialEndDate", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "vasSubscriptions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "state", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },

    {
      "collectionGroup": "adminNotifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "adminNotifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isRead", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "adminNotifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "priority", "order": "DESCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "adminNotifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "masterAccountId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "adminNotifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "isRead", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": [],
  "deployNote": "CRITICAL: After editing this file, run 'firebase deploy --only firestore:indexes' to deploy all indexes. This comprehensive index file includes all collections: sites, tasks, employees, plantAssets, BOQ, requests, activities, messages, users, companies, subcontractors, timesheets, face clock system, menu management, PV grid tracking (pvAreaId, blockId, row, column), EPH agreement workflow (ephPendingEdits, pendingAgreements, agreedTimesheets), master account verification system (masterAccounts, companyOwnership, companyRoles, masterIDVerification, fraudDisputes, ownershipChangeRequests, masterAccountAuditLogs), VAS subscriptions (vasSubscriptions), and admin notifications (adminNotifications), and all multi-tenant indexes."
}


--- END OF FILE: firestore.indexes.json ---


================================================================================
CATEGORY: Navigation Entry Points
FILE: app/accounts/index.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Platform,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FileText, BarChart3, List } from 'lucide-react-native';
import { collection, query, where, getDocs } from 'firebase/firestore';

import { useAuth } from '@/contexts/AuthContext';
import { db } from '@/config/firebase';
import PlantAssetsTimesheetsTab from '@/components/accounts/PlantAssetsTimesheetsTab';
import ProgressViewDashboard from '@/components/ProgressViewDashboard';
import DashboardFilterSidebar from '@/components/DashboardFilterSidebar';
import ExportJobsList from '@/components/accounts/ExportJobsList';
import type { FilterValues } from '@/components/accounts/FiltersBar';
import type { ExportRequest } from '@/components/accounts/ExportRequestModal';
import type { ExportJob } from '@/components/accounts/ExportJobsList';
import { handleExportRequest, downloadFile } from '@/utils/accounts/exportHandler';
import { calculatePerUserScopeProgress, SupervisorScopeProgress } from '@/utils/progressCalculations';
import type { ViewType, FilterLevel, DashboardSection, TimeRangeType } from '@/components/DashboardFilterSidebar';

type TabKey = 'assets' | 'progress' | 'jobs';

interface FilterState {
  level: FilterLevel;
  pvAreaId?: string;
  blockAreaId?: string;
  supervisorId?: string;
}

export default function AccountsIndexScreen() {
  const [activeTab, setActiveTab] = useState<TabKey>('progress');
  const [filters, setFilters] = useState<FilterValues>({});
  const [jobs, setJobs] = useState<ExportJob[]>([]);
  const [loadingJobs, setLoadingJobs] = useState(false);
  
  const [dashboardSection, setDashboardSection] = useState<DashboardSection>('PROGRESS');
  const [viewType, setViewType] = useState<ViewType>('TASKS_PROGRESS');
  const [filterState, setFilterState] = useState<FilterState>({ level: 'ALL' });
  const [progressData, setProgressData] = useState<SupervisorScopeProgress[]>([]);
  const [loadingProgress, setLoadingProgress] = useState(true);
  const [pvAreas, setPvAreas] = useState<{ id: string; name: string }[]>([]);
  const [blockAreas, setBlockAreas] = useState<{ id: string; name: string; pvAreaId: string }[]>([]);
  const [supervisors, setSupervisors] = useState<{ id: string; name: string; role: string }[]>([]);
  const [timeRange, setTimeRange] = useState<TimeRangeType>('CURRENT_WEEK');
  const [customWeekDate, setCustomWeekDate] = useState<Date | undefined>(undefined);
  const [selectedMonthYear, setSelectedMonthYear] = useState<{ month: number; year: number } | undefined>(undefined);

  const handleTimeRangeChange = (range: TimeRangeType, customDate?: Date, monthYear?: { month: number; year: number }) => {
    setTimeRange(range);
    if (range === 'CUSTOM_WEEK' && customDate) {
      setCustomWeekDate(customDate);
    } else if (range === 'MONTHLY' && monthYear) {
      setSelectedMonthYear(monthYear);
    }
  };

  const { user } = useAuth();

  useEffect(() => {
    if (user?.siteId) {
      loadProgressData();
    } else {
      setLoadingProgress(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.siteId]);

  const loadProgressData = async () => {
    if (!user?.siteId) {
      console.log('[Dashboard] No siteId available');
      setLoadingProgress(false);
      return;
    }

    console.log('[Dashboard] Loading progress data for site:', user.siteId);
    setLoadingProgress(true);

    try {
      const [supervisorProgress, pvAreasData, blockAreasData, supervisorsData] = await Promise.all([
        calculatePerUserScopeProgress(user.siteId),
        loadPvAreas(user.siteId),
        loadBlockAreas(user.siteId),
        loadSupervisors(user.siteId),
      ]);

      console.log('[Dashboard] Progress data loaded:', supervisorProgress.length, 'supervisors');
      setProgressData(supervisorProgress);
      setPvAreas(pvAreasData);
      setBlockAreas(blockAreasData);
      setSupervisors(supervisorsData);
    } catch (error) {
      console.error('[Dashboard] Error loading progress:', error);
      Alert.alert('Error', 'Failed to load progress data');
    } finally {
      setLoadingProgress(false);
    }
  };

  const loadPvAreas = async (siteId: string): Promise<{ id: string; name: string }[]> => {
    try {
      const pvAreasRef = collection(db, 'pvAreas');
      const pvAreasQuery = query(pvAreasRef, where('siteId', '==', siteId));
      const snapshot = await getDocs(pvAreasQuery);
      return snapshot.docs.map(doc => ({
        id: doc.id,
        name: doc.data().name || doc.data().pvAreaName || `PV Area ${doc.id.slice(0, 8)}`,
      }));
    } catch (error) {
      console.error('[Dashboard] Error loading PV areas:', error);
      return [];
    }
  };

  const loadBlockAreas = async (siteId: string): Promise<{ id: string; name: string; pvAreaId: string }[]> => {
    try {
      const blocksRef = collection(db, 'pvBlocks');
      const blocksQuery = query(blocksRef, where('siteId', '==', siteId));
      const snapshot = await getDocs(blocksQuery);
      return snapshot.docs.map(doc => ({
        id: doc.id,
        name: doc.data().blockName || doc.data().name || `Block ${doc.id.slice(0, 8)}`,
        pvAreaId: doc.data().pvAreaId || '',
      }));
    } catch (error) {
      console.error('[Dashboard] Error loading block areas:', error);
      return [];
    }
  };

  const loadSupervisors = async (siteId: string): Promise<{ id: string; name: string; role: string }[]> => {
    try {
      const usersRef = collection(db, 'users');
      const usersQuery = query(usersRef, where('siteId', '==', siteId));
      const snapshot = await getDocs(usersQuery);
      const uniqueSupervisors = new Map<string, { id: string; name: string; role: string }>();
      
      snapshot.docs.forEach(doc => {
        const userData = doc.data();
        const userId = userData.userId || doc.id;
        const name = userData.name || userId;
        const role = userData.role || 'Unknown';
        uniqueSupervisors.set(userId, { id: userId, name, role });
      });
      
      return Array.from(uniqueSupervisors.values()).sort((a, b) => a.name.localeCompare(b.name));
    } catch (error) {
      console.error('[Dashboard] Error loading supervisors:', error);
      return [];
    }
  };

  const handleExport = async (request: ExportRequest) => {
    if (!user) {
      Alert.alert('Error', 'User not authenticated');
      return;
    }

    console.log('[Accounts] Handling export request:', request);

    try {
      const result = await handleExportRequest(request, user as never);

      if (!result.success) {
        Alert.alert('Export Failed', result.error || 'Unknown error occurred');
        return;
      }

      if (result.isLarge && result.jobId) {
        const newJob: ExportJob = {
          id: result.jobId,
          type: request.type,
          requestedBy: user.name || 'Unknown',
          requestedAt: new Date(),
          status: 'queued',
          params: {
            format: request.format,
            groupBy: request.groupBy,
          },
          recordCount: result.recordCount,
        };
        setJobs((prev) => [newJob, ...prev]);
        setActiveTab('jobs');
        Alert.alert(
          'Export Job Created',
          'Your export is being processed. You can track it in the Jobs tab.'
        );
      } else if (result.fileUrl) {
        downloadFile(
          result.fileUrl,
          `export_${request.type}_${Date.now()}.${request.format}`
        );
        Alert.alert('Success', 'Export downloaded successfully');
      }
    } catch (error) {
      console.error('[Accounts] Export error:', error);
      Alert.alert('Error', 'Failed to process export request');
    }
  };

  const handleDownloadJob = (jobId: string) => {
    console.log('[Accounts] Download job:', jobId);
    const job = jobs.find((j) => j.id === jobId);
    if (job?.fileUrl) {
      downloadFile(job.fileUrl, `export_${job.type}_${jobId}.csv`);
    }
  };

  const handleRetryJob = (jobId: string) => {
    console.log('[Accounts] Retry job:', jobId);
    setJobs((prev) =>
      prev.map((job) =>
        job.id === jobId ? { ...job, status: 'queued' as const } : job
      )
    );
  };

  const handleCancelJob = (jobId: string) => {
    console.log('[Accounts] Cancel job:', jobId);
    setJobs((prev) => prev.filter((job) => job.id !== jobId));
  };

  const handleRefreshJobs = () => {
    console.log('[Accounts] Refreshing jobs...');
    setLoadingJobs(true);
    setTimeout(() => setLoadingJobs(false), 500);
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tab, activeTab === 'assets' && styles.activeTab]}
          onPress={() => setActiveTab('assets')}
          testID="tab-assets-timesheets"
        >
          <FileText
            size={20}
            color={activeTab === 'assets' ? '#3b82f6' : '#64748b'}
            style={styles.tabIcon}
          />
          <Text
            style={[
              styles.tabText,
              activeTab === 'assets' && styles.activeTabText,
            ]}
          >
            Plant Assets
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, activeTab === 'progress' && styles.activeTab]}
          onPress={() => setActiveTab('progress')}
          testID="tab-progress-tracking"
        >
          <BarChart3
            size={20}
            color={activeTab === 'progress' ? '#3b82f6' : '#64748b'}
            style={styles.tabIcon}
          />
          <Text
            style={[
              styles.tabText,
              activeTab === 'progress' && styles.activeTabText,
            ]}
          >
            Progress
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, activeTab === 'jobs' && styles.activeTab]}
          onPress={() => setActiveTab('jobs')}
          testID="tab-export-jobs"
        >
          <List
            size={20}
            color={activeTab === 'jobs' ? '#3b82f6' : '#64748b'}
            style={styles.tabIcon}
          />
          <Text
            style={[
              styles.tabText,
              activeTab === 'jobs' && styles.activeTabText,
            ]}
          >
            Jobs
          </Text>
        </TouchableOpacity>
      </View>

      {activeTab === 'assets' && (
        <PlantAssetsTimesheetsTab
          filters={filters}
          onFiltersChange={setFilters}
          onExport={handleExport}
        />
      )}

      {activeTab === 'progress' && (
        <View style={styles.progressContainer}>
          {Platform.OS === 'web' && (
            <DashboardFilterSidebar
              onFilterChange={setFilterState}
              onViewChange={setViewType}
              onSectionChange={setDashboardSection}
              onTimeRangeChange={handleTimeRangeChange}
              currentSection={dashboardSection}
              currentView={viewType}
              currentFilter={filterState}
              currentTimeRange={timeRange}
              customWeekDate={customWeekDate}
              selectedMonthYear={selectedMonthYear}
              pvAreas={pvAreas}
              blockAreas={blockAreas}
              supervisors={supervisors}
            />
          )}
          <View style={styles.progressContent}>
            {loadingProgress ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#4285F4" />
                <Text style={styles.loadingText}>Loading progress data...</Text>
              </View>
            ) : (
              <ProgressViewDashboard
                siteId={user?.siteId || ''}
                data={progressData}
                viewType={viewType}
                filter={filterState}
                pvAreas={pvAreas}
                blockAreas={blockAreas}
                supervisors={supervisors}
              />
            )}
          </View>
        </View>
      )}

      {activeTab === 'jobs' && (
        <ExportJobsList
          jobs={jobs}
          loading={loadingJobs}
          onDownload={handleDownloadJob}
          onRetry={handleRetryJob}
          onCancel={handleCancelJob}
          onRefresh={handleRefreshJobs}
        />
      )}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  tabContainer: {
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    paddingHorizontal: 16,
    ...Platform.select({
      web: {
        flexDirection: 'row' as const,
      },
      default: {
        flexDirection: 'row' as const,
      },
    }),
  },
  tab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    paddingHorizontal: 8,
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  activeTab: {
    borderBottomColor: '#3b82f6',
  },
  tabIcon: {
    marginRight: 6,
  },
  tabText: {
    fontSize: 13,
    fontWeight: '600' as const,
    color: '#64748b',
  },
  activeTabText: {
    color: '#3b82f6',
  },
  progressContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  progressContent: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#5f6368',
    fontWeight: '500' as const,
  },
});


--- END OF FILE: app/accounts/index.tsx ---


================================================================================
CATEGORY: Navigation Entry Points
FILE: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from "expo-router";
import { Home, Settings } from "lucide-react-native";
import React from "react";
import { StyleSheet, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useAuth } from "@/contexts/AuthContext";
import { Colors, getRoleAccentColor } from "@/constants/colors";
import HeaderSyncStatus from "@/components/HeaderSyncStatus";

export default function TabLayout() {
  const insets = useSafeAreaInsets();
  const { user } = useAuth();
  const roleAccentColor = getRoleAccentColor(user?.role);

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors.accent,
        tabBarInactiveTintColor: '#666666',
        headerShown: true,
        tabBarShowLabel: false,

        headerStyle: {
          backgroundColor: Colors.headerBg,
          borderBottomWidth: 2,
          borderBottomColor: roleAccentColor,
        },
        headerTintColor: Colors.text,
        headerTitleStyle: {
          fontWeight: '600' as const,
          color: Colors.text,
        },
        headerTitleAlign: 'left',
        headerRight: () => <HeaderSyncStatus />,
        tabBarStyle: [
          styles.tabBar,
          {
            paddingBottom: Platform.OS === 'web' ? 8 : Math.max(insets.bottom, 8),
            height: Platform.OS === 'web' ? 60 : 60 + Math.max(insets.bottom, 0),
          }
        ],
        tabBarIconStyle: styles.tabBarIcon,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => <Home size={24} color={color} />,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: "Settings",
          tabBarIcon: ({ color }) => <Settings size={24} color={color} />,
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBar: {
    backgroundColor: Colors.background,
    borderTopWidth: 2,
    borderTopColor: Colors.accent,
    paddingTop: 8,
  },
  tabBarLabel: {
    fontSize: 12,
    fontWeight: '600' as const,
  },
  tabBarIcon: {
    marginBottom: -4,
  },
});


--- END OF FILE: app/(tabs)/_layout.tsx ---


================================================================================
CATEGORY: Navigation Entry Points
FILE: app/_layout.tsx
================================================================================

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Stack, router, usePathname } from "expo-router";
import React, { useEffect, Component, ErrorInfo, ReactNode, useCallback, useRef, useState } from "react";
import { View, Text, StyleSheet, TouchableOpacity, Platform, ActivityIndicator, InteractionManager, LayoutChangeEvent } from "react-native";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { RootSiblingParent } from 'react-native-root-siblings';
import { LinearGradient } from 'expo-linear-gradient';
import { AuthProvider, useAuth } from "../contexts/AuthContext";
import { PermissionsProvider } from "../contexts/PermissionsContext";
import { isManagementRole, isOperatorRole } from "../utils/roles";
import OfflineBanner from "../components/OfflineBanner";
import { offlineQueue } from "../utils/offlineQueue";
import { sitePackManager } from "../utils/sitePackManager";
import { dataFreshnessManager } from "../utils/dataFreshnessSync";
import FreshnessNotificationBanner from "../components/FreshnessNotificationBanner";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnWindowFocus: false,
      refetchOnMount: false,
    },
  },
});

interface ErrorBoundaryProps {
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    const errorMessage = error?.message || '';
    
    if (errorMessage.includes('Unable to activate keep awake')) {
      console.warn('[ErrorBoundary] Non-critical keep-awake error ignored');
      return { hasError: false, error: null };
    }
    
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const errorMessage = error?.message || '';
    
    if (errorMessage.includes('Unable to activate keep awake')) {
      console.warn('[ErrorBoundary] Non-critical keep-awake error suppressed:', error);
      this.setState({ hasError: false, error: null });
      return;
    }
    
    console.error('[ErrorBoundary] Caught error:', error);
    console.error('[ErrorBoundary] Error info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={errorBoundaryStyles.container}>
          <View style={errorBoundaryStyles.content}>
            <Text style={errorBoundaryStyles.title}>Something went wrong</Text>
            <Text style={errorBoundaryStyles.message}>
              {this.state.error?.message || 'An unexpected error occurred'}
            </Text>
            <TouchableOpacity
              style={errorBoundaryStyles.button}
              onPress={() => {
                this.setState({ hasError: false, error: null });
                router.replace('/login');
              }}
            >
              <Text style={errorBoundaryStyles.buttonText}>Go to Login</Text>
            </TouchableOpacity>
          </View>
        </View>
      );
    }

    return this.props.children;
  }
}

const errorBoundaryStyles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  content: {
    alignItems: 'center',
    maxWidth: 400,
  },
  title: {
    fontSize: 24,
    fontWeight: '700' as const,
    color: '#1e293b',
    marginBottom: 16,
    textAlign: 'center' as const,
  },
  message: {
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center' as const,
    marginBottom: 32,
    lineHeight: 24,
  },
  button: {
    backgroundColor: '#3b82f6',
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 12,
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '600' as const,
    color: '#fff',
  },
});

interface RootLayoutNavProps {
  onReady: () => void;
}

function RootLayoutNav({ onReady }: RootLayoutNavProps) {
  const { user, masterAccount, isLoading, authInitializing } = useAuth();
  const navigationAttempted = useRef(false);
  const qrLoginInProgress = useRef(false);
  const pathname = usePathname();
  const previousUserIdRef = useRef<string | null>(null);
  const [isNavigatorReady, setIsNavigatorReady] = useState(false);

  // Debug logging
  useEffect(() => {
    console.log('[RootLayoutNav Debug] State:', JSON.stringify({
      isLoading,
      authInitializing,
      hasUser: !!user,
      userRole: user?.role,
      hasMasterAccount: !!masterAccount,
      pathname,
      isNavigatorReady
    }));
    
    if (user) {
      console.log('[RootLayoutNav Debug] User details:', JSON.stringify(user));
    }
  }, [isLoading, authInitializing, user, masterAccount, pathname, isNavigatorReady]);

  // Mark navigator as ready after render completes
  // FIX for "Attempted to navigate before mounting the Root Layout component" error:
  // This useEffect ensures the Stack navigator is fully mounted before any navigation
  // attempts occur. Without this, there's a race condition where auth initialization
  // completes and triggers navigation before the navigator is ready to handle it.
  useEffect(() => {
    // Call onReady synchronously to notify parent immediately
    onReady();
    
    // Use InteractionManager to wait for all interactions and animations to complete
    // This is more reliable than a fixed timeout as it waits for actual readiness
    const interaction = InteractionManager.runAfterInteractions(() => {
      console.log('[RootLayoutNav] Navigator marked as ready after interactions complete');
      setIsNavigatorReady(true);
    });
    
    return () => interaction.cancel();
  }, [onReady]);

  useEffect(() => {
    // CRITICAL FIX: Only perform navigation when BOTH auth is ready AND navigator is mounted
    if (authInitializing || isLoading) {
      console.log('[RootLayoutNav] Auth initializing or loading, waiting...', { authInitializing, isLoading });
      return;
    }
    
    if (!isNavigatorReady) {
      console.log('[RootLayoutNav] Navigator not ready yet, deferring navigation');
      return;
    }
    
    // Use a flag to prevent navigation after unmount
    let isActive = true;
    
    const currentUserId = user?.userId || masterAccount?.masterId || null;
    const currentUserRole = user?.role || null;
    
    if (currentUserId !== previousUserIdRef.current) {
      console.log('[RootLayout] User changed from', previousUserIdRef.current, 'to', currentUserId, 'role:', currentUserRole);
      console.log('[RootLayout] Resetting navigationAttempted flag and qrLoginInProgress');
      navigationAttempted.current = false;
      qrLoginInProgress.current = false;
      previousUserIdRef.current = currentUserId;
    }
    
    const currentPath = pathname ?? '/';
    console.log('[RootLayout] Current path:', currentPath);
    console.log('[RootLayout] User:', user?.userId, 'Role:', user?.role);
    console.log('[RootLayout] Master:', masterAccount?.masterId);
    console.log('[RootLayout] Navigation attempted:', navigationAttempted.current);
    
    const publicPaths = ['/login', '/master-signup', '/activate', '/setup-master-pin', '/setup-employee-pin', '/admin-pin-verify', '/admin-panel', '/company-selector', '/company-setup', '/qr-scanner'];
    const setupPaths = ['/setup-master-pin', '/setup-employee-pin'];
    
    // Defer all navigation to next tick to prevent state updates during render
    const performNavigation = (destination: string) => {
      if (!isActive) return;
      navigationAttempted.current = true;
      setTimeout(() => {
        if (!isActive) return;
        try {
          router.replace(destination as any);
          console.log('[RootLayout] Navigation to', destination, 'completed');
        } catch (error) {
          console.error('[RootLayout] Navigation error:', error);
          navigationAttempted.current = false;
        }
      }, 0);
    };
    
    if (!user && !masterAccount) {
      if (!publicPaths.includes(currentPath) && !navigationAttempted.current) {
        console.log('[RootLayout] No user, redirecting to login from:', currentPath);
        performNavigation('/login');
      }
      return () => { isActive = false; };
    }
    
    if ((user || masterAccount) && setupPaths.includes(currentPath)) {
      console.log('[RootLayout] User on setup path, not interfering');
      return () => { isActive = false; };
    }
    
    if ((user || masterAccount) && publicPaths.includes(currentPath)) {
      navigationAttempted.current = false;
    }
    
    // CRITICAL: Only check user.role for master routing, NOT masterAccount state
    // masterAccount is just a cached reference and shouldn't affect routing logic
    const isMasterUser = user?.role === 'master';
    if (isMasterUser) {
      const masterData = user;
      const hasCompanies = masterData?.companyIds && masterData.companyIds.length > 0;
      const hasSelectedCompany = !!masterData?.currentCompanyId;
      const hasSelectedSite = !!(user?.siteId && user?.siteName);
      
      console.log('[RootLayout] Master account state:');
      console.log('[RootLayout]   isMasterUser:', isMasterUser);
      console.log('[RootLayout]   hasCompanies:', hasCompanies, 'IDs:', masterData?.companyIds);
      console.log('[RootLayout]   hasSelectedCompany:', hasSelectedCompany, 'Current:', masterData?.currentCompanyId);
      console.log('[RootLayout]   hasSelectedSite:', hasSelectedSite, 'Site:', user?.siteName);
      console.log('[RootLayout]   accountType:', user?.accountType);
      
      if (!hasCompanies && currentPath !== '/company-setup' && !navigationAttempted.current) {
        console.log('[RootLayout]  Master has no companies  Routing to /company-setup');
        performNavigation('/company-setup');
        return () => { isActive = false; };
      }
      
      if (hasCompanies && !hasSelectedCompany && currentPath !== '/company-selector' && !navigationAttempted.current) {
        console.log('[RootLayout]  Master has companies but none selected  Routing to /company-selector');
        performNavigation('/company-selector');
        return () => { isActive = false; };
      }
      
      if (hasSelectedCompany && hasSelectedSite && currentPath !== '/(tabs)' && !publicPaths.includes(currentPath) && !navigationAttempted.current && !currentPath.startsWith('/(tabs)')) {
        console.log('[RootLayout]  Master has selected company and site  Routing to /(tabs)');
        performNavigation('/(tabs)');
        return () => { isActive = false; };
      }
      
      if (hasSelectedCompany && !hasSelectedSite && !publicPaths.includes(currentPath) && !navigationAttempted.current) {
        // After company selection, go directly to main tabs - site creation is optional and done in settings
        console.log('[RootLayout]  Master with selected company (no site required)  Routing to /(tabs)');
        if (currentPath !== '/(tabs)' && !currentPath.startsWith('/(tabs)')) {
          performNavigation('/(tabs)');
        }
      }
      return () => { isActive = false; };
    }
    
    if (user) {
      const hasCompanies = user.companyIds && user.companyIds.length > 0;
      const hasSelectedCompany = !!user.currentCompanyId;
      const isManagementUser = isManagementRole(user.role);
      
      console.log('[RootLayout] User check - role:', user.role, 'isManagement:', isManagementUser, 'path:', currentPath);
      
      if (currentPath === '/qr-scanner') {
        console.log('[RootLayout]   User is on QR scanner screen, BLOCKING all auto-navigation');
        qrLoginInProgress.current = true;
        return () => { isActive = false; };
      }
      
      if (qrLoginInProgress.current && currentPath !== '/qr-scanner') {
        console.log('[RootLayout] QR login completed, user is now on:', currentPath);
        qrLoginInProgress.current = false;
      }
      
      if (hasCompanies && !hasSelectedCompany && currentPath !== '/company-selector' && !navigationAttempted.current) {
        console.log('[RootLayout]  User has companies but none selected  Routing to /company-selector');
        performNavigation('/company-selector');
        return () => { isActive = false; };
      }
      
      if (publicPaths.includes(currentPath) && !navigationAttempted.current && !qrLoginInProgress.current) {
        console.log('[RootLayout]  User logged in from public path, routing to home screen');
        console.log('[RootLayout]   User ID:', user.userId, 'Role:', user.role);
        
        const isOperator = isOperatorRole(user.role);
        const destination = isManagementUser ? '/(tabs)' : isOperator ? '/operator-home' : '/employee-timesheet';
        
        console.log('[RootLayout] Is management role:', isManagementUser, '(role:', user.role, ') Routing to:', destination);
        performNavigation(destination);
      }
    }
    
    return () => { isActive = false; };
  }, [user, masterAccount, isLoading, authInitializing, pathname, isNavigatorReady]);

  if (isLoading || authInitializing) {
    console.log('[RootLayout] Rendering loading screen...', { isLoading, authInitializing });
    return (
      <LinearGradient
        colors={['#1e3a8a', '#3b82f6', '#60a5fa']}
        style={{ flex: 1 }}
      >
        <View 
          style={{ 
            flex: 1, 
            justifyContent: 'center', 
            alignItems: 'center'
          }}
        >
          <View style={{ alignItems: 'center', gap: 16 }}>
            <ActivityIndicator size="large" color="#ffffff" />
            <Text style={{ 
              fontSize: 28, 
              color: '#ffffff', 
              fontWeight: '700' as const 
            }}>Machine App</Text>
            <Text style={{ 
              fontSize: 14, 
              color: '#cbd5e1'
            }}>Loading...</Text>
          </View>
        </View>
      </LinearGradient>
    );
  }

  console.log('[RootLayout] Loading complete, rendering main app');

  return (
    <View style={{ flex: 1, pointerEvents: 'auto' }} collapsable={false}>
      <OfflineBanner showDetails={false} />
      <FreshnessNotificationBanner />
      <Stack
        screenOptions={{
          headerBackTitle: "Back",
          headerStyle: {
            backgroundColor: '#000000',
          },
          headerTintColor: '#FFFFFF',
          headerTitleStyle: {
            fontWeight: '600' as const,
            color: '#FFFFFF',
          },
          headerTitleAlign: 'left',
          contentStyle: {
            backgroundColor: '#000000',
          },
        }}
      >
        <Stack.Screen name="login" options={{ headerShown: false }} />
        <Stack.Screen name="activate" options={{ headerShown: false }} />
        <Stack.Screen name="setup-master-pin" options={{ headerShown: false }} />
        <Stack.Screen name="setup-employee-pin" options={{ headerShown: false }} />
        <Stack.Screen name="admin-pin-verify" options={{ headerShown: false, presentation: 'modal' }} />
        <Stack.Screen name="admin-panel" options={{ headerShown: false, presentation: 'modal' }} />
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="supervisor-activity" />
        <Stack.Screen name="supervisor-task-request" />
        <Stack.Screen name="supervisor-task-detail" />
        <Stack.Screen name="company-settings" />
        <Stack.Screen name="manage-users" />
        <Stack.Screen name="add-user" />
        <Stack.Screen name="master-company-profile" options={{ headerShown: false }} />
        <Stack.Screen name="master-planner" />
        <Stack.Screen name="master-supervisor" />
        <Stack.Screen name="planner-task-requests" />
        <Stack.Screen name="planner-activity-requests" />
        <Stack.Screen name="planner-qc-requests" />
        <Stack.Screen name="planner-cabling-requests" />
        <Stack.Screen name="planner-termination-requests" />
        <Stack.Screen name="master-sites" />
        <Stack.Screen name="planner-surveyor-requests" />
        <Stack.Screen name="edit-user" />
        <Stack.Screen name="master-plant-manager" />
        <Stack.Screen name="master-staff-manager" />
        <Stack.Screen name="master-logistics-manager" />
        <Stack.Screen name="planner-handover-requests" />
        <Stack.Screen name="planner-concrete-requests" />
        <Stack.Screen name="master-dashboard" />
        <Stack.Screen name="plant-allocation-requests" />
        <Stack.Screen name="employee-timesheet" options={{ headerShown: false }} />
        <Stack.Screen name="employee-profile" options={{ headerShown: false }} />
        <Stack.Screen name="operator-home" options={{ headerShown: false }} />
        <Stack.Screen name="operator-man-hours" options={{ headerShown: false }} />
        <Stack.Screen name="operator-plant-hours" options={{ headerShown: false }} />
        <Stack.Screen name="operator-checklist" options={{ headerShown: false }} />
        <Stack.Screen name="operator-checklist-plant" options={{ headerShown: false }} />
        <Stack.Screen name="operator-hours-dashboard" options={{ headerShown: false }} />
        <Stack.Screen name="qr-scanner" options={{ headerShown: false }} />
        <Stack.Screen name="generate-qr" />
        <Stack.Screen name="generate-plant-qr" />
        <Stack.Screen name="print-qr-codes" />
        <Stack.Screen name="face-clock" options={{ headerShown: false }} />
        <Stack.Screen name="face-enrollment" />
        <Stack.Screen name="site-face-settings" />
        <Stack.Screen name="add-employee" />
        <Stack.Screen name="add-asset" />
        <Stack.Screen name="add-subcontractor" />
        <Stack.Screen name="edit-subcontractor" />
        <Stack.Screen name="company-selector" options={{ headerShown: false }} />
        <Stack.Screen name="company-setup" options={{ headerShown: false }} />
        <Stack.Screen name="master-signup" options={{ headerShown: false }} />
        <Stack.Screen name="company-employees" />
        <Stack.Screen name="company-assets" />
        <Stack.Screen name="master-menu-manager" />
        <Stack.Screen name="sub-menu-detail" />
        <Stack.Screen name="seed-menus" />
        <Stack.Screen name="plant-allocation-overview" />
        <Stack.Screen name="staff-allocation-overview" />
        <Stack.Screen name="plant-manager-assets" />
        <Stack.Screen name="plant-manager-diary" />
        <Stack.Screen name="plant-manager-timesheets" />
        <Stack.Screen name="staff-manager-employees" />
        <Stack.Screen name="staff-requests" />
        <Stack.Screen name="resource-requests" />
        <Stack.Screen name="plant-asset-actions" />
        <Stack.Screen name="plant-asset-marketplace" />
        <Stack.Screen name="plant-asset-operator-change" />
        <Stack.Screen name="plant-asset-types" />
        <Stack.Screen name="materials-requests" />
        <Stack.Screen name="qc-requests" />
        <Stack.Screen name="qc-scheduled" />
        <Stack.Screen name="qc-completed" />
        <Stack.Screen name="planner-commissioning-requests" />
        <Stack.Screen name="progress-report" />
        <Stack.Screen name="master-pv-blocks" />
        <Stack.Screen name="master-subcontractors" />
        <Stack.Screen name="task-activities" />
        <Stack.Screen name="activity-detail" />
        <Stack.Screen name="daily-diary" />
        <Stack.Screen name="supervisor-messages" />
        <Stack.Screen name="messages" />
        <Stack.Screen name="onboarding-dashboard" />
        <Stack.Screen name="onboarding-employees" />
        <Stack.Screen name="onboarding-employee-detail" />
        <Stack.Screen name="onboarding-assets" />
        <Stack.Screen name="onboarding-asset-detail" />
        <Stack.Screen name="onboarding-messages" />
        <Stack.Screen name="chat" />
        <Stack.Screen name="archived-checklist-detail" />
        <Stack.Screen name="billing-config" />
        <Stack.Screen name="dumbass" />
        <Stack.Screen name="accounts" options={{ headerShown: false }} />
        <Stack.Screen name="account-info" />
        <Stack.Screen name="debug-info" />
        <Stack.Screen name="debug-progress" />
        <Stack.Screen name="diagnose-site-data" />
        <Stack.Screen name="log-breakdown" />
        <Stack.Screen name="per-user-progress" />
        <Stack.Screen name="user-progress-detail" />
        <Stack.Screen name="diesel-clerk-home" options={{ headerShown: false }} />
        <Stack.Screen name="diesel-clerk-fuel-log" />
        <Stack.Screen name="eph-inbox" />
        <Stack.Screen name="eph-menu" />
        <Stack.Screen name="emh-inbox" />
        <Stack.Screen name="emh-menu" />
        <Stack.Screen name="billing-menu" />
        <Stack.Screen name="man-hours" />
        <Stack.Screen name="machine-hours" />
      </Stack>
    </View>
  );
}

export default function RootLayout() {
  console.log('[RootLayout] Component rendering - TOP LEVEL');
  const hasHiddenSplash = useRef(false);
  const hasInitializedManagers = useRef(false);

  const handleNavReady = useCallback(() => {
    // Navigation ready callback (kept for future use)
  }, []);

  const handleRootLayout = useCallback((_event: LayoutChangeEvent) => {
    if (hasHiddenSplash.current) {
      return;
    }

    hasHiddenSplash.current = true;
    console.log('[RootLayout] Layout ready');
  }, []);

  useEffect(() => {
    if (hasInitializedManagers.current) {
      return;
    }
    hasInitializedManagers.current = true;

    setTimeout(() => {
      InteractionManager.runAfterInteractions(() => {
        console.log('[RootLayout] Starting lazy initialization...');
        
        const isIOS = Platform.OS === 'ios';
        const offlineTimeout = isIOS ? 300 : 600;
        const sitePackTimeout = isIOS ? 200 : 400;
        
        Promise.all([
          offlineQueue.init(offlineTimeout).catch(err => {
            console.warn('[RootLayout] offlineQueue init deferred:', err?.message);
          }),
          sitePackManager.init(sitePackTimeout).catch(err => {
            console.warn('[RootLayout] sitePackManager init deferred:', err?.message);
          }),
          dataFreshnessManager.init().catch(err => {
            console.warn('[RootLayout] dataFreshnessManager init deferred:', err?.message);
          })
        ]).then(() => {
          console.log('[RootLayout]  Background services ready');
        }).catch(err => {
          console.warn('[RootLayout] Background init non-fatal error:', err?.message);
        });
      });
    }, 1000);
  }, []);

  console.log('[RootLayout] About to render providers...');
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <AuthProvider>
          <PermissionsProvider>
            <RootSiblingParent>
              <GestureHandlerRootView style={{ flex: 1 }} onLayout={handleRootLayout}>
                <RootLayoutNav onReady={handleNavReady} />
              </GestureHandlerRootView>
            </RootSiblingParent>
          </PermissionsProvider>
        </AuthProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}


--- END OF FILE: app/_layout.tsx ---


================================================================================
END OF OLD_EPH_Complete
================================================================================

